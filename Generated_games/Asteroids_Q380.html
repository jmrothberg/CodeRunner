<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroids - 1979 Atari Original</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        canvas {
            border: 1px solid #333;
            background-color: #000;
        }
        #gameInfo {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div id="gameInfo">SCORE: 0 | LIVES: 3 | LEVEL: 1</div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        // Game canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const infoDisplay = document.getElementById('gameInfo');

        // Game constants
        const SCREEN_WIDTH = canvas.width;
        const SCREEN_HEIGHT = canvas.height;
        const SHIP_SIZE = 15;
        const THRUST_LENGTH = 8;
        const BULLET_SPEED = 7;
        const ASTEROID_SIZES = [40, 25, 15]; // Large, medium, small
        const MAX_BULLETS = 5;
        const UFO_SPAWN_CHANCE = 0.003; // Chance per frame to spawn UFO
        const UFO_LARGE_SPEED = 1.2;
        const UFO_SMALL_SPEED = 2.5;
        const UFO_SHOOT_CHANCE = 0.008;

        // Game state
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameOver = false;
        let gameStarted = false;
        let extraLifeScore = 10000; // Earn extra life at 10,000 points

        // Player ship
        const ship = {
            x: SCREEN_WIDTH / 2,
            y: SCREEN_HEIGHT / 2,
            radius: SHIP_SIZE,
            angle: 0,
            rotation: 0,
            thrusting: false,
            velocityX: 0,
            velocityY: 0,
            friction: 0.98,
            acceleration: 0.3,
            maxSpeed: 5,
            invulnerable: false,
            invulnerabilityTimer: 0,
            flashTimer: 0
        };

        // Arrays for game objects
        let asteroids = [];
        let bullets = [];
        let ufos = [];

        // Input handling
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // Start game on any key press if not started
            if (!gameStarted && !gameOver) {
                gameStarted = true;
                initGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Initialize game
        function initGame() {
            // Reset ship
            ship.x = SCREEN_WIDTH / 2;
            ship.y = SCREEN_HEIGHT / 2;
            ship.angle = 0;
            ship.rotation = 0;
            ship.velocityX = 0;
            ship.velocityY = 0;
            ship.thrusting = false;
            ship.invulnerable = true;
            ship.invulnerabilityTimer = 120; // 2 seconds at 60fps
            
            // Clear existing objects
            asteroids = [];
            bullets = [];
            ufos = [];
            
            // Create initial asteroids (4 large)
            for (let i = 0; i < 4; i++) {
                createAsteroid(ASTEROID_SIZES[0]);
            }
            
            // Reset score display
            updateScoreDisplay();
        }

        // Create asteroid with specified size
        function createAsteroid(size) {
            let x, y;
            do {
                x = Math.random() * SCREEN_WIDTH;
                y = Math.random() * SCREEN_HEIGHT;
            } while (distance(x, y, ship.x, ship.y) < 100); // Avoid spawning near ship
            
            const asteroid = {
                x: x,
                y: y,
                size: size,
                radius: size / 2,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.03,
                vertices: [],
                velocityX: (Math.random() - 0.5) * 2,
                velocityY: (Math.random() - 0.5) * 2
            };
            
            // Generate irregular jagged shape with 8-12 points
            const numPoints = 8 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                // Vary radius to create jagged appearance
                const radiusVariation = 0.7 + Math.random() * 0.6;
                asteroid.vertices.push({
                    angle: angle,
                    distance: size / 2 * radiusVariation
                });
            }
            
            asteroids.push(asteroid);
        }

        // Create UFO (random type)
        function createUFO() {
            const isLarge = Math.random() > 0.5;
            const ufo = {
                x: isLarge ? 
                    (Math.random() < 0.5 ? -30 : SCREEN_WIDTH + 30) : 
                    (Math.random() < 0.5 ? -20 : SCREEN_WIDTH + 20),
                y: Math.random() * SCREEN_HEIGHT,
                size: isLarge ? 30 : 18,
                radius: isLarge ? 15 : 9,
                type: isLarge ? 'large' : 'small',
                speed: isLarge ? UFO_LARGE_SPEED : UFO_SMALL_SPEED,
                rotation: 0,
                velocityX: isLarge ? 
                    (Math.random() < 0.5 ? 1 : -1) * UFO_LARGE_SPEED : 
                    (Math.random() < 0.5 ? 1 : -1) * UFO_SMALL_SPEED,
                velocityY: (Math.random() - 0.5) * (isLarge ? 0.8 : 1.5),
                shootTimer: 0,
                alive: true
            };
            
            // Ensure UFO doesn't spawn too close to ship
            if (distance(ufo.x, ufo.y, ship.x, ship.y) < 150) {
                return;
            }
            
            ufos.push(ufo);
        }

        // Calculate distance between two points
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // Draw ship with thrust flame animation
        function drawShip() {
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);
            
            // Ship outline - white wireframe triangle
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(0, -ship.radius); // nose
            ctx.lineTo(-ship.radius/1.5, ship.radius/1.2); // left wing
            ctx.lineTo(ship.radius/1.5, ship.radius/1.2); // right wing
            ctx.closePath();
            ctx.stroke();
            
            // Thrust flame animation - flickering white-orange lines
            if (ship.thrusting && !ship.invulnerable) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                
                // Create multiple flame segments for flicker effect
                for (let i = 0; i < 3; i++) {
                    const flameLength = THRUST_LENGTH * (0.7 + Math.random() * 0.3);
                    const flameOffset = ship.radius/2 + i * 1;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, ship.radius/1.2);
                    ctx.lineTo(
                        Math.sin(ship.angle + Math.PI) * flameLength * 0.5,
                        (ship.radius/1.2 + flameLength)
                    );
                    ctx.stroke();
                }
                
                // Add flickering glow effect
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, ship.radius/1.2);
                ctx.lineTo(
                    Math.sin(ship.angle + Math.PI) * (THRUST_LENGTH + 4),
                    (ship.radius/1.2 + THRUST_LENGTH + 4)
                );
                ctx.stroke();
            }
            
            // Flash effect when invulnerable
            if (ship.invulnerable && ship.flashTimer > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, -ship.radius);
                ctx.lineTo(-ship.radius/1.5, ship.radius/1.2);
                ctx.lineTo(ship.radius/1.5, ship.radius/1.2);
                ctx.closePath();
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Draw asteroids with wireframe jagged outlines
        function drawAsteroids() {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            
            for (let asteroid of asteroids) {
                ctx.save();
                ctx.translate(asteroid.x, asteroid.y);
                ctx.rotate(asteroid.rotation);
                
                ctx.beginPath();
                for (let i = 0; i < asteroid.vertices.length; i++) {
                    const vertex = asteroid.vertices[i];
                    const x = Math.cos(vertex.angle) * vertex.distance;
                    const y = Math.sin(vertex.angle) * vertex.distance;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
                
                // Add subtle rotation glow effect
                if (asteroid.rotationSpeed !== 0) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    for (let i = 0; i < asteroid.vertices.length; i++) {
                        const vertex = asteroid.vertices[i];
                        const x = Math.cos(vertex.angle) * vertex.distance;
                        const y = Math.sin(vertex.angle) * vertex.distance;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        // Draw bullets as simple white dots
        function drawBullets() {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            
            for (let bullet of bullets) {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 1.5, 0, Math.PI * 2);
                ctx.stroke();
                
                // Add subtle trail effect
                if (bullet.age > 10) {
                    const alpha = 1 - (bullet.age / 60); // Fade out after 60 frames
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 1.5 + (bullet.age * 0.03), 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        // Draw UFOs as classic flying saucer wireframes
        function drawUfos() {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            
            for (let ufo of ufos) {
                if (!ufo.alive) continue;
                
                ctx.save();
                ctx.translate(ufo.x, ufo.y);
                ctx.rotate(ufo.rotation);
                
                // UFO body - oval shape
                ctx.beginPath();
                ctx.ellipse(0, 0, ufo.radius * 1.5, ufo.radius * 0.8, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // UFO center dome
                ctx.beginPath();
                ctx.arc(0, -ufo.radius/3, ufo.radius/2, 0, Math.PI * 2);
                ctx.stroke();
                
                // UFO bottom glow (for large UFOs)
                if (ufo.type === 'large') {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(0, ufo.radius/2, ufo.radius * 1.2, ufo.radius/3, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // UFO engine glow (flickering)
                if (Math.random() > 0.7) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 1;
                    
                    // Bottom glow
                    ctx.beginPath();
                    ctx.moveTo(-ufo.radius/1.5, ufo.radius);
                    ctx.lineTo(-ufo.radius/3, ufo.radius + 4);
                    ctx.lineTo(ufo.radius/3, ufo.radius + 4);
                    ctx.lineTo(ufo.radius/1.5, ufo.radius);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        // Draw explosion effect
        function drawExplosion(x, y, size) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const length = size * (0.5 + Math.random() * 0.5);
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(
                    x + Math.cos(angle) * length,
                    y + Math.sin(angle) * length
                );
                ctx.stroke();
            }
        }

        // Update ship physics and controls
        function updateShip() {
            // Handle rotation
            if (keys['ArrowLeft'] || keys['a']) {
                ship.rotation = -0.1;
            } else if (keys['ArrowRight'] || keys['d']) {
                ship.rotation = 0.1;
            } else {
                ship.rotation = 0;
            }
            
            // Apply rotation
            ship.angle += ship.rotation;
            
            // Handle thrust with momentum physics
            if ((keys['ArrowUp'] || keys['w']) && !gameOver) {
                ship.thrusting = true;
                
                // Apply acceleration in direction of ship's angle
                ship.velocityX += Math.sin(ship.angle) * ship.acceleration;
                ship.velocityY += -Math.cos(ship.angle) * ship.acceleration;
                
                // Limit maximum speed
                const speed = Math.sqrt(ship.velocityX ** 2 + ship.velocityY ** 2);
                if (speed > ship.maxSpeed) {
                    ship.velocityX = (ship.velocityX / speed) * ship.maxSpeed;
                    ship.velocityY = (ship.velocityY / speed) * ship.maxSpeed;
                }
            } else {
                ship.thrusting = false;
            }
            
            // Apply friction
            ship.velocityX *= ship.friction;
            ship.velocityY *= ship.friction;
            
            // Update position with wraparound
            ship.x += ship.velocityX;
            ship.y += ship.velocityY;
            
            if (ship.x < 0) ship.x = SCREEN_WIDTH;
            if (ship.x > SCREEN_WIDTH) ship.x = 0;
            if (ship.y < 0) ship.y = SCREEN_HEIGHT;
            if (ship.y > SCREEN_HEIGHT) ship.y = 0;
            
            // Update invulnerability
            if (ship.invulnerable) {
                ship.invulnerabilityTimer--;
                ship.flashTimer--;
                
                if (ship.invulnerabilityTimer <= 0) {
                    ship.invulnerable = false;
                }
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Move bullet
                bullet.x += bullet.velocityX;
                bullet.y += bullet.velocityY;
                
                // Wraparound
                if (bullet.x < 0) bullet.x = SCREEN_WIDTH;
                if (bullet.x > SCREEN_WIDTH) bullet.x = 0;
                if (bullet.y < 0) bullet.y = SCREEN_HEIGHT;
                if (bullet.y > SCREEN_HEIGHT) bullet.y = 0;
                
                // Age and remove bullets after timeout
                bullet.age++;
                if (bullet.age > 60) { // 1 second at 60fps
                    bullets.splice(i, 1);
                }
            }
        }

        // Update asteroids
        function updateAsteroids() {
            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                
                // Move asteroid
                asteroid.x += asteroid.velocityX;
                asteroid.y += asteroid.velocityY;
                
                // Wraparound
                if (asteroid.x < 0) asteroid.x = SCREEN_WIDTH;
                if (asteroid.x > SCREEN_WIDTH) asteroid.x = 0;
                if (asteroid.y < 0) asteroid.y = SCREEN_HEIGHT;
                if (asteroid.y > SCREEN_HEIGHT) asteroid.y = 0;
                
                // Rotate asteroid
                asteroid.rotation += asteroid.rotationSpeed;
                
                // Check for collision with ship (only if not invulnerable)
                if (!ship.invulnerable && 
                    distance(ship.x, ship.y, asteroid.x, asteroid.y) < asteroid.radius + ship.radius * 0.8) {
                    
                    // Ship hit - reset
                    lives--;
                    updateScoreDisplay();
                    
                    if (lives <= 0) {
                        gameOver = true;
                    } else {
                        ship.invulnerable = true;
                        ship.invulnerabilityTimer = 120;
                        ship.flashTimer = 60;
                        
                        // Reset ship position
                        ship.x = SCREEN_WIDTH / 2;
                        ship.y = SCREEN_HEIGHT / 2;
                        ship.velocityX = 0;
                        ship.velocityY = 0;
                    }
                    
                    break; // Exit loop since we're resetting ship
                }
                
                // Check for collision with bullets
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const bullet = bullets[j];
                    
                    if (distance(bullet.x, bullet.y, asteroid.x, asteroid.y) < asteroid.radius) {
                        // Hit! Create explosion effect
                        drawExplosion(asteroid.x, asteroid.y, asteroid.size);
                        
                        // Remove bullet
                        bullets.splice(j, 1);
                        
                        // Split asteroid based on size
                        if (asteroid.size === ASTEROID_SIZES[0]) { // Large
                            score += 20;
                            for (let k = 0; k < 2; k++) {
                                createAsteroid(ASTEROID_SIZES[1]); // Create two medium
                            }
                        } else if (asteroid.size === ASTEROID_SIZES[1]) { // Medium
                            score += 50;
                            for (let k = 0; k < 2; k++) {
                                createAsteroid(ASTEROID_SIZES[2]); // Create two small
                            }
                        } else { // Small
                            score += 100;
                        }
                        
                        // Remove asteroid
                        asteroids.splice(i, 1);
                        updateScoreDisplay();
                        break;
                    }
                }
            }
        }

        // Update UFOs
        function updateUfos() {
            for (let i = ufos.length - 1; i >= 0; i--) {
                const ufo = ufos[i];
                
                if (!ufo.alive) continue;
                
                // Move UFO
                ufo.x += ufo.velocityX;
                ufo.y += ufo.velocityY;
                
                // Wraparound
                if (ufo.x < -50) ufo.x = SCREEN_WIDTH + 50;
                if (ufo.x > SCREEN_WIDTH + 50) ufo.x = -50;
                if (ufo.y < -50) ufo.y = SCREEN_HEIGHT + 50;
                if (ufo.y > SCREEN_HEIGHT + 50) ufo.y = -50;
                
                // Rotate UFO slightly
                ufo.rotation += 0.01;
                
                // UFO shooting logic
                ufo.shootTimer++;
                
                // Large UFO: random shots, slower rate
                if (ufo.type === 'large' && ufo.shootTimer > 90 + Math.random() * 60) {
                    fireUFOBullet(ufo);
                    ufo.shootTimer = 0;
                }
                
                // Small UFO: precise shots, faster rate
                if (ufo.type === 'small' && ufo.shootTimer > 45 + Math.random() * 30) {
                    // Aim at ship
                    const dx = ship.x - ufo.x;
                    const dy = ship.y - ufo.y;
                    const angle = Math.atan2(dy, dx);
                    
                    // Create bullet with direction toward ship
                    const bulletSpeed = 4;
                    const bullet = {
                        x: ufo.x,
                        y: ufo.y,
                        velocityX: Math.cos(angle) * bulletSpeed,
                        velocityY: Math.sin(angle) * bulletSpeed,
                        age: 0
                    };
                    
                    bullets.push(bullet);
                    ufo.shootTimer = 0;
                }
                
                // Check for collision with ship (only if not invulnerable)
                if (!ship.invulnerable && 
                    distance(ship.x, ship.y, ufo.x, ufo.y) < ufo.radius + ship.radius * 0.8) {
                    
                    lives--;
                    updateScoreDisplay();
                    
                    if (lives <= 0) {
                        gameOver = true;
                    } else {
                        ship.invulnerable = true;
                        ship.invulnerabilityTimer = 120;
                        ship.flashTimer = 60;
                        
                        // Reset ship position
                        ship.x = SCREEN_WIDTH / 2;
                        ship.y = SCREEN_HEIGHT / 2;
                        ship.velocityX = 0;
                        ship.velocityY = 0;
                    }
                    
                    ufo.alive = false; // Destroy UFO on collision
                }
                
                // Check for collision with bullets
                for (let j = bullets.length - 1; j >= 0; j--) {
                    const bullet = bullets[j];
                    
                    if (distance(bullet.x, bullet.y, ufo.x, ufo.y) < ufo.radius) {
                        // Hit! Create explosion effect
                        drawExplosion(ufo.x, ufo.y, ufo.size);
                        
                        // Remove bullet
                        bullets.splice(j, 1);
                        
                        // Award points based on UFO type
                        if (ufo.type === 'large') {
                            score += 200;
                        } else {
                            score += 1000;
                        }
                        
                        updateScoreDisplay();
                        ufo.alive = false; // Destroy UFO
                        
                        break;
                    }
                }
                
                // Remove dead UFOs
                if (!ufo.alive) {
                    ufos.splice(i, 1);
                }
            }
        }

        // Fire a bullet from the ship
        function fireBullet() {
            if (bullets.length >= MAX_BULLETS) return;
            
            const bullet = {
                x: ship.x + Math.cos(ship.angle) ,
                y: ship.y + Math.sin(ship.angle) ,
                velocityX: Math.sin(ship.angle) * BULLET_SPEED + ship.velocityX,
                velocityY: -Math.cos(ship.angle) * BULLET_SPEED + ship.velocityY,
                age: 0
            };
            
            bullets.push(bullet);
        }

        // Fire a bullet from UFO
        function fireUFOBullet(ufo) {
            const angle = Math.random() * Math.PI * 2;
            const bulletSpeed = 3.5;
            const bullet = {
                x: ufo.x,
                y: ufo.y,
                velocityX: Math.cos(angle) * bulletSpeed,
                velocityY: Math.sin(angle) * bulletSpeed,
                age: 0
            };
            
            bullets.push(bullet);
        }

        // Update score display
        function updateScoreDisplay() {
            infoDisplay.textContent = `SCORE: ${score} | LIVES: ${lives} | LEVEL: ${level}`;
            
            // Check for extra life
            if (score >= extraLifeScore && lives < 9) {
                lives++;
                extraLifeScore += 10000; // Next extra life at next 10k
                updateScoreDisplay();
            }
        }

        // Spawn new asteroids if all destroyed
        function checkLevelComplete() {
            if (asteroids.length === 0 && !gameOver) {
                level++;
                
                // Increase difficulty: more asteroids, faster movement
                const asteroidCount = Math.min(4 + level, 8);
                for (let i = 0; i < asteroidCount; i++) {
                    createAsteroid(ASTEROID_SIZES[0]);
                }
            }
        }

        // Main game loop
        function gameLoop() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            
            if (!gameStarted) {
                // Title screen
                ctx.font = '32px "Courier New", monospace';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeText('ASTEROIDS', SCREEN_WIDTH / 2 - 80, SCREEN_HEIGHT / 2 - 50);
                
                ctx.font = '16px "Courier New", monospace';
                ctx.strokeText('Press any key to start', SCREEN_WIDTH / 2 - 90, SCREEN_HEIGHT / 2 + 20);
                ctx.strokeText('Arrow Keys or WASD to move', SCREEN_WIDTH / 2 - 110, SCREEN_HEIGHT / 2 + 50);
                ctx.strokeText('Space to shoot', SCREEN_WIDTH / 2 - 70, SCREEN_HEIGHT / 2 + 80);
                
                // Draw sample ship
                ctx.save();
                ctx.translate(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 120);
                ctx.rotate(Math.PI/4);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(-10, 8);
                ctx.lineTo(10, 8);
                ctx.closePath();
                ctx.stroke();
                
                // Thrust flame
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, 8);
                ctx.lineTo(0, 25);
                ctx.stroke();
                ctx.restore();
                
            } else if (gameOver) {
                // Game over screen
                ctx.font = '32px "Courier New", monospace';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeText('GAME OVER', SCREEN_WIDTH / 2 - 80, SCREEN_HEIGHT / 2 - 50);
                
                ctx.font = '16px "Courier New", monospace';
                ctx.strokeText(`Final Score: ${score}`, SCREEN_WIDTH / 2 - 70, SCREEN_HEIGHT / 2 + 20);
                ctx.strokeText('Press any key to restart', SCREEN_WIDTH / 2 - 90, SCREEN_HEIGHT / 2 + 50);
                
                if (keys[' '] || keys['Enter'] || Object.keys(keys).length > 0) {
                    score = 0;
                    lives = 3;
                    level = 1;
                    gameOver = false;
                    gameStarted = false;
                    updateScoreDisplay();
                }
            } else {
                // Update game objects
                updateShip();
                updateBullets();
                updateAsteroids();
                updateUfos();
                
                // Spawn UFOs randomly
                if (Math.random() < UFO_SPAWN_CHANCE && ufos.length === 0) {
                    createUFO();
                }
                
                // Check for level completion
                checkLevelComplete();
                
                // Draw game objects
                drawShip();
                drawAsteroids();
                drawBullets();
                drawUfos();
                
                // Handle shooting
                if ((keys[' '] || keys['ArrowDown'] || keys['s']) && !gameOver) {
                    fireBullet();
                    keys[' '] = false; // Prevent continuous firing on key hold
                }
            }
            
            // Request next frame
            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        gameLoop();
    </script>
</body>
</html>