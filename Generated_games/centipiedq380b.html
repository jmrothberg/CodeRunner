<!DOCTYPE html>
<html>
<head>
    <title>Centipede - 1981 Atari Original</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 2px solid #333; box-shadow: 0 0 20px rgba(0, 255, 0, 0.7); }
        .score-display { position: absolute; top: 10px; left: 10px; color: white; font-family: 'Courier New', monospace; font-size: 24px; }
        .lives-display { position: absolute; top: 10px; right: 10px; color: white; font-family: 'Courier New', monospace; font-size: 24px; }
    </style>
</head>
<body>
    <div class="score-display">Score: 0</div>
    <div class="lives-display">Lives: 3</div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        // ======================
        // GAME CONSTANTS
        // ======================
        const CELL_SIZE = 20;
        const GRID_WIDTH = Math.floor(800 / CELL_SIZE);
        const GRID_HEIGHT = Math.floor(600 / CELL_SIZE);
        const PLAYER_Y_START = GRID_HEIGHT - 1; // Bottom row
        const MAX_MUSHROOMS = 30;
        const WAVE_INCREASE = 2; // Additional centipedes per wave

        // ======================
        // GAME STATE
        // ======================
        let gameState = {
            score: 0,
            lives: 3,
            wave: 1,
            playerX: Math.floor(GRID_WIDTH / 2),
            bullets: [],
            centipedes: [],
            mushrooms: [],
            fleas: [],
            spiders: [],
            scorpions: [],
            gameOver: false
        };

        // ======================
        // HELPER FUNCTIONS
        // ======================
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function mushroomAt(x, y) {
            for (let m of gameState.mushrooms) {
                if (m.x === x && m.y === y) return true;
            }
            return false;
        }

        function getMushroomAt(x, y) {
            for (let m of gameState.mushrooms) {
                if (m.x === x && m.y === y) return m;
            }
            return null;
        }

        function drawText(text, x, y, color = 'white', size = 16) {
            ctx.font = `${size}px 'Courier New', monospace`;
            ctx.fillStyle = color;
            ctx.fillText(text, x, y);
        }

        // ======================
        // DRAWING FUNCTIONS
        // ======================
        function drawPlayer() {
            const x = gameState.playerX * CELL_SIZE;
            const y = PLAYER_Y_START * CELL_SIZE;
            
            // Player body (tank)
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(x + 5, y, 10, 8);
            
            // Cannon
            ctx.fillStyle = '#FFFF00';
            ctx.fillRect(x + 7, y - 4, 6, 4);
            
            // Player glow effect
            ctx.beginPath();
            ctx.arc(x + 10, y + 4, 5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.fill();
        }

        function drawBullet(bullet) {
            const x = bullet.x * CELL_SIZE;
            const y = bullet.y * CELL_SIZE;
            
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(x + 8, y, 4, 12);
            
            // Bullet trail effect
            ctx.beginPath();
            ctx.arc(x + 10, y + 6, 3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.fill();
        }

        function drawCentipede(centipede) {
            for (let i = 0; i < centipede.segments.length; i++) {
                const seg = centipede.segments[i];
                const x = seg.x * CELL_SIZE;
                const y = seg.y * CELL_SIZE;
                
                // Head is red, body is green/yellow
                if (i === 0) {
                    ctx.fillStyle = '#FF0000';
                    ctx.beginPath();
                    ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/2 - 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Eye effect
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(x + CELL_SIZE/2 + 3, y + CELL_SIZE/2 - 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#00FF00';
                    ctx.beginPath();
                    ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/2 - 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Segment glow
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawMushroom(mush) {
            const x = mush.x * CELL_SIZE;
            const y = mush.y * CELL_SIZE;
            
            // Mushroom cap
            ctx.fillStyle = mush.poisoned ? '#FF0000' : (mush.health === 4 ? '#FFA500' : 
                mush.health === 3 ? '#FFD700' : 
                mush.health === 2 ? '#FF8C00' : '#8B0000');
            
            ctx.beginPath();
            ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/4, CELL_SIZE/2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Mushroom stem
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x + CELL_SIZE/2 - 2, y + CELL_SIZE/4, 4, CELL_SIZE/2);
            
            // Damage effect (cracks)
            if (mush.health < 4) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x + CELL_SIZE/2 - 3, y + CELL_SIZE/4);
                ctx.lineTo(x + CELL_SIZE/2 + 3, y + CELL_SIZE/4);
                ctx.stroke();
            }
        }

        function drawFlea(flea) {
            const x = flea.x * CELL_SIZE;
            const y = flea.y * CELL_SIZE;
            
            // Flea body
            ctx.fillStyle = '#00FFFF';
            ctx.beginPath();
            ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/3, 0, Math.PI * 2);
            ctx.fill();
            
            // Legs (simplified)
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const lx = x + CELL_SIZE/2 + Math.cos(angle) * CELL_SIZE/3;
                const ly = y + CELL_SIZE/2 + Math.sin(angle) * CELL_SIZE/3;
                ctx.beginPath();
                ctx.moveTo(x + CELL_SIZE/2, y + CELL_SIZE/2);
                ctx.lineTo(lx, ly);
                ctx.strokeStyle = '#00FFFF';
                ctx.stroke();
            }
        }

        function drawSpider(spider) {
            const x = spider.x * CELL_SIZE;
            const y = spider.y * CELL_SIZE;
            
            // Spider body
            ctx.fillStyle = '#FF00FF';
            ctx.beginPath();
            ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/3, 0, Math.PI * 2);
            ctx.fill();
            
            // Legs (8 legs)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const lx = x + CELL_SIZE/2 + Math.cos(angle) * CELL_SIZE/1.5;
                const ly = y + CELL_SIZE/2 + Math.sin(angle) * CELL_SIZE/1.5;
                ctx.beginPath();
                ctx.moveTo(x + CELL_SIZE/2, y + CELL_SIZE/2);
                ctx.lineTo(lx, ly);
                ctx.strokeStyle = '#FF00FF';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawScorpion(scorpion) {
            const x = scorpion.x * CELL_SIZE;
            const y = scorpion.y * CELL_SIZE;
            
            // Scorpion body
            ctx.fillStyle = '#8B008B';
            ctx.beginPath();
            ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/3, 0, Math.PI * 2);
            ctx.fill();
            
            // Pincers
            const pincerAngle = Math.PI / 4;
            for (let i = -1; i <= 1; i += 2) {
                const angle = pincerAngle * i;
                const lx = x + CELL_SIZE/2 + Math.cos(angle) * CELL_SIZE/1.5;
                const ly = y + CELL_SIZE/2 + Math.sin(angle) * CELL_SIZE/1.5;
                ctx.beginPath();
                ctx.moveTo(x + CELL_SIZE/2, y + CELL_SIZE/2);
                ctx.lineTo(lx, ly);
                ctx.strokeStyle = '#8B008B';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Tail
            const tailAngle = Math.PI / 2;
            const tx = x + CELL_SIZE/2 + Math.cos(tailAngle) * CELL_SIZE;
            const ty = y + CELL_SIZE/2 + Math.sin(tailAngle) * CELL_SIZE;
            ctx.beginPath();
            ctx.moveTo(x + CELL_SIZE/2, y + CELL_SIZE/2);
            ctx.lineTo(tx, ty);
            ctx.strokeStyle = '#8B008B';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // ======================
        // GAME LOGIC
        // ======================
        function initGame() {
            gameState.score = 0;
            gameState.lives = 3;
            gameState.wave = 1;
            gameState.gameOver = false;
            
            // Initialize mushrooms (random positions in upper grid)
            gameState.mushrooms = [];
            for (let i = 0; i < MAX_MUSHROOMS; i++) {
                const x = getRandomInt(2, GRID_WIDTH - 3);
                const y = getRandomInt(1, GRID_HEIGHT - 6);
                gameState.mushrooms.push({x, y, health: 4, poisoned: false});
            }
            
            // Initialize first centipede
            initCentipede();
        }

        function initCentipede() {
            gameState.centipedes = [];
            const numCentipedes = Math.min(1 + gameState.wave, 5); // Max 5 centipedes
            
            for (let c = 0; c < numCentipedes; c++) {
                const startX = getRandomInt(2, GRID_WIDTH - 3);
                const segments = [];
                
                // Create 10-12 segment centipede
                for (let i = 0; i < 10 + Math.floor(Math.random() * 3); i++) {
                    segments.push({x: startX - i, y: 0});
                }
                
                gameState.centipedes.push({
                    segments,
                    direction: 'right',
                    speed: 0.15 + (gameState.wave * 0.03), // Slower base speed
                    timer: 0 // Add timer property for movement control
                });
            }
        }

        function updateGame() {
            if (gameState.gameOver) return;
            
            // Update bullets
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                bullet.y -= 1;
                
                // Check collision with mushrooms
                let mushroomHit = getMushroomAt(bullet.x, bullet.y);
                if (mushroomHit) {
                    mushroomHit.health--;
                    gameState.score += 50;
                    
                    if (mushroomHit.health <= 0) {
                        gameState.mushrooms.splice(gameState.mushrooms.indexOf(mushroomHit), 1);
                    }
                    gameState.bullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with centipedes
                for (let c = 0; c < gameState.centipedes.length; c++) {
                    const centipede = gameState.centipedes[c];
                    for (let s = 0; s < centipede.segments.length; s++) {
                        const seg = centipede.segments[s];
                        if (seg.x === bullet.x && seg.y === bullet.y) {
                            // Hit centipede segment
                            gameState.score += 10;
                            
                            // Remove hit segment and possibly split centipede
                            if (s === 0) { // Head hit - destroy entire centipede
                                gameState.centipedes.splice(c, 1);
                                c--; // Adjust index after splice
                            } else {
                                const newCentipedes = [];
                                
                                // Split into two parts if not tail
                                if (s > 0) {
                                    newCentipedes.push({
                                        segments: centipede.segments.slice(0, s),
                                        direction: centipede.direction,
                                        speed: centipede.speed,
                                        timer: 0 // Initialize timer for new centipedes
                                    });
                                }
                                
                                if (s < centipede.segments.length - 1) {
                                    newCentipedes.push({
                                        segments: centipede.segments.slice(s + 1),
                                        direction: centipede.direction === 'right' ? 'left' : 'right',
                                        speed: centipede.speed,
                                        timer: 0 // Initialize timer for new centipedes
                                    });
                                }
                                
                                // Replace original centipede with new ones
                                gameState.centipedes.splice(c, 1);
                                gameState.centipedes = [...gameState.centipedes, ...newCentipedes];
                            }
                            
                            gameState.bullets.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // Remove bullets that go off screen
                if (bullet.y < 0) {
                    gameState.bullets.splice(i, 1);
                }
            }
            
            // Update centipedes with timer-based movement
            for (let c = 0; c < gameState.centipedes.length; c++) {
                const centipede = gameState.centipedes[c];
                
                // Accumulate time before moving
                centipede.timer += centipede.speed;
                if (centipede.timer >= 1) {
                    const head = centipede.segments[0];
                    
                    // Determine next position
                    let dx = centipede.direction === 'right' ? 1 : -1;
                    let nextX = head.x + dx;
                    let nextY = head.y;
                    
                    // Check for obstacles (edge or mushroom)
                    if (nextX < 0 || nextX >= GRID_WIDTH || mushroomAt(nextX, nextY)) {
                        nextX = head.x; // Stay in same column
                        nextY = head.y + 1;
                        centipede.direction = centipede.direction === 'right' ? 'left' : 'right';
                    }
                    
                    // Move head to new position
                    let oldHeadX = head.x;
                    let oldHeadY = head.y;
                    head.x = nextX;
                    head.y = nextY;
                    
                    // Move body segments
                    for (let i = 1; i < centipede.segments.length; i++) {
                        const prevX = centipede.segments[i-1].x;
                        const prevY = centipede.segments[i-1].y;
                        centipede.segments[i].x = oldHeadX;
                        centipede.segments[i].y = oldHeadY;
                        oldHeadX = prevX;
                        oldHeadY = prevY;
                    }
                    
                    // Check if centipede reached bottom (game over)
                    if (head.y >= PLAYER_Y_START) {
                        gameState.gameOver = true;
                    }
                    
                    // Reset timer after moving
                    centipede.timer -= 1;
                }
            }
            
            // Update fleas with timer-based movement
            for (let i = gameState.fleas.length - 1; i >= 0; i--) {
                const flea = gameState.fleas[i];
                
                // Accumulate time before moving
                flea.timer += flea.speed;
                if (flea.timer >= 1) {
                    flea.y += 1; // Move only when timer reaches threshold
                    
                    // Reset timer after moving
                    flea.timer -= 1;
                    
                    // Check collision with bullets
                    for (let b of gameState.bullets) {
                        if (b.x === flea.x && b.y === flea.y) {
                            // Flea hit - drop mushroom
                            gameState.mushrooms.push({x: flea.x, y: flea.y, health: 4, poisoned: false});
                            gameState.score += 100;
                            gameState.fleas.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // Remove fleas that go off screen
                if (flea.y >= GRID_HEIGHT) {
                    gameState.fleas.splice(i, 1);
                }
            }
            
            // Update spiders with timer-based movement
            for (let i = 0; i < gameState.spiders.length; i++) {
                const spider = gameState.spiders[i];
                
                // Accumulate time before moving
                spider.timer += spider.speed;
                if (spider.timer >= 1) {
                    // Move in both directions
                    if (spider.direction === 'right') {
                        spider.x += 1;
                    } else {
                        spider.x -= 1;
                    }
                    
                    if (spider.yDirection === 'down') {
                        spider.y += 1;
                    } else {
                        spider.y -= 1;
                    }
                    
                    // Check edges
                    if (spider.x <= 0 || spider.x >= GRID_WIDTH - 1) {
                        spider.direction = spider.direction === 'right' ? 'left' : 'right';
                    }
                    
                    if (spider.y <= 0 || spider.y >= GRID_HEIGHT - 1) {
                        spider.yDirection = spider.yDirection === 'down' ? 'up' : 'down';
                    }
                    
                    // Reset timer after moving
                    spider.timer -= 1;
                    
                    // Check collision with bullets
                    for (let b of gameState.bullets) {
                        if (b.x === spider.x && b.y === spider.y) {
                            gameState.score += 200;
                            gameState.spiders.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            
            // Update scorpions with timer-based movement
            for (let i = 0; i < gameState.scorpions.length; i++) {
                const scorpion = gameState.scorpions[i];
                
                // Accumulate time before moving
                scorpion.timer += scorpion.speed;
                if (scorpion.timer >= 1) {
                    // Move diagonally
                    if (scorpion.direction === 'right') {
                        scorpion.x += 1;
                    } else {
                        scorpion.x -= 1;
                    }
                    
                    if (scorpion.yDirection === 'down') {
                        scorpion.y += 1;
                    } else {
                        scorpion.y -= 1;
                    }
                    
                    // Check edges
                    if (scorpion.x <= 0 || scorpion.x >= GRID_WIDTH - 1) {
                        scorpion.direction = scorpion.direction === 'right' ? 'left' : 'right';
                    }
                    
                    if (scorpion.y <= 0 || scorpion.y >= GRID_HEIGHT - 1) {
                        scorpion.yDirection = scorpion.yDirection === 'down' ? 'up' : 'down';
                    }
                    
                    // Poison mushrooms
                    for (let m of gameState.mushrooms) {
                        if (Math.abs(scorpion.x - m.x) <= 1 && Math.abs(scorpion.y - m.y) <= 1) {
                            m.poisoned = true;
                        }
                    }
                    
                    // Reset timer after moving
                    scorpion.timer -= 1;
                    
                    // Check collision with bullets
                    for (let b of gameState.bullets) {
                        if (b.x === scorpion.x && b.y === scorpion.y) {
                            gameState.score += 300;
                            gameState.scorpions.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            
            // Spawn new enemies based on wave
            if (Math.random() < 0.02 * gameState.wave) {
                const x = getRandomInt(0, GRID_WIDTH - 1);
                gameState.fleas.push({x, y: 0, speed: 0.2, timer: 0});
            }
            
            if (Math.random() < 0.01 * gameState.wave) {
                const x = getRandomInt(0, GRID_WIDTH - 1);
                gameState.spiders.push({
                    x,
                    y: 0,
                    direction: x < GRID_WIDTH/2 ? 'right' : 'left',
                    yDirection: 'down',
                    speed: 0.25,
                    timer: 0
                });
            }
            
            if (Math.random() < 0.005 * gameState.wave) {
                const x = getRandomInt(0, GRID_WIDTH - 1);
                gameState.scorpions.push({
                    x,
                    y: 0,
                    direction: x < GRID_WIDTH/2 ? 'right' : 'left',
                    yDirection: 'down',
                    speed: 0.25,
                    timer: 0
                });
            }
            
            // Check for extra life
            if (gameState.score >= 12000 && gameState.lives < 5) {
                gameState.lives++;
                gameState.score -= 12000;
            }
        }

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid lines (optional for debugging)
            /*ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            for (let x = 0; x <= canvas.width; x += CELL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += CELL_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }*/
            
            // Draw mushrooms
            for (let m of gameState.mushrooms) {
                drawMushroom(m);
            }
            
            // Draw centipedes
            for (let c of gameState.centipedes) {
                drawCentipede(c);
            }
            
            // Draw fleas
            for (let f of gameState.fleas) {
                drawFlea(f);
            }
            
            // Draw spiders
            for (let s of gameState.spiders) {
                drawSpider(s);
            }
            
            // Draw scorpions
            for (let sc of gameState.scorpions) {
                drawScorpion(sc);
            }
            
            // Draw bullets
            for (let b of gameState.bullets) {
                drawBullet(b);
            }
            
            // Draw player
            drawPlayer();
            
            // Draw score and lives
            document.querySelector('.score-display').textContent = `Score: ${gameState.score}`;
            document.querySelector('.lives-display').textContent = `Lives: ${gameState.lives}`;
            
            // Game over message
            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '48px "Courier New", monospace';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                ctx.font = '24px "Courier New", monospace';
                ctx.fillText(`Final Score: ${gameState.score}`, canvas.width/2, canvas.height/2 + 50);
            }
        }

        // ======================
        // INPUT HANDLING
        // ======================
        let keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === ' ' && !gameState.gameOver) {
                gameState.bullets.push({
                    x: gameState.playerX,
                    y: PLAYER_Y_START - 1
                });
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        function handleInput() {
            if (gameState.gameOver) return;
            
            // Move player left/right
            if (keys['ArrowLeft'] && gameState.playerX > 0) {
                gameState.playerX--;
            }
            if (keys['ArrowRight'] && gameState.playerX < GRID_WIDTH - 1) {
                gameState.playerX++;
            }
        }

        // ======================
        // MAIN GAME LOOP
        // ======================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        initGame();
        
        function gameLoop() {
            handleInput();
            updateGame();
            drawGame();
            
            if (!gameState.gameOver) {
                requestAnimationFrame(gameLoop);
            }
        }
        
        gameLoop();
    </script>
</body>
</html>