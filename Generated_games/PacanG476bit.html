<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man 1980 Clone</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #111;
            --wall-color: #1919A6; /* Classic Arcade Blue */
            --pacman-color: #FFFF00;
            --text-color: #FFF;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            border: 4px solid #333;
            border-radius: 4px;
        }

        canvas {
            display: block;
            background-color: black;
        }

        /* UI Overlay for Score and Lives */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-size: 14px;
            text-shadow: 2px 2px #000;
        }

        /* Start / Game Over Screens */
        #overlay-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            color: var(--pacman-color);
            margin-bottom: 20px;
            font-size: 30px;
            text-shadow: 4px 4px #b30000;
        }

        p {
            line-height: 1.5;
            font-size: 12px;
            color: #ddd;
        }

        button {
            background: var(--pacman-color);
            border: none;
            padding: 15px 30px;
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            color: #000;
            box-shadow: 0 4px #b3b300;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 #b3b300;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Heads Up Display -->
        <div id="ui-layer">
            <div class="hud-row">
                <span>SCORE: <span id="scoreVal">0</span></span>
                <span>HIGH: <span id="highScoreVal">0</span></span>
            </div>
            <div class="hud-row" style="justify-content: center;">
                 <!-- Lives drawn dynamically or via icon -->
                 <span id="livesDisplay"></span>
            </div>
        </div>

        <!-- Menus -->
        <div id="overlay-screen">
            <h1 id="titleText">PAC-MAN</h1>
            <p id="statusText">Ready!</p>
            <button id="startBtn">INSERT COIN</button>
        </div>
    </div>

<script>
/**
 * PAC-MAN CLONE
 * Single file implementation.
 */

// --- CONFIGURATION & CONSTANTS ---
const TILE_SIZE = 20; // Base size of a grid tile in pixels
const SCALE = 1.5;    // Visual scaling factor
const ACTUAL_TILE = TILE_SIZE * SCALE;

// Map Codes: 0=Wall, 1=Dot, 2=Empty, 3=Power Pellet, 4=Ghost House Door, 5=Ghost House Interior
// The map is 28 tiles wide x 31 tiles high (Standard resolution)
const RAW_MAP = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
    [0,3,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,3,0],
    [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
    [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
    [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0],
    [2,2,2,2,2,0,1,0,0,0,0,0,2,0,0,2,0,0,0,0,0,1,0,2,2,2,2,2],
    [0,0,0,0,0,0,1,0,0,2,2,2,2,2,2,2,2,2,2,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,2,0,0,4,4,4,4,0,0,2,0,0,1,0,0,0,0,0,0],
    [2,2,2,2,2,2,1,2,2,2,0,5,5,5,5,5,0,0,2,2,2,1,2,2,2,2,2,2], // Tunnel row
    [0,0,0,0,0,0,1,0,0,2,0,5,5,5,5,5,0,0,2,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0],
    [2,2,2,2,2,0,1,0,0,2,2,2,2,2,2,2,2,2,2,0,0,1,0,2,2,2,2,2],
    [0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0],
    [0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
    [0,3,1,0,0,0,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,0,0,0,1,3,0], // Power pellets near ghost house
    [0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0],
    [0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,1,1,1,1,0],
    [0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],
    [0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
];

// Directions
const UP = { x: 0, y: -1 };
const DOWN = { x: 0, y: 1 };
const LEFT = { x: -1, y: 0 };
const RIGHT = { x: 1, y: 0 };
const NONE = { x: 0, y: 0 };

// Game Settings
const FPS = 60;
const PACMAN_SPEED = 2.5; // Pixels per frame (must divide ACTUAL_TILE evenly for smooth grid lock)
const GHOST_SPEED = 2.5; 
const GHOST_FRIGHTENED_SPEED = 1.25;

// Colors
const COLOR_WALL = '#1919A6';
const COLOR_DOT = '#ffb8ae';
const COLOR_PELLET = '#ffb8ae';

// --- GLOBAL VARIABLES ---
let canvas, ctx;
let gameMap = [];
let score = 0;
let highScore = localStorage.getItem('pacman_highscore') || 0;
let lives = 3;
let level = 1;
let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER, LEVEL_TRANSITION
let animationId;
let frameCount = 0;

// Entities
let pacman;
let ghosts = [];
let particles = []; // For visual effects

// --- CLASSES ---

class Entity {
    constructor(x, y, color) {
        this.x = x * ACTUAL_TILE + ACTUAL_TILE / 2; // Center in tile
        this.y = y * ACTUAL_TILE + ACTUAL_TILE / 2;
        this.color = color;
        this.dir = NONE;
        this.nextDir = NONE;
        this.speed = PACMAN_SPEED;
        this.radius = ACTUAL_TILE * 0.4;
    }

    getGridPos() {
        return {
            c: Math.floor(this.x / ACTUAL_TILE),
            r: Math.floor(this.y / ACTUAL_TILE)
        };
    }

    // Check if entity is perfectly centered on a tile
    isCentered() {
        const centerTolerance = this.speed; 
        const centerX = (Math.floor(this.x / ACTUAL_TILE) * ACTUAL_TILE) + (ACTUAL_TILE / 2);
        const centerY = (Math.floor(this.y / ACTUAL_TILE) * ACTUAL_TILE) + (ACTUAL_TILE / 2);
        return Math.abs(this.x - centerX) < centerTolerance && Math.abs(this.y - centerY) < centerTolerance;
    }

    canMove(direction) {
        const pos = this.getGridPos();
        const nextR = pos.r + direction.y;
        const nextC = pos.c + direction.x;

        // Screen wrapping check
        if (nextC < 0 || nextC >= gameMap[0].length) return true;

        if (gameMap[nextR] && gameMap[nextR][nextC] === 0) return false; // Wall
        
        // Ghost House Door Logic
        if (gameMap[nextR] && gameMap[nextR][nextC] === 4) {
            // Only ghosts can enter/exit usually, but for simplicity:
            // If ghost is inside house (5), it can go to door (4). 
            // If ghost is outside, it cannot go back in unless eaten.
            return false; 
        }
        
        return true;
    }

    move() {
        // Try to change direction if queued
        if (this.nextDir !== NONE && this.isCentered()) {
            if (this.canMove(this.nextDir)) {
                this.dir = this.nextDir;
                this.nextDir = NONE;
                // Snap to grid to prevent drift
                const pos = this.getGridPos();
                this.x = pos.c * ACTUAL_TILE + ACTUAL_TILE / 2;
                this.y = pos.r * ACTUAL_TILE + ACTUAL_TILE / 2;
            }
        }

        if (this.canMove(this.dir)) {
            this.x += this.dir.x * this.speed;
            this.y += this.dir.y * this.speed;
        } else {
            // Stop if hitting wall
            // Snap to grid
            const pos = this.getGridPos();
            this.x = pos.c * ACTUAL_TILE + ACTUAL_TILE / 2;
            this.y = pos.r * ACTUAL_TILE + ACTUAL_TILE / 2;
        }

        // Screen Wrapping
        if (this.x < -ACTUAL_TILE/2) this.x = canvas.width + ACTUAL_TILE/2;
        if (this.x > canvas.width + ACTUAL_TILE/2) this.x = -ACTUAL_TILE/2;
    }
}

class Pacman extends Entity {
    constructor(x, y) {
        super(x, y, '#FFFF00');
        this.mouthOpen = 0;
        this.mouthSpeed = 0.2;
        this.rotation = 0;
    }

    update() {
        // Animation
        this.mouthOpen += this.mouthSpeed;
        if (this.mouthOpen > 0.25 * Math.PI || this.mouthOpen < 0) {
            this.mouthSpeed = -this.mouthSpeed;
        }

        // Rotation based on direction
        if (this.dir === RIGHT) this.rotation = 0;
        if (this.dir === DOWN) this.rotation = 0.5 * Math.PI;
        if (this.dir === LEFT) this.rotation = Math.PI;
        if (this.dir === UP) this.rotation = 1.5 * Math.PI;

        this.move();

        // Eating Dots
        const pos = this.getGridPos();
        if (gameMap[pos.r] && gameMap[pos.r][pos.c] === 1) {
            gameMap[pos.r][pos.c] = 2; // Empty
            score += 10;
            checkWinCondition();
        } else if (gameMap[pos.r] && gameMap[pos.r][pos.c] === 3) {
            gameMap[pos.r][pos.c] = 2;
            score += 50;
            activatePowerPellet();
            checkWinCondition();
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        ctx.beginPath();
        // Draw Pacman shape
        const actualMouth = Math.max(0, this.mouthOpen); // Prevent negative glitch
        ctx.arc(0, 0, this.radius, actualMouth, 2 * Math.PI - actualMouth);
        ctx.lineTo(0, 0);
        
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.closePath();
        ctx.restore();
    }
}

class Ghost extends Entity {
    constructor(x, y, type) {
        super(x, y, 'white');
        this.type = type; // 'blinky', 'pinky', 'inky', 'clyde'
        this.originalColor = this.getColor(type);
        this.color = this.originalColor;
        
        this.mode = 'SCATTER'; // SCATTER, CHASE, FRIGHTENED, EATEN
        this.speed = GHOST_SPEED;
        
        // Initial release timers (so they don't all flood out)
        this.releaseTimer = 0; 
        if (type === 'blinky') this.releaseTimer = 0;
        if (type === 'pinky') this.releaseTimer = 180; // ~3 seconds
        if (type === 'inky') this.releaseTimer = 420;  // ~7 seconds
        if (type === 'clyde') this.releaseTimer = 660; // ~11 seconds
        
        this.inHouse = true;
    }

    getColor(type) {
        switch(type) {
            case 'blinky': return '#FF0000'; // Red
            case 'pinky': return '#FFB8FF';  // Pink
            case 'inky': return '#00FFFF';   // Cyan
            case 'clyde': return '#FFB852';  // Orange
        }
    }

    update() {
        if (this.releaseTimer > 0) {
            this.releaseTimer--;
            return; // Stay in house
        } else if (this.inHouse && this.mode !== 'EATEN') {
            this.inHouse = false;
            // Move to door position
            const pos = this.getGridPos();
            this.x = 14 * ACTUAL_TILE + ACTUAL_TILE/2;
            this.y = 11 * ACTUAL_TILE + ACTUAL_TILE/2; 
        }

        if (this.mode === 'EATEN') {
            this.speed = GHOST_SPEED * 2; // Return fast
            this.color = 'rgba(0,0,0,0)'; // Invisible body, just eyes
            // Logic to return to house center (14, 14)
            const targetR = 14;
            const targetC = 14;
            const pos = this.getGridPos();
            
            if (pos.r === targetR && pos.c === targetC) {
                this.mode = 'CHASE'; // Respawn
                this.color = this.originalColor;
                this.speed = GHOST_SPEED;
            }
        } else if (this.mode === 'FRIGHTENED') {
            this.speed = GHOST_FRIGHTENED_SPEED;
            // Flash white near end of frighten
            const globalFrightenTime = (frightenTimer / 60) | 0; 
            if (globalFrightenTime < 2 && frameCount % 10 === 0) {
                this.color = '#FFFFFF';
            } else {
                this.color = '#0000FF'; // Blue
            }
        } else {
            this.speed = GHOST_SPEED;
            this.color = this.originalColor;
        }

        // AI Movement Logic (Only at intersections)
        if (this.isCentered()) {
            const pos = this.getGridPos();
            
            // Determine target tile based on mode and personality
            let target = this.getTargetTile();

            // Choose best direction (excluding reverse unless dead end)
            const options = [UP, DOWN, LEFT, RIGHT];
            let bestDir = this.dir;
            let minDist = Infinity;

            // Shuffle options to prevent bias if distances are equal
            options.sort(() => Math.random() - 0.5);

            for (let opt of options) {
                // Don't reverse immediately unless necessary
                if (opt.x === -this.dir.x && opt.y === -this.dir.y) continue;
                
                if (this.canMove(opt)) {
                    const nextR = pos.r + opt.y;
                    const nextC = pos.c + opt.x;
                    
                    // Distance squared to target
                    const dist = Math.pow(nextR - target.r, 2) + Math.pow(nextC - target.c, 2);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        bestDir = opt;
                    }
                }
            }

            // If stuck (dead end), allow reverse
            if (minDist === Infinity) {
                 for (let opt of options) {
                    if (this.canMove(opt)) { bestDir = opt; break; }
                 }
            }

            this.nextDir = bestDir;
        }

        this.move();
    }

    getTargetTile() {
        const pacPos = pacman.getGridPos();
        
        // 1. Eaten Mode: Go to Ghost House
        if (this.mode === 'EATEN') return { r: 14, c: 14 };

        // 2. Frightened Mode: Random target (handled by movement logic mostly, but strictly random tile)
        if (this.mode === 'FRIGHTENED') {
            return { r: Math.floor(Math.random()*28), c: Math.floor(Math.random()*31) };
        }

        // 3. Scatter/Chase Modes
        let target = { r: 0, c: 0 };

        switch(this.type) {
            case 'blinky': // Red: Directly targets Pacman
                target = { r: pacPos.r, c: pacPos.c };
                break;
            
            case 'pinky': // Pink: Targets 4 tiles in front of Pacman
                target = { 
                    r: pacPos.r + (pacman.dir.y * 4), 
                    c: pacPos.c + (pacman.dir.x * 4) 
                };
                break;

            case 'inky': // Cyan: Complex vector based on Blinky and Pacman
                // Pivot is 2 tiles in front of Pacman
                const pivotR = pacPos.r + (pacman.dir.y * 2);
                const pivotC = pacPos.c + (pacman.dir.x * 2);
                
                // Vector from Blinky to Pivot
                const blinkyPos = ghosts[0].getGridPos();
                const vecR = pivotR - blinkyPos.r;
                const vecC = pivotC - blinkyPos.c;

                // Double the vector and add to Pivot
                target = { r: pivotR + vecR, c: pivotC + vecC };
                break;

            case 'clyde': // Orange: Chase Pacman unless close (< 8 tiles)
                const distToPac = Math.sqrt(Math.pow(pacPos.r - this.getGridPos().r, 2) + Math.pow(pacPos.c - this.getGridPos().c, 2));
                if (distToPac > 8) {
                    target = { r: pacPos.r, c: pacPos.c };
                } else {
                    // Scatter to bottom left
                    target = { r: 28, c: 0 }; 
                }
                break;
        }

        // Override for Scatter Mode (Corners)
        if (this.mode === 'SCATTER') {
            if (this.type === 'blinky') target = { r: 0, c: 25 }; // Top Right
            if (this.type === 'pinky') target = { r: 0, c: 2 };   // Top Left
            if (this.type === 'inky') target = { r: 29, c: 27 };  // Bottom Right
            if (this.type === 'clyde') target = { r: 29, c: 0 };  // Bottom Left
        }

        return target;
    }

    draw() {
        const x = this.x;
        const y = this.y;
        const r = this.radius;

        ctx.fillStyle = this.color;
        
        if (this.mode !== 'EATEN') {
            // Draw Body (Dome + Wavy bottom)
            ctx.beginPath();
            ctx.arc(x, y - 2, r, Math.PI, 0);
            ctx.lineTo(x + r, y + r);
            
            // Wavy feet
            for(let i=1; i<=3; i++) {
                ctx.lineTo(x + r - (2*r/3)*i, y + r - (i%2==0 ? 0 : 3));
            }
            ctx.lineTo(x - r, y + r);
            ctx.fill();
            ctx.closePath();

            // Eyes
            if (this.mode === 'FRIGHTENED') {
                // Scared face
                ctx.fillStyle = '#ffb8ae';
                ctx.beginPath();
                ctx.arc(x - 4, y - 2, 2, 0, Math.PI*2);
                ctx.arc(x + 4, y - 2, 2, 0, Math.PI*2);
                ctx.fill();
                
                // Wavy mouth
                ctx.strokeStyle = '#ffb8ae';
                ctx.beginPath();
                ctx.moveTo(x - r/2, y + 5);
                for(let i=1; i<=3; i++) {
                     ctx.lineTo(x - r/2 + (r)*i/3, y + 5 + (i%2==0 ? 0 : 2));
                }
                ctx.stroke();
            } else {
                // Normal Eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x - 4, y - 4, 4, 0, Math.PI*2);
                ctx.arc(x + 4, y - 4, 4, 0, Math.PI*2);
                ctx.fill();

                // Pupils (look in direction)
                ctx.fillStyle = 'blue';
                const pupilOffX = this.dir.x * 2;
                const pupilOffY = this.dir.y * 2;
                ctx.beginPath();
                ctx.arc(x - 4 + pupilOffX, y - 4 + pupilOffY, 1.5, 0, Math.PI*2);
                ctx.arc(x + 4 + pupilOffX, y - 4 + pupilOffY, 1.5, 0, Math.PI*2);
                ctx.fill();
            }
        } else {
            // Just Eyes (Eaten)
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x - 4, y - 4, 4, 0, Math.PI*2);
            ctx.arc(x + 4, y - 4, 4, 0, Math.PI*2);
            ctx.fill();
             // Pupils
            ctx.fillStyle = 'blue';
            const pupilOffX = this.dir.x * 2;
            const pupilOffY = this.dir.y * 2;
            ctx.beginPath();
            ctx.arc(x - 4 + pupilOffX, y - 4 + pupilOffY, 1.5, 0, Math.PI*2);
            ctx.arc(x + 4 + pupilOffX, y - 4 + pupilOffY, 1.5, 0, Math.PI*2);
            ctx.fill();
        }
    }
}

// --- GAME LOGIC ---

let frightenTimer = 0;
let scatterChaseTimer = 0;

function initGame() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // Set canvas size based on map
    canvas.width = RAW_MAP[0].length * ACTUAL_TILE;
    canvas.height = RAW_MAP.length * ACTUAL_TILE;

    resetLevel();
    
    // Input Listeners
    window.addEventListener('keydown', handleInput);
    
    // Touch support
    let touchStartX = 0;
    let touchStartY = 0;
    canvas.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    }, {passive: false});
    
    canvas.addEventListener('touchend', e => {
        e.preventDefault();
        const touchEndX = e.changedTouches[0].screenX;
        const touchEndY = e.changedTouches[0].screenY;
        handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
    }, {passive: false});

    document.getElementById('startBtn').addEventListener('click', startGame);

    // Initial Draw
    draw();
}

function resetLevel() {
    // Deep copy map
    gameMap = JSON.parse(JSON.stringify(RAW_MAP));
    
    // Spawn Entities
    pacman = new Pacman(14, 21); // Starting position
    
    ghosts = [
        new Ghost(14, 11, 'blinky'),
        new Ghost(12, 14, 'pinky'),
        new Ghost(14, 14, 'inky'),
        new Ghost(16, 14, 'clyde')
    ];

    frightenTimer = 0;
    scatterChaseTimer = 0;
    
    // Reset ghost modes
    ghosts.forEach(g => {
        g.mode = 'SCATTER';
        g.inHouse = true;
        g.releaseTimer = (g.type === 'blinky' ? 0 : g.type === 'pinky' ? 180 : g.type === 'inky' ? 420 : 660);
    });
}

function startGame() {
    score = 0;
    lives = 3;
    level = 1;
    gameState = 'PLAYING';
    
    document.getElementById('overlay-screen').classList.add('hidden');
    updateUI();
    
    resetLevel();
    
    if (animationId) cancelAnimationFrame(animationId);
    gameLoop();
}

function handleInput(e) {
    if (gameState !== 'PLAYING') return;

    switch(e.key) {
        case 'ArrowUp': case 'w': case 'W':
            pacman.nextDir = UP; break;
        case 'ArrowDown': case 's': case 'S':
            pacman.nextDir = DOWN; break;
        case 'ArrowLeft': case 'a': case 'A':
            pacman.nextDir = LEFT; break;
        case 'ArrowRight': case 'd': case 'D':
            pacman.nextDir = RIGHT; break;
    }
}

function handleSwipe(sx, sy, ex, ey) {
    if (gameState !== 'PLAYING') return;
    const dx = ex - sx;
    const dy = ey - sy;
    
    if (Math.abs(dx) > Math.abs(dy)) {
        pacman.nextDir = dx > 0 ? RIGHT : LEFT;
    } else {
        pacman.nextDir = dy > 0 ? DOWN : UP;
    }
}

function activatePowerPellet() {
    frightenTimer = 600; // 10 seconds at 60fps
    ghosts.forEach(g => {
        if (g.mode !== 'EATEN') {
            g.mode = 'FRIGHTENED';
            // Reverse direction immediately for classic feel
            g.dir = { x: -g.dir.x, y: -g.dir.y };
        }
    });
}

function checkWinCondition() {
    let dotsLeft = 0;
    for(let r=0; r<gameMap.length; r++) {
        for(let c=0; c<gameMap[0].length; c++) {
            if (gameMap[r][c] === 1 || gameMap[r][c] === 3) dotsLeft++;
        }
    }
    
    if (dotsLeft === 0) {
        levelComplete();
    }
}

function levelComplete() {
    gameState = 'LEVEL_TRANSITION';
    setTimeout(() => {
        level++;
        resetLevel();
        gameState = 'PLAYING';
    }, 2000);
}

function handleDeath() {
    lives--;
    updateUI();
    
    if (lives <= 0) {
        gameOver();
    } else {
        // Reset positions only
        pacman.x = 14 * ACTUAL_TILE + ACTUAL_TILE/2;
        pacman.y = 21 * ACTUAL_TILE + ACTUAL_TILE/2;
        pacman.dir = NONE;
        pacman.nextDir = NONE;
        
        ghosts.forEach((g, index) => {
            g.x = (index === 0 ? 14 : index === 1 ? 12 : index === 2 ? 14 : 16) * ACTUAL_TILE + ACTUAL_TILE/2;
            g.y = (index === 0 ? 11 : 14) * ACTUAL_TILE + ACTUAL_TILE/2;
            g.mode = 'SCATTER';
            g.inHouse = true;
            g.releaseTimer = (g.type === 'blinky' ? 0 : g.type === 'pinky' ? 180 : g.type === 'inky' ? 420 : 660);
        });
    }
}

function gameOver() {
    gameState = 'GAMEOVER';
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('pacman_highscore', highScore);
    }
    
    document.getElementById('titleText').innerText = "GAME OVER";
    document.getElementById('statusText').innerText = `Final Score: ${score}`;
    document.getElementById('startBtn').innerText = "TRY AGAIN";
    document.getElementById('overlay-screen').classList.remove('hidden');
}

function updateUI() {
    document.getElementById('scoreVal').innerText = score;
    document.getElementById('highScoreVal').innerText = highScore;
    
    let livesStr = '';
    for(let i=0; i<lives; i++) livesStr += 'â™¥ ';
    document.getElementById('livesDisplay').innerText = livesStr;
}

// --- DRAWING ---

function drawMap() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw Walls
    ctx.strokeStyle = COLOR_WALL;
    ctx.lineWidth = 2 * SCALE;
    ctx.lineCap = 'round';
    
    // To make it look like the arcade, we draw lines connecting centers of wall tiles
    // Simplified: Just draw blue blocks for walls with a glow
    ctx.shadowBlur = 0;
    
    for(let r=0; r<gameMap.length; r++) {
        for(let c=0; c<gameMap[0].length; c++) {
            const tile = gameMap[r][c];
            const x = c * ACTUAL_TILE;
            const y = r * ACTUAL_TILE;

            if (tile === 0) {
                // Wall
                ctx.fillStyle = COLOR_WALL;
                // Draw slightly smaller than tile for grid effect
                ctx.fillRect(x + 2, y + 2, ACTUAL_TILE - 4, ACTUAL_TILE - 4);
                
                // Inner black square to make it look like a hollow wall (classic style)
                ctx.fillStyle = 'black';
                ctx.fillRect(x + 6, y + 6, ACTUAL_TILE - 12, ACTUAL_TILE - 12);
            } else if (tile === 1) {
                // Dot
                ctx.fillStyle = COLOR_DOT;
                ctx.beginPath();
                ctx.arc(x + ACTUAL_TILE/2, y + ACTUAL_TILE/2, 3 * SCALE, 0, Math.PI*2);
                ctx.fill();
            } else if (tile === 3) {
                // Power Pellet
                ctx.fillStyle = COLOR_PELLET;
                // Pulsing effect
                const pulse = Math.sin(frameCount * 0.1) * 2;
                ctx.beginPath();
                ctx.arc(x + ACTUAL_TILE/2, y + ACTUAL_TILE/2, (6 * SCALE) + pulse, 0, Math.PI*2);
                ctx.fill();
            } else if (tile === 4) {
                // Ghost House Door
                ctx.strokeStyle = 'pink';
                ctx.beginPath();
                ctx.moveTo(x, y + ACTUAL_TILE/2);
                ctx.lineTo(x + ACTUAL_TILE, y + ACTUAL_TILE/2);
                ctx.stroke();
            }
        }
    }
}

function draw() {
    drawMap();
    
    pacman.draw();
    ghosts.forEach(g => g.draw());
}

// --- MAIN LOOP ---

function gameLoop() {
    if (gameState === 'PLAYING' || gameState === 'LEVEL_TRANSITION') {
        
        // Logic
        if (gameState === 'PLAYING') {
            frameCount++;
            
            // Global Timers
            if (frightenTimer > 0) frightenTimer--;
            else {
                // Revert ghosts from frightened to chase/scatter
                ghosts.forEach(g => {
                    if (g.mode === 'FRIGHTENED') g.mode = 'CHASE';
                });
            }

            scatterChaseTimer++;
            // Switch modes every ~20 seconds (1200 frames)
            if (scatterChaseTimer > 1200) {
                const currentMode = ghosts[0].mode;
                const newMode = (currentMode === 'SCATTER') ? 'CHASE' : 'SCATTER';
                ghosts.forEach(g => { if(g.mode !== 'FRIGHTENED' && g.mode !== 'EATEN') g.mode = newMode; });
                scatterChaseTimer = 0;
            }

            pacman.update();
            
            // Ghost Updates & Collision
            ghosts.forEach(g => {
                g.update();
                
                // Check collision with Pacman
                const dist = Math.sqrt(Math.pow(pacman.x - g.x, 2) + Math.pow(pacman.y - g.y, 2));
                if (dist < ACTUAL_TILE * 0.8) {
                    if (g.mode === 'FRIGHTENED') {
                        // Eat Ghost
                        score += 200;
                        g.mode = 'EATEN';
                        updateUI();
                        console.log("Ghost eaten!");
                    } else if (g.mode !== 'EATEN') {
                        // Pacman Dies
                        handleDeath();
                    }
                }
            });
            
            updateUI();
        }

        draw();
    }
    
    animationId = requestAnimationFrame(gameLoop);
}

// Start initialization on load
window.onload = initGame;

</script>
</body>
</html>