<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroids (1979 Arcade Clone)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505; /* Deep black */
            color: #ffffff;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            background-color: black;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 800px;
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px white;
            pointer-events: none;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        h1 {
            font-size: 64px;
            margin-bottom: 20px;
            color: white;
            text-shadow: 4px 4px 0px #333;
            letter-spacing: 5px;
        }

        .controls {
            margin-top: 30px;
            line-height: 1.6;
            font-size: 20px;
            color: #ccc;
            text-align: center;
        }

        button {
            margin-top: 40px;
            padding: 15px 40px;
            font-size: 32px;
            font-family: 'Courier New', Courier, monospace;
            background: transparent;
            color: white;
            border: 4px solid white;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: white;
            color: black;
            box-shadow: 0 0 20px white;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div>SCORE: <span id="score">0</span></div>
        <div>HIGH SCORE: <span id="high-score">0</span></div>
        <div>LIVES: <span id="lives">3</span></div>
    </div>

    <div id="start-screen">
        <h1>ASTEROIDS</h1>
        <div class="controls">
            <p>ROTATE: Left / Right Arrow</p>
            <p>THRUST: Up Arrow</p>
            <p>SHOOT: Spacebar</p>
            <p>WRAP AROUND SCREEN: Yes</p>
        </div>
        <button id="start-btn">INSERT COIN (START)</button>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
/**
 * ASTEROIDS - 1979 Atari Clone
 */

// --- Configuration & Constants ---
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const FPS = 60;
const FRICTION = 0.995; // Space drag (very slight)
const SHIP_THRUST = 0.15;
const SHIP_TURN_SPEED = 0.07; // Radians per frame
const BULLET_SPEED = 8;
const BULLET_LIFETIME = 60; // Frames
const ASTEROID_SPEED = 1.5;
const LIVES_START = 3;

// --- Game State ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const highScoreEl = document.getElementById('high-score');
const startScreen = document.getElementById('start-screen');
const startBtn = document.getElementById('start-btn');

let gameRunning = false;
let score = 0;
let highScore = localStorage.getItem('asteroids_highscore') || 0;
let level = 1;
let lives = LIVES_START;
let frameCount = 0;

// Input State
const keys = {
    ArrowUp: false,
    ArrowLeft: false,
    ArrowRight: false,
    Space: false
};

// Entities
let ship;
let bullets = [];
let asteroids = [];
let ufos = [];
let particles = [];

// --- Helper Functions ---
function randomRange(min, max) {
    return Math.random() * (max - min) + min;
}

function getDistance(x1, y1, x2, y2) {
    return Math.hypot(x2 - x1, y2 - y1);
}

// --- Classes ---

class Vector {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

// 1. The Player Ship
class Ship {
    constructor() {
        this.x = CANVAS_WIDTH / 2;
        this.y = CANVAS_HEIGHT / 2;
        this.radius = 15; // Hitbox radius
        this.angle = -Math.PI / 2; // Pointing up
        this.velocity = { x: 0, y: 0 };
        this.thrusting = false;
        this.shootCooldown = 0;
        this.invincible = 180; // 3 seconds at 60fps
        this.visible = true;
    }

    update() {
        if (this.invincible > 0) {
            this.invincible--;
            // Blink effect
            if (Math.floor(Date.now() / 100) % 2 === 0) this.visible = false;
            else this.visible = true;
        } else {
            this.visible = true;
        }

        // Rotation
        if (keys.ArrowLeft) this.angle -= SHIP_TURN_SPEED;
        if (keys.ArrowRight) this.angle += SHIP_TURN_SPEED;

        // Thrust
        this.thrusting = false;
        if (keys.ArrowUp) {
            this.velocity.x += Math.cos(this.angle) * SHIP_THRUST;
            this.velocity.y += Math.sin(this.angle) * SHIP_THRUST;
            this.thrusting = true;
            
            // Add thrust particles
            const backX = this.x - Math.cos(this.angle) * 15;
            const backY = this.y - Math.sin(this.angle) * 15;
            particles.push(new Particle(backX, backY, 'thrust'));
        }

        // Physics
        this.velocity.x *= FRICTION;
        this.velocity.y *= FRICTION;
        this.x += this.velocity.x;
        this.y += this.velocity.y;

        // Screen Wrap
        if (this.x < 0) this.x = CANVAS_WIDTH;
        if (this.x > CANVAS_WIDTH) this.x = 0;
        if (this.y < 0) this.y = CANVAS_HEIGHT;
        if (this.y > CANVAS_HEIGHT) this.y = 0;

        // Shooting
        if (this.shootCooldown > 0) this.shootCooldown--;
        if (keys.Space && this.shootCooldown <= 0 && this.visible) {
            bullets.push(new Bullet(this.x, this.y, this.angle));
            this.shootCooldown = 15; // Fire rate
        }
    }

    draw() {
        if (!this.visible) return;

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';

        ctx.beginPath();
        
        // Draw Ship Triangle
        const tipX = this.x + Math.cos(this.angle) * 15;
        const tipY = this.y + Math.sin(this.angle) * 15;
        
        // Left corner
        const leftX = this.x + Math.cos(this.angle - 2.6) * 15; 
        const leftY = this.y + Math.sin(this.angle - 2.6) * 15;
        
        // Right corner
        const rightX = this.x + Math.cos(this.angle + 2.6) * 15;
        const rightY = this.y + Math.sin(this.angle + 2.6) * 15;

        ctx.moveTo(tipX, tipY);
        ctx.lineTo(leftX, leftY);
        
        // Draw Thrust Flame if active
        if (this.thrusting) {
            const flameLen = randomRange(10, 20);
            const flameX = this.x - Math.cos(this.angle) * flameLen;
            const flameY = this.y - Math.sin(this.angle) * flameLen;
            ctx.lineTo(flameX, flameY);
        }

        ctx.lineTo(rightX, rightY);
        ctx.closePath();
        ctx.stroke();

        // Draw Engine Glow
        if (this.thrusting && this.invincible === 0) {
            ctx.fillStyle = 'orange';
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'red';
            ctx.beginPath();
            ctx.arc(this.x - Math.cos(this.angle) * 12, this.y - Math.sin(this.angle) * 12, 2, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }
}

// 2. Bullets
class Bullet {
    constructor(x, y, angle) {
        this.x = x;
        this.y = y;
        this.velocity = {
            x: Math.cos(angle) * BULLET_SPEED,
            y: Math.sin(angle) * BULLET_SPEED
        };
        this.life = BULLET_LIFETIME;
    }

    update() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.life--;

        // Wrap bullets
        if (this.x < 0) this.x = CANVAS_WIDTH;
        if (this.x > CANVAS_WIDTH) this.x = 0;
        if (this.y < 0) this.y = CANVAS_HEIGHT;
        if (this.y > CANVAS_HEIGHT) this.y = 0;
    }

    draw() {
        ctx.strokeStyle = '#ffff00'; // Yellow
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.stroke();
    }
}

// 3. Asteroids
class Asteroid {
    constructor(x, y, sizeLevel) {
        this.sizeLevel = sizeLevel; // 3 = Large, 2 = Medium, 1 = Small
        this.x = x || randomRange(0, CANVAS_WIDTH);
        this.y = y || randomRange(0, CANVAS_HEIGHT);
        
        // Ensure asteroid doesn't spawn on ship
        if (ship && getDistance(this.x, this.y, ship.x, ship.y) < 100) {
            this.x += 100;
        }

        this.radius = sizeLevel === 3 ? 40 : (sizeLevel === 2 ? 25 : 12);
        this.velocity = {
            x: randomRange(-ASTEROID_SPEED, ASTEROID_SPEED),
            y: randomRange(-ASTEROID_SPEED, ASTEROID_SPEED)
        };
        
        // Generate jagged shape
        this.vertices = [];
        const numVertices = 8 + Math.floor(Math.random() * 5);
        for (let i = 0; i < numVertices; i++) {
            const angle = (i / numVertices) * Math.PI * 2;
            // Vary the radius to make it jagged
            const rVar = this.radius * randomRange(0.7, 1.3);
            this.vertices.push({
                x: Math.cos(angle) * rVar,
                y: Math.sin(angle) * rVar
            });
        }
        
        this.rotationSpeed = randomRange(-0.02, 0.02);
        this.angle = 0;
    }

    update() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.angle += this.rotationSpeed;

        // Wrap
        if (this.x < -this.radius) this.x = CANVAS_WIDTH + this.radius;
        if (this.x > CANVAS_WIDTH + this.radius) this.x = -this.radius;
        if (this.y < -this.radius) this.y = CANVAS_HEIGHT + this.radius;
        if (this.y > CANVAS_HEIGHT + this.radius) this.y = -this.radius;
    }

    draw() {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        // Draw jagged wireframe
        for (let i = 0; i < this.vertices.length; i++) {
            const v1 = this.vertices[i];
            const v2 = this.vertices[(i + 1) % this.vertices.length];
            
            // Calculate world coordinates
            const x1 = this.x + v1.x * Math.cos(this.angle) - v1.y * Math.sin(this.angle);
            const y1 = this.y + v1.x * Math.sin(this.angle) + v1.y * Math.cos(this.angle);
            
            const x2 = this.x + v2.x * Math.cos(this.angle) - v2.y * Math.sin(this.angle);
            const y2 = this.y + v2.x * Math.sin(this.angle) + v2.y * Math.cos(this.angle);

            if (i === 0) ctx.moveTo(x1, y1);
            else ctx.lineTo(x1, y1);
            
            // Draw line to next vertex
            ctx.lineTo(x2, y2);
        }
        ctx.closePath();
        ctx.stroke();
    }
}

// 4. UFOs
class UFO {
    constructor(type) {
        this.type = type; // 'large' or 'small'
        this.x = -50; // Start off screen left
        this.y = randomRange(50, CANVAS_HEIGHT - 50);
        
        if (type === 'large') {
            this.radius = 30;
            this.speed = 1.5;
            this.hp = 3;
            this.scoreValue = 500;
            this.color = '#ff00ff'; // Magenta
        } else {
            this.x = CANVAS_WIDTH + 50; // Start off screen right
            this.radius = 15;
            this.speed = 4.0;
            this.hp = 1;
            this.scoreValue = 1000;
            this.color = '#ff0000'; // Red
        }

        // Move across screen
        const direction = type === 'large' ? 1 : -1;
        this.velocity = { x: this.speed * direction, y: randomRange(-1, 1) };
        
        this.shootTimer = randomRange(60, 200);
    }

    update() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;

        // Wrap if it goes way off screen
        if (this.x > CANVAS_WIDTH + 50 || this.x < -50) {
            return false; // Remove from game
        }

        // Shooting Logic
        this.shootTimer--;
        if (this.shootTimer <= 0) {
            this.shoot();
            this.shootTimer = this.type === 'large' ? randomRange(120, 300) : randomRange(40, 90);
        }

        return true;
    }

    shoot() {
        // Aim at ship
        const angle = Math.atan2(ship.y - this.y, ship.x - this.x);
        
        if (this.type === 'large') {
            // Slow, inaccurate shots
            bullets.push(new Bullet(this.x, this.y, angle + randomRange(-0.3, 0.3)));
            bullets.push(new Bullet(this.x, this.y, angle));
            bullets.push(new Bullet(this.x, this.y, angle - randomRange(0.3, 0.3)));
        } else {
            // Fast, precise shots
            bullets.push(new Bullet(this.x, this.y, angle));
            // Sometimes a spread
            if (Math.random() > 0.5) {
                bullets.push(new Bullet(this.x, this.y, angle + 0.2));
                bullets.push(new Bullet(this.x, this.y, angle - 0.2));
            }
        }
    }

    draw() {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        
        // Draw Saucer Shape (Wireframe)
        ctx.beginPath();
        
        if (this.type === 'large') {
            // Top dome
            ctx.moveTo(this.x - 15, this.y);
            ctx.quadraticCurveTo(this.x, this.y - 20, this.x + 15, this.y);
            // Bottom saucer
            ctx.lineTo(this.x + 20, this.y + 10);
            ctx.lineTo(this.x - 20, this.y + 10);
            ctx.closePath();
            
            // Center dome line
            ctx.moveTo(this.x - 10, this.y);
            ctx.lineTo(this.x + 10, this.y);
            
        } else {
            // Small UFO (Faster shape)
            ctx.moveTo(this.x - 12, this.y - 5);
            ctx.lineTo(this.x - 6, this.y - 10);
            ctx.lineTo(this.x + 6, this.y - 10);
            ctx.lineTo(this.x + 12, this.y - 5);
            
            ctx.moveTo(this.x - 12, this.y + 5);
            ctx.lineTo(this.x - 6, this.y + 8);
            ctx.lineTo(this.x + 6, this.y + 8);
            ctx.lineTo(this.x + 12, this.y + 5);
            
            // Center body
            ctx.moveTo(this.x - 8, this.y);
            ctx.lineTo(this.x + 8, this.y);
            
            ctx.closePath();
        }
        
        ctx.stroke();
        
        // Engine glow
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

// 5. Particles (Explosions)
class Particle {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'thrust' or 'explosion'
        this.life = type === 'explosion' ? 30 : 15;
        this.size = type === 'explosion' ? randomRange(2, 5) : randomRange(1, 3);
        this.velocity = {
            x: randomRange(-2, 2),
            y: randomRange(-2, 2)
        };
    }

    update() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.life--;
        return this.life > 0;
    }

    draw() {
        ctx.strokeStyle = this.type === 'explosion' ? '#ffaa00' : '#ff6600';
        ctx.lineWidth = 1;
        
        // Fading effect
        ctx.globalAlpha = this.life / (this.type === 'explosion' ? 30 : 15);
        
        if (this.type === 'explosion') {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.stroke();
        } else {
            // Thrust particles are just dots
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(this.x, this.y, this.size, this.size);
        }
        
        ctx.globalAlpha = 1.0;
    }
}

// --- Game Logic Functions ---

function spawnAsteroids(count) {
    asteroids = [];
    for (let i = 0; i < count; i++) {
        // Spawn away from center
        let x, y;
        do {
            x = randomRange(0, CANVAS_WIDTH);
            y = randomRange(0, CANVAS_HEIGHT);
        } while (getDistance(x, y, ship.x, ship.y) < 150);
        
        asteroids.push(new Asteroid(x, y, 3)); // Start with Large
    }
}

function createExplosion(x, y, type) {
    const count = type === 'asteroid' ? 15 : 8;
    for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, 'explosion'));
    }
}

function checkCollisions() {
    // 1. Bullets vs Asteroids
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        let hit = false;
        
        for (let j = asteroids.length - 1; j >= 0; j--) {
            let a = asteroids[j];
            
            if (getDistance(b.x, b.y, a.x, a.y) < a.radius + 5) {
                // Hit!
                createExplosion(a.x, a.y, 'asteroid');
                
                // Score
                if (a.sizeLevel === 3) score += 20;
                else if (a.sizeLevel === 2) score += 50;
                else score += 100;

                // Split Asteroid
                if (a.sizeLevel > 1) {
                    asteroids.push(new Asteroid(a.x, a.y, a.sizeLevel - 1));
                    asteroids.push(new Asteroid(a.x, a.y, a.sizeLevel - 1));
                }
                
                asteroids.splice(j, 1);
                bullets.splice(i, 1);
                hit = true;
                updateUI();
                break; // Bullet can only hit one asteroid
            }
        }
    }

    // 2. Bullets vs UFOs
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        for (let j = ufos.length - 1; j >= 0; j--) {
            let u = ufos[j];
            
            if (getDistance(b.x, b.y, u.x, u.y) < u.radius + 5) {
                createExplosion(u.x, u.y, 'ufo');
                score += u.scoreValue;
                updateUI();
                ufos.splice(j, 1);
                bullets.splice(i, 1);
                break;
            }
        }
    }

    // 3. Ship vs Asteroids
    if (ship.invincible <= 0 && ship.visible) {
        for (let a of asteroids) {
            if (getDistance(ship.x, ship.y, a.x, a.y) < a.radius + ship.radius - 5) {
                handleShipHit();
                break;
            }
        }
    }

    // 4. Ship vs UFOs
    if (ship.invincible <= 0 && ship.visible) {
        for (let u of ufos) {
            if (getDistance(ship.x, ship.y, u.x, u.y) < u.radius + ship.radius) {
                handleShipHit();
                break;
            }
        }
    }
}

function handleShipHit() {
    createExplosion(ship.x, ship.y, 'ship');
    lives--;
    updateUI();
    
    if (lives <= 0) {
        gameOver();
    } else {
        // Respawn
        ship = new Ship();
        ship.invincible = 180; // 3 seconds invincibility
    }
}

function spawnUFO() {
    if (ufos.length === 0 && Math.random() < 0.005) { // 0.5% chance per frame
        const type = Math.random() > 0.7 ? 'small' : 'large';
        ufos.push(new UFO(type));
    }
}

function updateUI() {
    scoreEl.innerText = score;
    livesEl.innerText = lives;
    
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('asteroids_highscore', highScore);
        highScoreEl.innerText = highScore;
    }

    // Check 10k life bonus
    if (Math.floor(score / 10000) > Math.floor((score - (score % 10000)) / 10000) && score > 0) {
        lives++;
        updateUI();
    }
}

function gameOver() {
    gameRunning = false;
    startScreen.style.display = 'flex';
    document.querySelector('#start-screen h1').innerText = "GAME OVER";
    document.querySelector('#start-screen .controls').innerHTML = `Final Score: ${score}`;
    startBtn.innerText = "RESTART GAME";
}

// --- Main Loop ---

function initGame() {
    score = 0;
    lives = LIVES_START;
    level = 1;
    bullets = [];
    asteroids = [];
    ufos = [];
    particles = [];
    
    ship = new Ship();
    spawnAsteroids(4);
    updateUI();
    gameRunning = true;
    startScreen.style.display = 'none';
    
    requestAnimationFrame(gameLoop);
}

function gameLoop() {
    if (!gameRunning) return;

    // Clear Screen
    ctx.fillStyle = '#050505'; // Deep black
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw Stars (Static background)
    ctx.fillStyle = 'white';
    for(let i=0; i<20; i++) {
        // Simple pseudo-random stars based on frame to avoid flickering
        const sx = (Math.sin(i * 132.1) * CANVAS_WIDTH + CANVAS_WIDTH) % CANVAS_WIDTH;
        const sy = (Math.cos(i * 453.2) * CANVAS_HEIGHT + CANVAS_HEIGHT) % CANVAS_HEIGHT;
        ctx.fillRect(sx, sy, 1, 1);
    }

    // Update & Draw Ship
    ship.update();
    ship.draw();

    // Update & Draw Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.update();
        b.draw();
        if (b.life <= 0) bullets.splice(i, 1);
    }

    // Update & Draw Asteroids
    asteroids.forEach(a => { a.update(); a.draw(); });

    // Update & Draw UFOs
    for (let i = ufos.length - 1; i >= 0; i--) {
        let u = ufos[i];
        if (!u.update()) {
            ufos.splice(i, 1);
        } else {
            u.draw();
        }
    }

    // Update & Draw Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        if (!p.update()) {
            particles.splice(i, 1);
        } else {
            p.draw();
        }
    }

    spawnUFO();
    checkCollisions();

    // Level Management
    if (asteroids.length === 0 && ufos.length === 0) {
        level++;
        spawnAsteroids(4 + level); // Increase difficulty
    }

    requestAnimationFrame(gameLoop);
}

// --- Event Listeners ---

window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowUp') keys.ArrowUp = true;
    if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
    if (e.code === 'ArrowRight') keys.ArrowRight = true;
    if (e.code === 'Space') keys.Space = true;
});

window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowUp') keys.ArrowUp = false;
    if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
    if (e.code === 'ArrowRight') keys.ArrowRight = false;
    if (e.code === 'Space') keys.Space = false;
});

startBtn.addEventListener('click', () => {
    initGame();
});

// Initial High Score Load
highScoreEl.innerText = highScore;

</script>
</body>
</html>