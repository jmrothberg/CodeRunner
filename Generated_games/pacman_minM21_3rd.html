<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Classic Pac-Man 1980</title>
    <style>
        body {
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            border: 4px solid #222;
            box-shadow: 0 0 20px rgba(0,0,255,0.2);
        }
        canvas {
            display: block;
            background-color: black;
        }
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 2px 2px #000;
        }
        #center-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
        }
        h1 { margin: 0; font-size: 40px; color: yellow; }
        p { font-size: 18px; color: white; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <div id="score-board">Score: 0</div>
        <div id="high-score">High Score: 0</div>
    </div>
    <!-- Canvas height set to 25 rows * 16px = 400px -->
    <canvas id="gameCanvas" width="448" height="400"></canvas>
    <div id="center-msg">
        <h1 id="msg-title">READY!</h1>
        <p>Press Space to Start</p>
    </div>
</div>

<script>
/**
 * PAC-MAN CLONE
 * Based on 1980 Namco Arcade Machine
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONSTANTS & CONFIG ---
const TILE_SIZE = 16; // Size of one grid block
const COLS = 28;
// ROWS corrected to match MAP_LAYOUT length (25)
const ROWS = 25;
const PACMAN_SPEED = 1.5; // Pixels per frame
const GHOST_SPEED = 1.25; 
const GHOST_SCARED_SPEED = 0.5;

// Map Key: 0=Dot, 1=Wall, 2=PowerPellet, 3=GhostHouse(Empty), 4=Door(Ghosts only), 5=Empty
// A simplified symmetrical representation of the classic maze
const MAP_LAYOUT = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,2,1],
    [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
    [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],
    [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,0,1,1,1,1,1,3,1,1,3,1,1,1,1,1,0,1,1,1,1,1,1],
    [1,1,1,1,1,1,0,1,1,3,3,3,3,3,3,3,3,3,3,1,1,0,1,1,1,1,1,1],
    [1,1,1,1,1,1,0,1,1,3,1,1,1,4,4,1,1,1,3,1,1,0,1,1,1,1,1,1],
    [5,5,5,5,5,5,0,5,5,3,1,1,1,1,1,1,1,1,3,5,5,0,5,5,5,5,5,5], // Tunnel area
    [1,1,1,1,1,1,0,1,1,3,1,1,1,1,1,1,1,1,3,1,1,0,1,1,1,1,1,1],
    [1,1,1,1,1,1,0,1,1,3,3,3,3,3,3,3,3,3,3,1,1,0,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
    [1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
    [1,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,1,1,1],
    [1,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,1,1,1],
    [1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],
    [1,2,0,0,0,1,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,1,0,0,0,2,1],
    [1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],
    [1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1],
    [5,5,5,5,5,5,0,5,5,5,5,5,0,1,1,0,5,5,5,5,5,0,5,5,5,5,5,5], // Tunnel
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];

// Directions
const UP = { x: 0, y: -1 };
const DOWN = { x: 0, y: 1 };
const LEFT = { x: -1, y: 0 };
const RIGHT = { x: 1, y: 0 };
const STOP = { x: 0, y: 0 };

// Game State
let gameLoopId;
let score = 0;
let highScore = localStorage.getItem('pacman_highscore') || 0;
let lives = 3;
let level = 1;
let gameState = 'START'; // START, PLAYING, PAUSED, GAMEOVER, WIN
let powerModeTime = 0; // Frames remaining for power mode
let fruitTimer = 0;
let fruitActive = false;
let fruitPos = { x: 13 * TILE_SIZE, y: 15 * TILE_SIZE }; // Center bottom

// Entities
let pacman = {};
let ghosts = [];
let map = [];

// --- INITIALIZATION ---

function initGame() {
    document.getElementById('high-score').innerText = `High Score: ${highScore}`;
    resetLevel();
    
    // Input handling
    window.addEventListener('keydown', handleInput);
    
    gameLoop();
}

function resetLevel() {
    // Deep copy map
    map = MAP_LAYOUT.map(row => [...row]);
    
    // Reset Pacman
    pacman = {
        x: 15 * TILE_SIZE, // Center-ish
        y: 23 * TILE_SIZE,
        dir: STOP,
        nextDir: STOP,
        mouthOpen: 0,
        mouthSpeed: 0.2,
        radius: 7,
        speed: PACMAN_SPEED
    };

    // Reset Ghosts (Colors: Red, Pink, Cyan, Orange)
    ghosts = [
        createGhost(13.5, 11, 'red', 'chase'),     // Blinky
        createGhost(14.5, 11, 'pink', 'ambush'),   // Pinky
        createGhost(13.5, 14, 'cyan', 'flank'),    // Inky
        createGhost(14.5, 14, 'orange', 'erratic') // Clyde
    ];

    powerModeTime = 0;
    fruitActive = false;
    fruitTimer = 0;
    
    updateUI();
}

function createGhost(x, y, color, type) {
    return {
        x: x * TILE_SIZE,
        y: y * TILE_SIZE,
        color: color,
        type: type,
        dir: [LEFT, RIGHT][Math.floor(Math.random()*2)], // Start moving
        speed: GHOST_SPEED,
        scared: false,
        eaten: false,
        animOffset: 0
    };
}

// --- INPUT ---

function handleInput(e) {
    if (gameState === 'START' || gameState === 'GAMEOVER') {
        if (e.code === 'Space') {
            startGame();
        }
        return;
    }

    // Prevent scrolling with arrows/space
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].indexOf(e.code) > -1) {
        e.preventDefault();
    }

    switch(e.key) {
        case 'ArrowUp': pacman.nextDir = UP; break;
        case 'ArrowDown': pacman.nextDir = DOWN; break;
        case 'ArrowLeft': pacman.nextDir = LEFT; break;
        case 'ArrowRight': pacman.nextDir = RIGHT; break;
    }
}

function startGame() {
    gameState = 'PLAYING';
    score = 0;
    lives = 3;
    level = 1;
    document.getElementById('center-msg').style.display = 'none';
    resetLevel();
}

// --- GAME LOGIC ---

function update() {
    if (gameState !== 'PLAYING') return;

    // Fruit Spawning
    fruitTimer++;
    if (!fruitActive && fruitTimer > 600) { // Approx 10 seconds at 60fps
        fruitActive = true;
    }

    // Power Mode Logic
    if (powerModeTime > 0) {
        powerModeTime--;
        if (powerModeTime < 120 && Math.floor(powerModeTime / 15) % 2 === 0) {
            // Flash effect handled in draw
        }
    } else {
        ghosts.forEach(g => g.scared = false);
    }

    movePacman();

    ghosts.forEach(ghost => moveGhost(ghost));
    
    // Check Ghost Collisions after movement
    ghosts.forEach(ghost => {
        if (!ghost.eaten && rectIntersect(pacman.x - 6, pacman.y - 6, 12, 12, ghost.x - 7, ghost.y - 7, 14, 14)) {
            handleGhostCollision(ghost);
        }
    });
}

function movePacman() {
    // Try to change direction
    if (pacman.nextDir !== STOP) {
        let col = Math.round(pacman.x / TILE_SIZE);
        let row = Math.round(pacman.y / TILE_SIZE);
        
        // Check if centered enough to turn
        if (Math.abs((col * TILE_SIZE) - pacman.x) < 2 && 
            Math.abs((row * TILE_SIZE) - pacman.y) < 2) {
            
            let nextCol = col + pacman.nextDir.x;
            let nextRow = row + pacman.nextDir.y;

            if (!isWall(nextCol, nextRow)) {
                pacman.dir = pacman.nextDir;
                // Snap to grid center for clean turning
                pacman.x = col * TILE_SIZE;
                pacman.y = row * TILE_SIZE;
            }
        }
    }

    let nextX = pacman.x + (pacman.dir.x * pacman.speed);
    let nextY = pacman.y + (pacman.dir.y * pacman.speed);

    // Wall Collision
    if (!isWallCollision(nextX, nextY)) {
        pacman.x = nextX;
        pacman.y = nextY;
        
        // Screen Wrapping
        if (pacman.x < -TILE_SIZE) pacman.x = canvas.width;
        if (pacman.x > canvas.width) pacman.x = -TILE_SIZE;

        // Eat Dots
        let c = Math.round(pacman.x / TILE_SIZE);
        let r = Math.round(pacman.y / TILE_SIZE);
        
        if (map[r] && map[r][c] === 0) {
            map[r][c] = 5; // Empty
            score += 10;
            checkWin();
        } else if (map[r] && map[r][c] === 2) {
            map[r][c] = 5; // Empty
            score += 50;
            activatePowerMode();
        }

        // Eat Fruit
        if (fruitActive && Math.abs(pacman.x - fruitPos.x) < TILE_SIZE && Math.abs(pacman.y - fruitPos.y) < TILE_SIZE) {
            fruitActive = false;
            score += (level * 100);
        }
    } else {
        // Stopped by wall, snap to center of current tile
        pacman.x = Math.round(pacman.x / TILE_SIZE) * TILE_SIZE;
        pacman.y = Math.round(pacman.y / TILE_SIZE) * TILE_SIZE;
    }

    // Animation
    pacman.mouthOpen += pacman.mouthSpeed;
    if (pacman.mouthOpen > 0.25 || pacman.mouthOpen < 0) pacman.mouthSpeed *= -1;
}

function moveGhost(ghost) {
    let speed = ghost.eaten ? GHOST_SPEED * 2 : (ghost.scared ? GHOST_SCARED_SPEED : GHOST_SPEED);
    
    // If eaten, target is the ghost house center
    if (ghost.eaten && Math.abs(ghost.x - 14*TILE_SIZE) < 4 && Math.abs(ghost.y - 14*TILE_SIZE) < 4) {
        ghost.eaten = false;
        ghost.scared = true; // Respawn scared
        return;
    }

    let col = Math.round(ghost.x / TILE_SIZE);
    let row = Math.round(ghost.y / TILE_SIZE);

    // Decision Point: Center of tile?
    if (Math.abs((col * TILE_SIZE) - ghost.x) < speed && 
        Math.abs((row * TILE_SIZE) - ghost.y) < speed) {
        
        ghost.x = col * TILE_SIZE;
        ghost.y = row * TILE_SIZE;

        // Get valid directions
        let dirs = [UP, DOWN, LEFT, RIGHT];
        let validDirs = dirs.filter(d => !isWall(col + d.x, row + d.y));

        // Don't reverse direction unless dead end or frightened (except eaten ghosts)
        if (!ghost.eaten && validDirs.length > 1) {
            validDirs = validDirs.filter(d => !(d.x === -ghost.dir.x && d.y === -ghost.dir.y));
        }

        // Ghost House Door Logic
        let tileVal = map[row][col];
        if (tileVal !== 4) { 
             // Normal movement logic
        } else {
            // Can only go UP from door
            validDirs = [UP]; 
        }
        
        // If eaten, must enter house (Door is at 14,11 roughly)
        if (ghost.eaten && row === 12) {
             // Force down into house
             validDirs = [DOWN];
        }

        if (validDirs.length > 0) {
            ghost.dir = getBestDirection(ghost, validDirs);
        } else {
            // Dead end, reverse
            ghost.dir = { x: -ghost.dir.x, y: -ghost.dir.y };
        }
    }

    let nextX = ghost.x + (ghost.dir.x * speed);
    let nextY = ghost.y + (ghost.dir.y * speed);

    ghost.x = nextX;
    ghost.y = nextY;

    // Screen Wrap for ghosts too
    if (ghost.x < -TILE_SIZE) ghost.x = canvas.width;
    if (ghost.x > canvas.width) ghost.x = -TILE_SIZE;

    // Animation feet
    ghost.animOffset += 0.2;
}

function getBestDirection(ghost, candidates) {
    let target = { x: pacman.x, y: pacman.y };

    if (ghost.eaten) {
        target = { x: 14 * TILE_SIZE, y: 14 * TILE_SIZE }; // Ghost House
    } else if (ghost.scared) {
        // Random choice when scared
        return candidates[Math.floor(Math.random() * candidates.length)];
    } else {
        // AI Logic
        switch(ghost.type) {
            case 'chase': // Red - Direct Chase
                break;
            case 'ambush': // Pink - 4 tiles ahead of Pacman
                target = { 
                    x: pacman.x + (pacman.dir.x * TILE_SIZE * 4), 
                    y: pacman.y + (pacman.dir.y * TILE_SIZE * 4) 
                };
                break;
            case 'flank': // Cyan - Try to get perpendicular
                 target = { x: pacman.x - (pacman.dir.x * TILE_SIZE * 2), y: pacman.y - (pacman.dir.y * TILE_SIZE * 2) };
                 if(Math.random() > 0.5) target.x += 100; else target.y += 100;
                 break;
            case 'erratic': // Orange - Chase until close, then scatter to corner
                let dist = Math.hypot(pacman.x - ghost.x, pacman.y - ghost.y);
                if (dist < TILE_SIZE * 8) {
                    target = { x: 1 * TILE_SIZE, y: 1 * TILE_SIZE }; // Top Left Corner
                }
                break;
        }
    }

    // Sort candidates by distance to target
    return candidates.sort((a, b) => {
        let distA = Math.hypot((ghost.x + a.x*TILE_SIZE) - target.x, (ghost.y + a.y*TILE_SIZE) - target.y);
        let distB = Math.hypot((ghost.x + b.x*TILE_SIZE) - target.x, (ghost.y + b.y*TILE_SIZE) - target.y);
        return distA - distB;
    })[0];
}

function isWall(col, row) {
    if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return true; // Out of bounds
    let tile = map[row][col];
    return tile === 1; 
}

function isWallCollision(x, y) {
    // Check corners of the entity bounding box
    const margin = 2;
    let left = Math.floor((x - margin) / TILE_SIZE);
    let right = Math.floor((x + margin) / TILE_SIZE);
    let top = Math.floor((y - margin) / TILE_SIZE);
    let bottom = Math.floor((y + margin) / TILE_SIZE);

    return isWall(left, top) || isWall(right, top) || isWall(left, bottom) || isWall(right, bottom);
}

function activatePowerMode() {
    powerModeTime = 600; // 10 seconds
    ghosts.forEach(g => {
        if (!g.eaten) g.scared = true;
    });
}

function handleGhostCollision(ghost) {
    if (ghost.scared && !ghost.eaten) {
        ghost.eaten = true;
        score += 200;
    } else if (!ghost.eaten) {
        // Pacman dies
        lives--;
        updateUI();
        if (lives <= 0) {
            gameState = 'GAMEOVER';
            showCenterMsg("GAME OVER", "Press Space");
        } else {
            resetPositionsOnly();
        }
    }
}

function checkWin() {
    let dotsLeft = false;
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if (map[r][c] === 0 || map[r][c] === 2) dotsLeft = true;
        }
    }
    if (!dotsLeft) {
        level++;
        resetLevel();
    }
}

function resetPositionsOnly() {
    pacman.x = 15 * TILE_SIZE;
    pacman.y = 23 * TILE_SIZE;
    pacman.dir = STOP;
    pacman.nextDir = STOP;

    ghosts.forEach((g, i) => {
        g.x = (13.5 + (i%2)) * TILE_SIZE; // Rough reset
        g.y = (11 + Math.floor(i/2)) * TILE_SIZE;
        if(level > 1 && !g.scared) g.dir = [LEFT, RIGHT][Math.floor(Math.random()*2)];
    });
    
    powerModeTime = 0;
}

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

function updateUI() {
    document.getElementById('score-board').innerText = `Score: ${score}`;
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('pacman_highscore', highScore);
        document.getElementById('high-score').innerText = `High Score: ${highScore}`;
    }
}

function showCenterMsg(title, sub) {
    const el = document.getElementById('center-msg');
    document.getElementById('msg-title').innerText = title;
    el.querySelector('p').innerText = sub;
    el.style.display = 'block';
}

// --- DRAWING ---

function draw() {
    // Clear
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawMap();
    
    if (fruitActive) drawFruit();

    ghosts.forEach(g => drawGhost(g));
    
    drawPacman();
}

function drawMap() {
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            let x = c * TILE_SIZE;
            let y = r * TILE_SIZE;
            let tile = map[r][c];

            if (tile === 1) {
                drawWall(x, y);
            } else if (tile === 0) {
                ctx.fillStyle = '#ffb8ae';
                ctx.beginPath();
                ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (tile === 2) {
                // Power Pellet Blink
                if (Math.floor(Date.now() / 200) % 2 === 0 || powerModeTime > 0) {
                    ctx.fillStyle = '#ffb8ae';
                    ctx.beginPath();
                    ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (tile === 4) {
                // Ghost House Door
                ctx.fillStyle = 'pink';
                ctx.fillRect(x + 2, y + TILE_SIZE - 4, TILE_SIZE - 4, 4);
            }
        }
    }
}

function drawWall(x, y) {
    ctx.strokeStyle = '#1919A6'; // Classic Blue
    ctx.lineWidth = 2;
    
    let isTop = (y > 0 && map[y/TILE_SIZE - 1][x/TILE_SIZE] === 1);
    let isBottom = (y < canvas.height - TILE_SIZE && map[y/TILE_SIZE + 1][x/TILE_SIZE] === 1);
    let isLeft = (x > 0 && map[y/TILE_SIZE][x/TILE_SIZE - 1] === 1);
    let isRight = (x < canvas.width - TILE_SIZE && map[y/TILE_SIZE][x/TILE_SIZE + 1] === 1);

    ctx.beginPath();
    
    // Draw connections if needed
    if (!isTop) { ctx.moveTo(x+2, y); ctx.lineTo(x+TILE_SIZE-2, y); }
    if (!isBottom) { ctx.moveTo(x+2, y + TILE_SIZE); ctx.lineTo(x+TILE_SIZE-2, y + TILE_SIZE); }
    
    // Simplified: Just draw the block outline
    ctx.strokeRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
    
    // Inner detail (classic style)
    ctx.fillStyle = 'black';
    ctx.fillRect(x+6, y+6, TILE_SIZE-12, TILE_SIZE-12);
}

function drawPacman() {
    let cx = pacman.x + TILE_SIZE/2;
    let cy = pacman.y + TILE_SIZE/2;

    // Calculate rotation based on direction
    let angle = 0;
    if (pacman.dir === DOWN) angle = Math.PI / 2;
    if (pacman.dir === LEFT) angle = Math.PI;
    if (pacman.dir === UP) angle = -Math.PI / 2;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);

    // Mouth animation
    let mouth = Math.max(0, pacman.mouthOpen);
    
    ctx.beginPath();
    ctx.arc(0, 0, pacman.radius, mouth * Math.PI, (2 - mouth) * Math.PI);
    ctx.lineTo(0, 0);
    ctx.fillStyle = 'yellow';
    ctx.fill();
    ctx.restore();
}

function drawGhost(g) {
    let cx = g.x + TILE_SIZE/2;
    let cy = g.y + TILE_SIZE/2;

    // Color logic
    if (g.eaten) {
        ctx.fillStyle = 'transparent'; // Just eyes
    } else if (g.scared) {
        // Flash white/blue near end of power mode
        if (powerModeTime < 120 && Math.floor(Date.now() / 100) % 2 === 0) {
            ctx.fillStyle = 'white';
        } else {
            ctx.fillStyle = '#0000FF'; // Blue
        }
    } else {
        switch(g.color) {
            case 'red': ctx.fillStyle = '#FF0000'; break;
            case 'pink': ctx.fillStyle = '#FFB8FF'; break;
            case 'cyan': ctx.fillStyle = '#00FFFF'; break;
            case 'orange': ctx.fillStyle = '#FFB852'; break;
        }
    }

    // Draw Body (Dome + Skirt)
    if (!g.eaten) {
        ctx.beginPath();
        ctx.arc(cx, cy - 2, 7, Math.PI, 0);
        ctx.lineTo(cx + 7, cy + 6);
        
        // Wavy feet animation
        let feet = Math.sin(g.animOffset) * 1.5;
        ctx.lineTo(cx + 4, cy + 6 - feet);
        ctx.lineTo(cx, cy + 6 + feet);
        ctx.lineTo(cx - 4, cy + 6 - feet);
        ctx.lineTo(cx - 7, cy + 6);
        
        ctx.fill();
    }

    // Eyes
    if (!g.eaten) {
        drawEyes(cx - 3, cy - 2, g.dir);
        drawEyes(cx + 3, cy - 2, g.dir);
    } else {
        // Just eyes floating
        drawEyes(cx - 3, cy - 2, {x:0,y:0}, true);
        drawEyes(cx + 3, cy - 2, {x:0,y:0}, true);
    }
}

function drawEyes(x, y, dir, small=false) {
    ctx.fillStyle = 'white';
    let s = small ? 3 : 4;
    ctx.beginPath();
    ctx.arc(x, y, s, 0, Math.PI*2);
    ctx.fill();

    // Pupil
    ctx.fillStyle = 'blue';
    let px = dir.x * 1.5;
    let py = dir.y * 1.5;
    if (small) { px=0; py=0; }
    
    ctx.beginPath();
    ctx.arc(x + px, y + py, s/2, 0, Math.PI*2);
    ctx.fill();
}

function drawFruit() {
    let x = fruitPos.x + TILE_SIZE/2;
    let y = fruitPos.y + TILE_SIZE/2;

    // Cherry
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(x - 3, y - 2, 4, 0, Math.PI*2);
    ctx.arc(x + 3, y - 2, 4, 0, Math.PI*2);
    ctx.fill();

    // Stem
    ctx.strokeStyle = 'green';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y-5);
    ctx.quadraticCurveTo(x+3, y-8, x+6, y-10);
    ctx.stroke();
}

// --- MAIN LOOP ---

function gameLoop() {
    update();
    draw();
    
    if (gameState === 'START') {
        showCenterMsg("PAC-MAN", "Press Space");
    }

    requestAnimationFrame(gameLoop);
}

// Start
initGame();

</script>
</body>
</html>