<html lang="en">
<head>
<meta charset="utf-8" />
<title>Pac-Man - HTML5 Canvas</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  html, body {
    background: #000;
    color: #fff;
    margin: 0;
    height: 100%;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    user-select: none;
    overflow: hidden;
  }
  .wrap {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    gap: 16px;
    flex-direction: column;
  }
  canvas {
    background: #000;
    image-rendering: pixelated;
    border: 2px solid #1a1aff;
    box-shadow: 0 0 24px rgba(26,26,255,0.35);
  }
  .hud {
    display: flex;
    gap: 32px;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    letter-spacing: 0.5px;
  }
  .btnbar {
    display: flex;
    gap: 8px;
  }
  button {
    background: #1a1aff;
    color: white;
    border: none;
    padding: 6px 10px;
    border-radius: 4px;
    cursor: pointer;
  }
  button:hover { filter: brightness(1.15); }
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Lives: <span id="lives">3</span></div>
    <div>Level: <span id="level">1</span></div>
    <div class="btnbar">
      <button id="pauseBtn" title="P">Pause</button>
      <button id="restartBtn" title="R">Restart</button>
    </div>
  </div>
  <canvas id="game" width="504" height="558"></canvas>
  <div style="opacity:0.8; font-size:12px;">
    Controls: Arrow keys or WASD to move • P to pause/resume • R to restart
  </div>
</div>

<script>
(() => {
  // Constants
  const TILE = 18;
  const WIDTH = 28, HEIGHT = 31; // classic maze size
  const CANVAS_W = WIDTH * TILE;
  const CANVAS_H = HEIGHT * TILE;

  const COLORS = {
    wall: "#1a1aff",
    pellet: "#f8f8ff",
    power: "#ffffff",
    pacman: "#ffe000",
    blinky: "#ff0000",
    pinky: "#ffb8ff",
    inky: "#00ffff",
    clyde: "#ffb852",
    eyes: "#ffffff",
    frightened: "#1a1aff",
    text: "#fff"
  };

  const DIRS = [
    {x: 0, y: -1}, // up
    {x: -1, y: 0}, // left
    {x: 0, y: 1},  // down
    {x: 1, y: 0}   // right
  ];
  const DIR_INDEX = {up:0, left:1, down:2, right:3};

  // Game state
  let canvas, ctx;
  let grid; // char grid
  let pellets; // pellet map: 0 none, 1 pellet, 2 power
  let pelletCount = 0;

  let score = 0;
  let lives = 3;
  let level = 1;

  let paused = false;
  let gameOver = false;
  let readyMessageTimer = 0; // show READY! / GAME OVER

  // Entities
  const pacman = {
    x: 0, y: 0,
    dir: {x: 0, y: 0},
    nextDir: {x: 0, y: 0},
    speed: 80, // px/s
    mouthTime: 0,
    mouthSpeed: 6, // animation speed
    radius: TILE * 0.45
  };

  const ghosts = []; // will fill with 4 ghosts

  // Timings and phases
  let lastTime = 0;
  let globalTime = 0;

  // Scatter/Chase cycle (seconds)
  const PHASES = [
    {mode: "scatter", duration: 7},
    {mode: "chase",   duration: 20},
    {mode: "scatter", duration: 7},
    {mode: "chase",   duration: 20},
    {mode: "scatter", duration: 5},
    {mode: "chase",   duration: 20}
  ];
  let phaseIndex = 0;
  let phaseTimer = PHASES[0].duration;

  // Frightened mode
  let frightenedTimer = 0; // seconds left
  let eatChain = 0; // ghost-eaten chain within one frightened

  // Ghost house settings (tile coordinates)
  const GH = {
    x: Math.floor(WIDTH/2) - 4, // interior left
    y: Math.floor(HEIGHT/2),    // interior top
    w: 8,
    h: 3,
    gateX: Math.floor(WIDTH/2),
    gateY: Math.floor(HEIGHT/2) - 1
  };

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function tileCenter(tx, ty){ return {x: tx * TILE + TILE/2, y: ty * TILE + TILE/2}; }
  function toTile(px){ return Math.floor(px / TILE); }
  function sign(n){ return n === 0 ? 0 : (n > 0 ? 1 : -1); }

  // Build maze grid
  function buildMaze() {
    const g = Array.from({length: HEIGHT}, () => Array(WIDTH).fill(' '));

    // Border walls
    for (let x=0;x<WIDTH;x++){ g[0][x]='X'; g[HEIGHT-1][x]='X'; }
    for (let y=0;y<HEIGHT;y++){ g[y][0]='X'; g[y][WIDTH-1]='X'; }

    // Tunnels on row 14 (index), columns 0 and WIDTH-1
    g[14][0] = ' ';
    g[14][WIDTH-1] = ' ';

    // Helper to draw rectangles of walls
    function rect(x,y,w,h){
      for(let j=0;j<h;j++){
        for(let i=0;i<w;i++){
          const xx=x+i, yy=y+j;
          if (xx>0 && xx<WIDTH-1 && yy>0 && yy<HEIGHT-1) g[yy][xx]='X';
        }
      }
    }

    // Top and bottom bands
    rect(2, 3, WIDTH-4, 1);
    rect(2, HEIGHT-4, WIDTH-4, 1);

    // Left/right vertical bars with openings
    for (let y=6;y<=HEIGHT-7;y++){
      if (![12,14,16].includes(y)) g[y][6] = 'X';
      if (![11,14,17].includes(y)) g[y][WIDTH-7] = 'X';
    }

    // Middle horizontal bars
    rect(2, 9, WIDTH-4, 1);
    rect(2, HEIGHT-10, WIDTH-4, 1);

    // Ghost house area
    for (let y=GH.y; y<GH.y+GH.h; y++){
      for (let x=GH.x; x<GH.x+GH.w; x++){
        g[y][x] = 'H'; // interior
      }
    }
    // Gate above the house
    g[GH.gateY][GH.gateX] = 'D';

    // Connect gate to top band with a vertical column at center
    for (let y=3; y<GH.gateY; y++){
      if (![12,14].includes(y)) g[y][Math.floor(WIDTH/2)] = 'X';
    }

    // Add some interior obstacles near house to shape paths
    rect(Math.floor(WIDTH/2)-6, 7, 3, 1);
    rect(Math.floor(WIDTH/2)+4, 7, 3, 1);

    return g;
  }

  function placePellets() {
    pellets = Array.from({length: HEIGHT}, () => Array(WIDTH).fill(0));
    pelletCount = 0;

    for (let y=1;y<HEIGHT-1;y++){
      for (let x=1;x<WIDTH-1;x++){
        const t = grid[y][x];
        if (t === ' ') {
          pellets[y][x] = 1;
          pelletCount++;
        } else if (t === 'D') {
          // gate has no pellet
        }
      }
    }

    // Power pellets at four corners inside the maze
    const powerSpots = [
      {x:1, y:1},
      {x:WIDTH-2, y:1},
      {x:1, y:HEIGHT-2},
      {x:WIDTH-2, y:HEIGHT-2}
    ];
    for (const p of powerSpots) {
      if (grid[p.y][p.x] === ' ') {
        pellets[p.y][p.x] = 2;
        pelletCount++;
      }
    }

    // Remove pellets inside ghost house interior
    for (let y=GH.y; y<GH.y+GH.h; y++){
      for (let x=GH.x; x<GH.x+GH.w; x++){
        if (pellets[y][x] !== 0) {
          pelletCount -= pellets[y][x] ? 1 : 0;
          pellets[y][x] = 0;
        }
      }
    }

    // No pellet on gate
    pellets[GH.gateY][GH.gateX] = 0;

    // Ensure tunnel tiles have no pellets (they're ' ')
    pellets[14][0] = 0;
    pellets[14][WIDTH-1] = 0;
  }

  function isInside(tx, ty){
    return tx >= 0 && tx < WIDTH && ty >= 0 && ty < HEIGHT;
  }
  function tileAt(tx, ty) {
    if (!isInside(tx,ty)) return 'X';
    return grid[ty][tx];
  }

  // Walkability
  function isWalkableForPacman(tx, ty){
    const t = tileAt(tx, ty);
    if (t === 'X') return false;
    if (t === 'D') return false; // gate blocks Pac-Man
    return true;
  }
  function isWalkableForGhost(tx, ty, ghost){
    const t = tileAt(tx, ty);
    if (t === 'X') return false;
    if (t === 'D') {
      // Gate allows ghosts to pass only when leaving house or returning as eyes
      if (ghost.state === "eyes") return true; // going home through gate
      // If in house and trying to go out via the gate tile itself, allow stepping onto it
      if (ty === GH.gateY && tx === GH.gateX) {
        // Only allow if they are inHouse and moving upward towards exit
        return ghost.inHouse;
      }
      return false;
    }
    return true;
  }

  function resetEntitiesPositions() {
    // Pac-Man start near bottom center
    const px = Math.floor(WIDTH/2);
    const py = HEIGHT - 8;
    const c = tileCenter(px, py);
    pacman.x = c.x; pacman.y = c.y;
    pacman.dir = {x:0,y:0};
    pacman.nextDir = {x:0,y:0};

    // Ghosts start positions inside house
    const gx = Math.floor(WIDTH/2);
    const gy = GH.y + 1;

    ghosts.length = 0;
    ghosts.push(makeGhost("blinky", COLORS.blinky, gx-1, gy, DIR_INDEX.right));
    ghosts.push(makeGhost("pinky",  COLORS.pinky,  gx+1, gy, DIR_INDEX.left));
    ghosts.push(makeGhost("inky",   COLORS.inky,   gx-2, gy, DIR_INDEX.right));
    ghosts.push(makeGhost("clyde",  COLORS.clyde,  gx+2, gy, DIR_INDEX.left));

    // Reset frightened/eat chain
    frightenedTimer = 0;
    eatChain = 0;

    // Reset scatter/chase phase
    phaseIndex = 0;
    phaseTimer = PHASES[0].duration;
  }

  function makeGhost(name, color, tx, ty, dirIdx){
    const c = tileCenter(tx, ty);
    return {
      name,
      color,
      x: c.x, y: c.y,
      dirIndex: dirIdx,
      speed: 75, // px/s
      state: "inHouse", // inHouse -> leaving -> chase/scatter/frightened/eyes
      inHouse: true,
      leaveTimer: 2.0 + Math.random()*1.5, // seconds before leaving house
      homeTarget: {x: Math.floor(WIDTH/2), y: GH.y+1}, // inside house center
      scatterTarget: {x: (name==="blinky"?WIDTH-2: name==="pinky"?1 : name==="inky"?WIDTH-2:1),
                      y: (name==="blinky"||name==="inky")?1:HEIGHT-2}
    };
  }

  function resetLevel(newLevel=false) {
    if (newLevel) level++;
    // Rebuild maze and pellets
    grid = buildMaze();
    placePellets();

    // Reset entities
    resetEntitiesPositions();

    readyMessageTimer = 2.0; // show READY!
    gameOver = false;
  }

  function restartGame() {
    score = 0;
    lives = 3;
    level = 1;
    updateHUD();
    resetLevel(false);
  }

  // Input
  const keys = {};
  window.addEventListener('keydown', (e) => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    keys[e.code] = true;

    switch(e.code){
      case 'KeyP':
        paused = !paused;
        document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
        break;
      case 'KeyR':
        restartGame();
        break;
      case 'ArrowUp':
      case 'KeyW': pacman.nextDir = {x:0,y:-1}; break;
      case 'ArrowDown':
      case 'KeyS': pacman.nextDir = {x:0,y:1}; break;
      case 'ArrowLeft':
      case 'KeyA': pacman.nextDir = {x:-1,y:0}; break;
      case 'ArrowRight':
      case 'KeyD': pacman.nextDir = {x:1,y:0}; break;
    }
  });
  window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
  });

  document.getElementById('pauseBtn').addEventListener('click', ()=>{
    paused = !paused;
    document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
  });
  document.getElementById('restartBtn').addEventListener('click', restartGame);

  // Audio (simple beeps)
  let audioCtx = null;
  function ensureAudio(){
    if (!audioCtx) {
      try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      catch(e){}
    }
  }
  function beep(freq=800, duration=0.05, type='square', volume=0.03){
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = volume;
    o.connect(g).connect(audioCtx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); }, duration*1000);
  }
  function eatPelletSound(){ beep(1200, 0.03, 'square', 0.025); }
  function eatPowerSound(){ beep(400, 0.2, 'sine', 0.04); }
  function eatGhostSound(){
    const freqs = [800, 1000, 1200, 1400];
    let t=0;
    for (let i=0;i<freqs.length;i++){
      setTimeout(()=>beep(freqs[i], 0.06, 'square', 0.04), t);
      t+=60;
    }
  }

  // BFS pathfinding
  function bfsNextStep(sx, sy, tx, ty, isWalkable){
    if (sx === tx && sy === sy) return null; // same tile
    const q = [];
    const visited = Array.from({length: HEIGHT}, () => Array(WIDTH).fill(false));
    const parent = Array.from({length: HEIGHT}, () => Array(WIDTH).fill(null));

    q.push({x:sx, y:sy});
    visited[sy][sx] = true;

    while(q.length){
      const cur = q.shift();
      if (cur.x === tx && cur.y === ty) break;
      for (let i=0;i<4;i++){
        const nx = cur.x + DIRS[i].x;
        const ny = cur.y + DIRS[i].y;
        if (!isInside(nx,ny)) continue;
        if (visited[ny][nx]) continue;
        if (!isWalkable(nx, ny)) continue;
        visited[ny][nx] = true;
        parent[ny][nx] = cur;
        q.push({x:nx,y:ny});
      }
    }

    // Reconstruct path
    let cx = tx, cy = ty;
    let prev = parent[cy][cx];
    if (!prev) {
      // No path found; choose any valid neighbor that reduces Manhattan distance
      let best = null, bestD = 1e9;
      for (let i=0;i<4;i++){
        const nx = sx + DIRS[i].x, ny = sy + DIRS[i].y;
        if (!isInside(nx,ny)) continue;
        if (!isWalkable(nx, ny)) continue;
        const d = Math.abs(tx-nx)+Math.abs(ty-ny);
        if (d < bestD) { bestD = d; best = i; }
      }
      return best==null? null : best;
    }
    while(prev && !(prev.x === sx && prev.y === sy)){
      cx = prev.x; cy = prev.y;
      prev = parent[cy][cx];
    }
    // Determine direction from start to next
    for (let i=0;i<4;i++){
      if (sx + DIRS[i].x === cx && sy + DIRS[i].y === cy) return i;
    }
    return null;
  }

  function wrapIfTunnel(entity){
    const ty = toTile(entity.y);
    // Only row 14 has tunnels
    if (ty === 14) {
      if (entity.x < -TILE/2) entity.x = CANVAS_W + TILE/2 - 1;
      if (entity.x > CANVAS_W + TILE/2) entity.x = -TILE/2 + 1;
    }
  }

  function atTileCenter(entity){
    const cx = Math.floor(entity.x / TILE);
    const cy = Math.floor(entity.y / TILE);
    const center = tileCenter(cx, cy);
    return (Math.abs(entity.x - center.x) < 0.5 && Math.abs(entity.y - center.y) < 0.5);
  }

  function tryTurn(entity, nextDir){
    if (!nextDir) return false;
    const tx = toTile(entity.x), ty = toTile(entity.y);
    const nx = tx + nextDir.x, ny = ty + nextDir.y;
    // Check walkability for Pac-Man
    if (isWalkableForPacman(nx, ny)) {
      entity.dir = {x:nextDir.x, y:nextDir.y};
      return true;
    }
    return false;
  }

  function updatePacman(dt){
    // Mouth animation
    pacman.mouthTime += dt * pacman.mouthSpeed;

    // Turning at tile centers
    if (atTileCenter(pacman)) {
      const tx = toTile(pacman.x), ty = toTile(pacman.y);
      // Try requested turn first
      if ((pacman.nextDir.x !== pacman.dir.x || pacman.nextDir.y !== pacman.dir.y) &&
          isWalkableForPacman(tx + pacman.nextDir.x, ty + pacman.nextDir.y)) {
        pacman.dir = {x:pacman.nextDir.x, y:pacman.nextDir.y};
      }
      // If current direction blocked, stop
      const nx = tx + pacman.dir.x, ny = ty + pacman.dir.y;
      if (!isWalkableForPacman(nx, ny)) {
        pacman.dir = {x:0,y:0};
      }

      // Eat pellet at tile center
      const p = pellets[ty][tx];
      if (p === 1) {
        pellets[ty][tx] = 0;
        score += 10;
        pelletCount--;
        eatPelletSound();
        updateHUD();
      } else if (p === 2) {
        pellets[ty][tx] = 0;
        score += 50;
        pelletCount--;
        frightenedTimer = Math.max(frightenedTimer, 6.0); // seconds
        eatChain = 0;
        eatPowerSound();
        updateHUD();
      }

      if (pelletCount <= 0) {
        // Level complete
        resetLevel(true);
      }
    }

    // Move
    pacman.x += pacman.dir.x * pacman.speed * dt;
    pacman.y += pacman.dir.y * pacman.speed * dt;

    wrapIfTunnel(pacman);
  }

  function ghostTargetTile(ghost){
    const ptx = toTile(pacman.x), pty = toTile(pacman.y);

    if (ghost.state === "eyes") {
      // Return to inside house center
      return {x: Math.floor(WIDTH/2), y: GH.y+1};
    }

    if (frightenedTimer > 0) {
      // No specific target while frightened; BFS will pick any valid neighbor
      return {x: ptx, y: pty};
    }

    const mode = PHASES[phaseIndex].mode;
    if (mode === "scatter") {
      return ghost.scatterTarget;
    }

    // Chase modes with individual targets
    switch(ghost.name){
      case "blinky":
        return {x: ptx, y: pty};
      case "pinky": {
        const ahead = {x: ptx + 4*sign(pacman.dir.x), y: pty + 4*sign(pacman.dir.y)};
        return {x: clamp(ahead.x, 1, WIDTH-2), y: clamp(ahead.y, 1, HEIGHT-2)};
      }
      case "inky": {
        // Inky uses a two-step vector from Blinky to a point ahead of Pac-Man
        const blinky = ghosts.find(g=>g.name==="blinky");
        const btx = toTile(blinky.x), bty = toTile(blinky.y);
        const ahead = {x: ptx + 2*sign(pacman.dir.x), y: pty + 2*sign(pacman.dir.y)};
        const vx = ahead.x - btx;
        const vy = ahead.y - bty;
        return {x: clamp(ahead.x + vx, 1, WIDTH-2), y: clamp(ahead.y + vy, 1, HEIGHT-2)};
      }
      case "clyde": {
        const dx = ptx - toTile(ghost.x);
        const dy = pty - toTile(ghost.y);
        const dist2 = dx*dx + dy*dy;
        if (dist2 >= 64) { // > 8 tiles
          return {x: ptx, y: pty};
        } else {
          return ghost.scatterTarget; // retreat to corner
        }
      }
    }
    return {x: ptx, y: pty};
  }

  function updateGhost(ghost, dt){
    // State transitions
    if (ghost.state === "inHouse") {
      ghost.leaveTimer -= dt;
      if (ghost.leaveTimer <= 0) {
        ghost.inHouse = false;
        ghost.state = "leaving";
      }
    } else if (ghost.state === "eyes" && atTileCenter(ghost)) {
      const tx = toTile(ghost.x), ty = toTile(ghost.y);
      if (tx === Math.floor(WIDTH/2) && ty === GH.y+1) {
        // Re-enter house
        ghost.inHouse = true;
        ghost.state = "inHouse";
        ghost.leaveTimer = 3 + Math.random()*2;
        ghost.speed = 75;
      }
    }

    if (frightenedTimer > 0 && ghost.state !== "eyes") {
      ghost.state = "frightened";
      ghost.speed = 60;
    } else if (ghost.state === "frightened" && frightenedTimer <= 0) {
      // Return to normal
      ghost.state = ghost.inHouse ? "inHouse" : PHASES[phaseIndex].mode;
      ghost.speed = 75;
    }

    // Movement at tile centers: decide direction
    if (atTileCenter(ghost)) {
      const tx = toTile(ghost.x), ty = toTile(ghost.y);

      let target = ghostTargetTile(ghost);
      // Determine walkable function for this ghost
      const isWalk = (x,y)=>isWalkableForGhost(x,y,ghost);

      // If frightened: choose random valid direction that is not reverse if possible
      let chosenDir = null;
      if (ghost.state === "frightened") {
        const options = [];
        for (let i=0;i<4;i++){
          const nx = tx + DIRS[i].x, ny = ty + DIRS[i].y;
          if (!isInside(nx,ny)) continue;
          if (!isWalk(nx, ny)) continue;
          // avoid immediate reverse
          const rev = (i+2)%4;
          if (ghost.dirIndex !== null && i === ((ghost.dirIndex+2)%4) && Math.random() < 0.7) continue;
          options.push(i);
        }
        chosenDir = options.length ? options[Math.floor(Math.random()*options.length)] : null;
      } else {
        // Use BFS to find next step
        const next = bfsNextStep(tx, ty, target.x, target.y, isWalk);
        chosenDir = next;
      }

      if (chosenDir == null) {
        // fallback: pick any valid direction not reverse
        let options = [];
        for (let i=0;i<4;i++){
          const nx = tx + DIRS[i].x, ny = ty + DIRS[i].y;
          if (!isInside(nx,ny)) continue;
          if (!isWalk(nx, ny)) continue;
          const rev = (i+2)%4;
          if (ghost.dirIndex !== null && i === ((ghost.dirIndex+2)%4) && Math.random() < 0.7) continue;
          options.push(i);
        }
        chosenDir = options.length ? options[Math.floor(Math.random()*options.length)] : ghost.dirIndex ?? 3;
      }

      ghost.dirIndex = chosenDir;

      // If leaving house, ensure they move upward through the gate
      if (ghost.state === "leaving") {
        // Force direction up if possible
        const upX = tx, upY = ty-1;
        if (isWalk(upX, upY)) ghost.dirIndex = DIR_INDEX.up;
        else ghost.state = PHASES[phaseIndex].mode; // left house area
      }
    }

    // Move
    ghost.x += DIRS[ghost.dirIndex].x * ghost.speed * dt;
    ghost.y += DIRS[ghost.dirIndex].y * ghost.speed * dt;

    wrapIfTunnel(ghost);
  }

  function checkCollisions(){
    const pr = TILE*0.4;
    for (const g of ghosts) {
      const dx = pacman.x - g.x, dy = pacman.y - g.y;
      const dist2 = dx*dx + dy*dy;
      if (dist2 < (pr+TILE*0.4)*(pr+TILE*0.4)) {
        if (g.state === "frightened") {
          // Eat ghost
          eatChain++;
          const points = 200 * Math.pow(2, Math.min(eatChain-1,3));
          score += points;
          g.state = "eyes";
          g.speed = 120;
          eatGhostSound();
          updateHUD();
        } else if (g.state !== "eyes") {
          // Pac-Man dies
          lives--;
          updateHUD();
          if (lives <= 0) {
            gameOver = true;
            readyMessageTimer = 9999;
          } else {
            resetEntitiesPositions();
            readyMessageTimer = 2.0;
          }
          return;
        }
      }
    }
  }

  function update(dt){
    if (paused || gameOver) return;

    globalTime += dt;

    // READY! timer
    if (readyMessageTimer > 0) {
      readyMessageTimer -= dt;
      return; // freeze movement during READY!
    }

    // Update scatter/chase phases
    phaseTimer -= dt;
    if (phaseTimer <= 0) {
      phaseIndex = (phaseIndex + 1) % PHASES.length;
      phaseTimer = PHASES[phaseIndex].duration;
    }

    // Frightened timer
    if (frightenedTimer > 0) {
      frightenedTimer -= dt;
      if (frightenedTimer <= 0) {
        eatChain = 0; // reset chain when frightened ends
      }
    }

    updatePacman(dt);
    for (const g of ghosts) updateGhost(g, dt);
    checkCollisions();
  }

  function drawMaze(){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,CANVAS_W,CANVAS_H);

    // Draw walls
    ctx.fillStyle = COLORS.wall;
    for (let y=0;y<HEIGHT;y++){
      for (let x=0;x<WIDTH;x++){
        const t = grid[y][x];
        if (t === 'X') {
          ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        }
      }
    }

    // Gate
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(GH.gateX*TILE, GH.gateY*TILE + TILE*0.4, TILE, TILE*0.2);

    // Pellets
    for (let y=0;y<HEIGHT;y++){
      for (let x=0;x<WIDTH;x++){
        const p = pellets[y][x];
        if (p === 1) {
          ctx.fillStyle = COLORS.pellet;
          ctx.beginPath();
          ctx.arc(x*TILE+TILE/2, y*TILE+TILE/2, TILE*0.12, 0, Math.PI*2);
          ctx.fill();
        } else if (p === 2) {
          // Power pellet - pulse
          const r = TILE*0.25 + Math.sin(globalTime*6)*TILE*0.05;
          ctx.fillStyle = COLORS.power;
          ctx.beginPath();
          ctx.arc(x*TILE+TILE/2, y*TILE+TILE/2, r, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }
  }

  function drawPacman(){
    const angle = (Math.sin(pacman.mouthTime)*0.25 + 0.35) * Math.PI; // mouth opening
    let rot = 0;
    if (pacman.dir.x === 1) rot = 0;
    else if (pacman.dir.y === -1) rot = -Math.PI/2;
    else if (pacman.dir.y === 1) rot = Math.PI/2;
    else if (pacman.dir.x === -1) rot = Math.PI;

    ctx.fillStyle = COLORS.pacman;
    ctx.beginPath();
    ctx.moveTo(pacman.x, pacman.y);
    ctx.arc(pacman.x, pacman.y, TILE*0.45, rot + angle, rot - angle, false);
    ctx.closePath();
    ctx.fill();
  }

  function drawGhost(ghost){
    const tx = toTile(ghost.x), ty = toTile(ghost.y);
    const cx = ghost.x, cy = ghost.y;
    let bodyColor = ghost.color;

    if (ghost.state === "frightened") {
      // Flicker near end
      if (frightenedTimer < 2 && Math.floor(globalTime*10)%2===0) {
        bodyColor = "#ffffff";
      } else {
        bodyColor = COLORS.frightened;
      }
    }

    const w = TILE*0.9, h = TILE*0.9;
    const left = cx - w/2, top = cy - h/2;

    // Body
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(cx, cy + h*0.1, w*0.5, Math.PI, 0); // head
    ctx.rect(left, cy, w, h*0.4); // body rectangle
    // feet
    const footW = w/4;
    for (let i=0;i<4;i++){
      const fx = left + i*footW;
      ctx.beginPath();
      ctx.arc(fx+footW/2, cy+h*0.45, footW*0.5, 0, Math.PI);
      ctx.fill();
    }
    ctx.fill();

    // Eyes
    if (ghost.state !== "frightened") {
      const ex = DIRS[ghost.dirIndex].x * TILE*0.08;
      const ey = DIRS[ghost.dirIndex].y * TILE*0.08;
      drawEye(cx - w*0.2, cy - h*0.05, ex, ey);
      drawEye(cx + w*0.1,  cy - h*0.05, ex, ey);
    } else {
      // frightened eyes
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(cx - w*0.2, cy - h*0.05, TILE*0.12, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(cx + w*0.1,  cy - h*0.05, TILE*0.12, 0, Math.PI*2); ctx.fill();
    }

    // If eyes state, draw return markers
    if (ghost.state === "eyes") {
      ctx.strokeStyle = "#00f";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(cx - TILE*0.25, cy + TILE*0.15); ctx.lineTo(cx - TILE*0.05, cy + TILE*0.15); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx + TILE*0.05, cy + TILE*0.15); ctx.lineTo(cx + TILE*0.25, cy + TILE*0.15); ctx.stroke();
    }

    function drawEye(x,y,dx,dy){
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(x, y, TILE*0.14, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "#00f";
      ctx.beginPath(); ctx.arc(x+dx, y+dy, TILE*0.07, 0, Math.PI*2); ctx.fill();
    }
  }

  function drawOverlay(){
    if (readyMessageTimer > 0 && !gameOver) {
      ctx.fillStyle = COLORS.text;
      ctx.font = "bold 24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("READY!", CANVAS_W/2, CANVAS_H*0.55);
    }
    if (gameOver) {
      ctx.fillStyle = "#ff4040";
      ctx.font = "bold 28px Arial";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", CANVAS_W/2, CANVAS_H*0.55);
      ctx.fillStyle = COLORS.text;
      ctx.font = "16px Arial";
      ctx.fillText("Press R to Restart", CANVAS_W/2, CANVAS_H*0.60);
    }
  }

  function draw(){
    drawMaze();
    // Draw entities
    for (const g of ghosts) drawGhost(g);
    drawPacman();
    drawOverlay();
  }

  function updateHUD(){
    document.getElementById('score').textContent = score;
    document.getElementById('lives').textContent = lives;
    document.getElementById('level').textContent = level;
  }

  function loop(ts){
    if (!lastTime) lastTime = ts;
    const dt = Math.min(0.033, (ts - lastTime)/1000);
    lastTime = ts;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // Init
  function init(){
    canvas = document.getElementById('game');
    ctx = canvas.getContext('2d');

    grid = buildMaze();
    placePellets();
    resetEntitiesPositions();
    updateHUD();

    // Start audio on first interaction
    window.addEventListener('pointerdown', ensureAudio, {once:true});
    window.addEventListener('keydown', ensureAudio, {once:true});

    requestAnimationFrame(loop);
  }

  init();
})();
</script>
</body>
</html>