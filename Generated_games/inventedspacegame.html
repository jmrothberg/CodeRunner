<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Space Combat Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            cursor: crosshair;
        }
        
        #gameCanvas {
            display: block;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .hud-element {
            position: absolute;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            font-size: 14px;
        }
        
        #healthBar {
            top: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            border: 2px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00aa00);
            transition: width 0.3s ease;
        }
        
        #shieldBar {
            top: 50px;
            left: 20px;
            width: 200px;
            height: 20px;
            border: 2px solid #00aaff;
            background: rgba(0, 170, 255, 0.1);
        }
        
        #shieldFill {
            height: 100%;
            background: linear-gradient(90deg, #00aaff, #0066aa);
            transition: width 0.3s ease;
        }
        
        #score {
            top: 20px;
            right: 20px;
            font-size: 24px;
        }
        
        #wave {
            top: 50px;
            right: 20px;
            font-size: 18px;
        }
        
        #ammo {
            bottom: 20px;
            left: 20px;
            font-size: 16px;
        }
        
        #radar {
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            border: 2px solid #00ff00;
            background: radial-gradient(circle, rgba(0,255,0,0.1), rgba(0,255,0,0.02));
            border-radius: 50%;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff0000;
            font-size: 48px;
            text-shadow: 0 0 20px #ff0000;
            display: none;
        }
        
        #restart {
            margin-top: 20px;
            padding: 10px 30px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff0000;
            color: #ff0000;
            font-size: 20px;
            cursor: pointer;
            pointer-events: all;
        }
        
        #restart:hover {
            background: rgba(255, 0, 0, 0.4);
        }
        
        #powerUpIndicator {
            bottom: 60px;
            left: 20px;
            font-size: 16px;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="hud">
        <div class="hud-element" id="healthBar">
            <div id="healthFill" style="width: 100%"></div>
        </div>
        <div class="hud-element" id="shieldBar">
            <div id="shieldFill" style="width: 100%"></div>
        </div>
        <div class="hud-element" id="score">SCORE: 0</div>
        <div class="hud-element" id="wave">WAVE: 1</div>
        <div class="hud-element" id="ammo">AMMO: âˆž</div>
        <div class="hud-element" id="radar"></div>
        <div class="hud-element" id="powerUpIndicator"></div>
    </div>
    
    <div id="gameOver">
        <div>GAME OVER</div>
        <div style="font-size: 24px; margin-top: 10px;">Final Score: <span id="finalScore">0</span></div>
        <button id="restart">RESTART</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Game Configuration
        const config = {
            playerSpeed: 0.5,
            enemySpeed: 0.2,
            laserSpeed: 2,
            maxEnemies: 10,
            enemySpawnRate: 2000,
            powerUpDuration: 5000,
            shieldRegenRate: 0.1
        };

        // Game State
        let gameState = {
            score: 0,
            wave: 1,
            health: 100,
            shield: 100,
            isGameOver: false,
            rapidFireActive: false,
            shieldBoostActive: false,
            lastShot: 0,
            shotCooldown: 200
        };

        // Input State
        const keys = {};
        const mouse = { x: 0, y: 0 };
        
        // Three.js Setup
        let scene, camera, renderer;
        let playerShip, enemies = [], lasers = [], asteroids = [], powerUps = [];
        let starField, nebulaClouds;
        let enemySpawnTimer = 0;
        let clock = new THREE.Clock();

        // Sound System (using Web Audio API for generated sounds)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playLaserSound() {
            playSound(800, 0.1, 'sawtooth', 0.05);
        }

        function playExplosionSound() {
            playSound(100, 0.3, 'square', 0.1);
            setTimeout(() => playSound(50, 0.2, 'triangle', 0.08), 100);
        }

        function playHitSound() {
            playSound(200, 0.15, 'sine', 0.06);
        }

        function playPowerUpSound() {
            playSound(600, 0.1, 'sine', 0.05);
            setTimeout(() => playSound(800, 0.1, 'sine', 0.05), 100);
            setTimeout(() => playSound(1000, 0.1, 'sine', 0.05), 200);
        }

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000033, 0.001);

            // Camera Setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'),
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create Starfield
            createStarField();

            // Create Nebula Clouds
            createNebulaClouds();

            // Create Player Ship
            createPlayerShip();

            // Create Asteroid Field
            createAsteroidField();

            // Input Handlers
            setupInputHandlers();

            // Start Game Loop
            animate();
        }

        function createStarField() {
            const starsGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            
            for (let i = 0; i < 5000; i++) {
                starPositions.push(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }

        function createNebulaClouds() {
            const cloudGeometry = new THREE.SphereGeometry(50, 32, 32);
            const cloudMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                transparent: true,
                opacity: 0.02,
                side: THREE.DoubleSide
            });
            
            for (let i = 0; i < 3; i++) {
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.set(
                    Math.random() * 100 - 50,
                    Math.random() * 20 - 10,
                    Math.random() * 100 - 50
                );
                scene.add(cloud);
            }
        }

        function createPlayerShip() {
            const shipGroup = new THREE.Group();
            
            // Main Body
            const bodyGeometry = new THREE.ConeGeometry(0.5, 2, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0066ff,
                emissive: 0x002244,
                shininess: 100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            shipGroup.add(body);
            
            // Wings
            const wingGeometry = new THREE.BoxGeometry(3, 0.1, 1);
            const wingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0044aa,
                emissive: 0x001122
            });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.z = -0.5;
            shipGroup.add(wings);
            
            // Engine Glow
            const engineGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const engineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const engineGlow = new THREE.Mesh(engineGeometry, engineMaterial);
            engineGlow.position.z = -1;
            shipGroup.add(engineGlow);
            
            // Shield Bubble
            const shieldGeometry = new THREE.SphereGeometry(2, 16, 16);
            const shieldMaterial = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const shieldBubble = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shipGroup.add(shieldBubble);
            
            playerShip = {
                group: shipGroup,
                body: body,
                shield: shieldBubble,
                velocity: new THREE.Vector3(0, 0, 0)
            };
            
            scene.add(shipGroup);
        }

        function createEnemyShip() {
            const enemyGroup = new THREE.Group();
            
            // Main Body
            const bodyGeometry = new THREE.OctahedronGeometry(0.8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                emissive: 0x440000
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            enemyGroup.add(body);
            
            // Engine Glow
            const engineGeometry = new THREE.SphereGeometry(0.2, 6, 6);
            const engineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff6600,
                transparent: true,
                opacity: 0.8
            });
            const engineGlow = new THREE.Mesh(engineGeometry, engineMaterial);
            engineGlow.position.z = 1;
            enemyGroup.add(engineGlow);
            
            // Random spawn position
            enemyGroup.position.set(
                (Math.random() - 0.5) * 30,
                (Math.random() - 0.5) * 10,
                -20 - Math.random() * 10
            );
            
            const enemy = {
                group: enemyGroup,
                body: body,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * config.enemySpeed,
                    (Math.random() - 0.5) * config.enemySpeed * 0.5,
                    config.enemySpeed
                ),
                health: 30,
                shootTimer: Math.random() * 2000
            };
            
            enemies.push(enemy);
            scene.add(enemyGroup);
        }

        function createAsteroidField() {
            for (let i = 0; i < 20; i++) {
                const size = Math.random() * 2 + 0.5;
                const geometry = new THREE.DodecahedronGeometry(size, 0);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x444444,
                    emissive: 0x111111
                });
                
                const asteroid = new THREE.Mesh(geometry, material);
                asteroid.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 20,
                    Math.random() * 40 - 10
                );
                
                asteroid.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                asteroid.userData = {
                    rotationSpeed: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.01,
                        (Math.random() - 0.5) * 0.01,
                        (Math.random() - 0.5) * 0.01
                    )
                };
                
                asteroids.push(asteroid);
                scene.add(asteroid);
            }
        }

        function createLaser(position, direction, isPlayer = true) {
            const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2);
            const laserMaterial = new THREE.MeshBasicMaterial({ 
                color: isPlayer ? 0x00ff00 : 0xff0000,
                emissive: isPlayer ? 0x00ff00 : 0xff0000
            });
            
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            laser.position.copy(position);
            laser.lookAt(direction);
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: isPlayer ? 0x00ff00 : 0xff0000,
                transparent: true,
                opacity: 0.5
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            laser.add(glow);
            
            lasers.push({
                mesh: laser,
                velocity: direction.clone().normalize().multiplyScalar(config.laserSpeed),
                isPlayer: isPlayer
            });
            
            scene.add(laser);
            
            if (isPlayer) {
                playLaserSound();
            }
        }

        function createPowerUp(position) {
            const powerUpGroup = new THREE.Group();
            
            // Outer ring
            const ringGeometry = new THREE.TorusGeometry(0.5, 0.1, 8, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                emissive: 0xffff00
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            powerUpGroup.add(ring);
            
            // Inner core
            const coreGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                emissive: 0xffffff
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            powerUpGroup.add(core);
            
            powerUpGroup.position.copy(position);
            
            const type = Math.random() > 0.5 ? 'rapidFire' : 'shieldBoost';
            
            powerUps.push({
                group: powerUpGroup,
                type: type,
                rotationSpeed: 0.05
            });
            
            scene.add(powerUpGroup);
        }

        function createExplosion(position) {
            const particleCount = 30;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.1, 1, 0.5),
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 1
                });
                
                scene.add(particle);
            }
            
            playExplosionSound();
            
            // Animate and remove particles
            const animateParticles = () => {
                particles.forEach((particle, index) => {
                    particle.mesh.position.add(particle.velocity);
                    particle.life -= 0.02;
                    particle.mesh.material.opacity = particle.life;
                    
                    if (particle.life <= 0) {
                        scene.remove(particle.mesh);
                        particles.splice(index, 1);
                    }
                });
                
                if (particles.length > 0) {
                    requestAnimationFrame(animateParticles);
                }
            };
            
            animateParticles();
        }

        function setupInputHandlers() {
            // Keyboard
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            // Mouse
            window.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            
            window.addEventListener('click', () => {
                if (!gameState.isGameOver) {
                    shoot();
                }
            });
            
            // Restart button
            document.getElementById('restart').addEventListener('click', restartGame);
        }

        function shoot() {
            const now = Date.now();
            const cooldown = gameState.rapidFireActive ? 100 : gameState.shotCooldown;
            
            if (now - gameState.lastShot > cooldown) {
                const laserPosition = playerShip.group.position.clone();
                laserPosition.z -= 1;
                
                const direction = new THREE.Vector3(mouse.x * 10, mouse.y * 10, -20);
                createLaser(laserPosition, direction, true);
                
                gameState.lastShot = now;
            }
        }

        function updatePlayer(deltaTime) {
            if (gameState.isGameOver) return;
            
            // Movement
            const moveVector = new THREE.Vector3(0, 0, 0);
            
            if (keys['w'] || keys['arrowup']) moveVector.z -= config.playerSpeed;
            if (keys['s'] || keys['arrowdown']) moveVector.z += config.playerSpeed;
            if (keys['a'] || keys['arrowleft']) moveVector.x -= config.playerSpeed;
            if (keys['d'] || keys['arrowright']) moveVector.x += config.playerSpeed;
            
            playerShip.group.position.add(moveVector);
            
            // Constrain position
            playerShip.group.position.x = Math.max(-15, Math.min(15, playerShip.group.position.x));
            playerShip.group.position.y = Math.max(-5, Math.min(5, playerShip.group.position.y));
            playerShip.group.position.z = Math.max(-10, Math.min(10, playerShip.group.position.z));
            
            // Tilt based on movement
            playerShip.group.rotation.z = -moveVector.x * 0.3;
            playerShip.group.rotation.x = moveVector.z * 0.2;
            
            // Shield regeneration
            if (gameState.shield < 100) {
                gameState.shield = Math.min(100, gameState.shield + config.shieldRegenRate);
                updateHUD();
            }
        }

        function updateEnemies(deltaTime) {
            enemies.forEach((enemy, index) => {
                // Move enemy
                enemy.group.position.add(enemy.velocity);
                
                // Rotate towards player
                const direction = new THREE.Vector3()
                    .subVectors(playerShip.group.position, enemy.group.position)
                    .normalize();
                enemy.group.lookAt(playerShip.group.position);
                
                // Enemy shooting
                enemy.shootTimer -= deltaTime * 1000;
                if (enemy.shootTimer <= 0) {
                    const laserPosition = enemy.group.position.clone();
                    laserPosition.z += 1;
                    
                    const targetDirection = playerShip.group.position.clone().sub(laserPosition);
                    createLaser(laserPosition, targetDirection, false);
                    
                    enemy.shootTimer = 2000 + Math.random() * 1000;
                }
                
                // Remove if too far
                if (enemy.group.position.z > 20) {
                    scene.remove(enemy.group);
                    enemies.splice(index, 1);
                }
            });
        }

        function updateLasers(deltaTime) {
            lasers.forEach((laser, index) => {
                laser.mesh.position.add(laser.velocity.clone().multiplyScalar(deltaTime * 60));
                
                // Remove if too far
                if (Math.abs(laser.mesh.position.z) > 50) {
                    scene.remove(laser.mesh);
                    lasers.splice(index, 1);
                }
            });
        }

        function updateAsteroids(deltaTime) {
            asteroids.forEach(asteroid => {
                asteroid.rotation.x += asteroid.userData.rotationSpeed.x;
                asteroid.rotation.y += asteroid.userData.rotationSpeed.y;
                asteroid.rotation.z += asteroid.userData.rotationSpeed.z;
                
                // Slow drift
                asteroid.position.z -= 0.01;
                
                // Wrap around
                if (asteroid.position.z < -20) {
                    asteroid.position.z = 30;
                    asteroid.position.x = (Math.random() - 0.5) * 50;
                    asteroid.position.y = (Math.random() - 0.5) * 20;
                }
            });
        }

        function updatePowerUps(deltaTime) {
            powerUps.forEach((powerUp, index) => {
                powerUp.group.rotation.y += powerUp.rotationSpeed;
                
                // Check collection
                const distance = powerUp.group.position.distanceTo(playerShip.group.position);
                if (distance < 2) {
                    collectPowerUp(powerUp.type);
                    
                    scene.remove(powerUp.group);
                    powerUps.splice(index, 1);
                }
            });
        }

        function collectPowerUp(type) {
            playPowerUpSound();
            
            if (type === 'rapidFire') {
                gameState.rapidFireActive = true;
                document.getElementById('powerUpIndicator').textContent = 'RAPID FIRE ACTIVE';
                
                setTimeout(() => {
                    gameState.rapidFireActive = false;
                    document.getElementById('powerUpIndicator').textContent = '';
                }, config.powerUpDuration);
            } else if (type === 'shieldBoost') {
                gameState.shieldBoostActive = true;
                gameState.shield = 100;
                playerShip.shield.material.opacity = 0.3;
                document.getElementById('powerUpIndicator').textContent = 'SHIELD BOOST ACTIVE';
                
                setTimeout(() => {
                    gameState.shieldBoostActive = false;
                    playerShip.shield.material.opacity = 0.1;
                    document.getElementById('powerUpIndicator').textContent = '';
                }, config.powerUpDuration);
            }
            
            updateHUD();
        }

        function checkCollisions() {
            // Player lasers vs enemies
            lasers.forEach((laser, laserIndex) => {
                if (laser.isPlayer) {
                    enemies.forEach((enemy, enemyIndex) => {
                        const distance = laser.mesh.position.distanceTo(enemy.group.position);
                        if (distance < 1) {
                            enemy.health -= 10;
                            
                            scene.remove(laser.mesh);
                            lasers.splice(laserIndex, 1);
                            
                            if (enemy.health <= 0) {
                                createExplosion(enemy.group.position);
                                scene.remove(enemy.group);
                                enemies.splice(enemyIndex, 1);
                                
                                gameState.score += 100;
                                updateHUD();
                                
                                // Chance to spawn power-up
                                if (Math.random() < 0.2) {
                                    createPowerUp(enemy.group.position);
                                }
                            } else {
                                playHitSound();
                            }
                        }
                    });
                }
            });
            
            // Enemy lasers vs player
            lasers.forEach((laser, laserIndex) => {
                if (!laser.isPlayer) {
                    const distance = laser.mesh.position.distanceTo(playerShip.group.position);
                    if (distance < 1.5) {
                        scene.remove(laser.mesh);
                        lasers.splice(laserIndex, 1);
                        
                        takeDamage(10);
                    }
                }
            });
            
            // Enemy vs player collision
            enemies.forEach((enemy, enemyIndex) => {
                const distance = enemy.group.position.distanceTo(playerShip.group.position);
                if (distance < 2) {
                    createExplosion(enemy.group.position);
                    scene.remove(enemy.group);
                    enemies.splice(enemyIndex, 1);
                    
                    takeDamage(20);
                }
            });
        }

        function takeDamage(amount) {
            playHitSound();
            
            if (gameState.shield > 0) {
                gameState.shield = Math.max(0, gameState.shield - amount);
            } else {
                gameState.health = Math.max(0, gameState.health - amount);
            }
            
            updateHUD();
            
            // Flash effect
            playerShip.body.material.emissive.setHex(0xff0000);
            setTimeout(() => {
                playerShip.body.material.emissive.setHex(0x002244);
            }, 100);
            
            if (gameState.health <= 0) {
                gameOver();
            }
        }

        function spawnEnemies(deltaTime) {
            enemySpawnTimer += deltaTime * 1000;
            
            const spawnRate = Math.max(500, config.enemySpawnRate - gameState.wave * 100);
            
            if (enemySpawnTimer > spawnRate && enemies.length < config.maxEnemies + gameState.wave * 2) {
                createEnemyShip();
                enemySpawnTimer = 0;
                
                // Wave progression
                if (gameState.score > gameState.wave * 500) {
                    gameState.wave++;
                    updateHUD();
                }
            }
        }

        function updateHUD() {
            document.getElementById('healthFill').style.width = gameState.health + '%';
            document.getElementById('shieldFill').style.width = gameState.shield + '%';
            document.getElementById('score').textContent = 'SCORE: ' + gameState.score;
            document.getElementById('wave').textContent = 'WAVE: ' + gameState.wave;
            
            // Update radar
            updateRadar();
        }

        function updateRadar() {
            const radarElement = document.getElementById('radar');
            radarElement.innerHTML = '';
            
            // Player position (center)
            const playerDot = document.createElement('div');
            playerDot.style.position = 'absolute';
            playerDot.style.width = '4px';
            playerDot.style.height = '4px';
            playerDot.style.background = '#00ff00';
            playerDot.style.left = '73px';
            playerDot.style.top = '73px';
            radarElement.appendChild(playerDot);
            
            // Enemy positions
            enemies.forEach(enemy => {
                const relativePos = enemy.group.position.clone().sub(playerShip.group.position);
                const radarX = 75 + (relativePos.x / 30) * 70;
                const radarY = 75 - (relativePos.z / 30) * 70;
                
                if (Math.abs(radarX - 75) < 70 && Math.abs(radarY - 75) < 70) {
                    const enemyDot = document.createElement('div');
                    enemyDot.style.position = 'absolute';
                    enemyDot.style.width = '3px';
                    enemyDot.style.height = '3px';
                    enemyDot.style.background = '#ff0000';
                    enemyDot.style.left = radarX + 'px';
                    enemyDot.style.top = radarY + 'px';
                    radarElement.appendChild(enemyDot);
                }
            });
        }

        function gameOver() {
            gameState.isGameOver = true;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
            
            createExplosion(playerShip.group.position);
            scene.remove(playerShip.group);
        }

        function restartGame() {
            // Reset game state
            gameState = {
                score: 0,
                wave: 1,
                health: 100,
                shield: 100,
                isGameOver: false,
                rapidFireActive: false,
                shieldBoostActive: false,
                lastShot: 0,
                shotCooldown: 200
            };
            
            // Clear arrays
            enemies.forEach(enemy => scene.remove(enemy.group));
            enemies = [];
            
            lasers.forEach(laser => scene.remove(laser.mesh));
            lasers = [];
            
            powerUps.forEach(powerUp => scene.remove(powerUp.group));
            powerUps = [];
            
            // Recreate player ship
            createPlayerShip();
            
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            // Update HUD
            updateHUD();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            
            if (!gameState.isGameOver) {
                // Update game objects
                updatePlayer(deltaTime);
                updateEnemies(deltaTime);
                updateLasers(deltaTime);
                updateAsteroids(deltaTime);
                updatePowerUps(deltaTime);
                
                // Spawn enemies
                spawnEnemies(deltaTime);
                
                // Check collisions
                checkCollisions();
            }
            
            // Animate starfield
            starField.rotation.y += 0.0001;
            
            // Camera follow player
            camera.position.x = playerShip.group.position.x * 0.3;
            camera.position.y = playerShip.group.position.y + 5;
            camera.position.z = playerShip.group.position.z + 10;
            camera.lookAt(playerShip.group.position);
            
            // Render
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize game
        init();
    </script>
</body>
</html>