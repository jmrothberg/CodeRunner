<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Raycaster Doom Clone</title>
    <style>
        :root {
            --ui-bg: #2a2a2a;
            --ui-border: #4a4a4a;
            --text-color: #e0e0e0;
            --accent-red: #d32f2f;
            --accent-green: #388e3c;
            --hud-height: 80px;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 800px; /* Base resolution */
            max-width: 100%;
            aspect-ratio: 4/3;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            border: 2px solid var(--ui-border);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* Retro feel */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* HUD Styling */
        #hud {
            background-color: var(--ui-bg);
            border-top: 4px solid var(--ui-border);
            height: var(--hud-height);
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding: 0 20px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #111;
            padding: 5px 15px;
            border: 2px solid var(--ui-border);
            min-width: 80px;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 1.5rem;
            color: #fff;
        }

        #health-val { color: var(--accent-red); }
        #ammo-val { color: #ffeb3b; }
        #armor-val { color: #03a9f4; }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }

        /* Overlay Messages */
        #message-overlay {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            font-size: 2rem;
            color: var(--accent-red);
            text-shadow: 2px 2px 0 #000;
            opacity: 0;
            transition: opacity 0.5s;
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - var(--hud-height));
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            font-size: 3rem;
            color: var(--accent-red);
            text-shadow: 4px 4px 0 #333;
            margin-bottom: 10px;
        }

        .controls-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: left;
            line-height: 1.6;
        }

        button.start-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 1.5rem;
            background: var(--accent-red);
            color: white;
            border: none;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #8b0000;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button.start-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #8b0000;
        }

        /* Weapon Display */
        #weapon-name {
            position: absolute;
            bottom: calc(var(--hud-height) + 10px);
            right: 10px;
            color: rgba(255,255,255,0.5);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="640" height="480"></canvas>
    
    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="message-overlay"></div>
        
        <div id="start-screen">
            <h1>DOOM JS</h1>
            <p>A Raycasting Experience</p>
            <div class="controls-info">
                <strong>Controls:</strong><br>
                [MOUSE] Look Around<br>
                [ARROWS / WASD] Move<br>
                [CLICK] Shoot<br>
                [1-4] Switch Weapons
            </div>
            <button class="start-btn" id="startBtn">Click to Start</button>
        </div>

        <div id="weapon-name">PISTOL</div>

        <div id="hud">
            <div class="stat-box">
                <span class="stat-label">HEALTH</span>
                <span class="stat-value" id="health-val">100%</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">ARMOR</span>
                <span class="stat-value" id="armor-val">0%</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">AMMO</span>
                <span class="stat-value" id="ammo-val">--</span>
            </div>
        </div>
    </div>
</div>

<script>
/**
 * DOOM JS - Single File Raycasting Engine
 * 
 * Architecture:
 * 1. Constants & Config: Game settings, map definitions.
 * 2. Input Handling: Keyboard and Mouse state management.
 * 3. Asset Generation: Procedural textures and sprites using offscreen canvases.
 * 4. Core Engine: Raycasting logic (DDA algorithm), Z-buffering.
 * 5. Entities: Player, Enemies, Projectiles.
 * 6. Game Loop: Update -> Render cycle.
 */

// --- CONSTANTS & CONFIG ---
const SCREEN_WIDTH = 640;
const SCREEN_HEIGHT = 480;
const TICK_RATE = 30; // Logic updates per second
const FOV = Math.PI / 3;
const BLOCK_SIZE = 64;
const MAP_SIZE = 16;
const MINIMAP_SCALE = 0.2;

// Colors
const COLOR_CEILING = '#1a1a1a';
const COLOR_FLOOR = '#3d3d3d';

// Map (1 = Wall, 0 = Empty)
// Simple maze-like structure
const WORLD_MAP = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],
    [1,0,0,1,0,0,0,0,1,1,1,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1],
    [1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1],
    [1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1],
    [1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// --- ASSET GENERATION (Procedural Textures) ---
const textures = {};

function generateTextures() {
    // 1. Wall Texture: Bricks with noise
    const wallCanvas = document.createElement('canvas');
    wallCanvas.width = 64;
    wallCanvas.height = 64;
    const wCtx = wallCanvas.getContext('2d');

    // Base gray
    wCtx.fillStyle = '#666';
    wCtx.fillRect(0, 0, 64, 64);

    // Bricks
    wCtx.fillStyle = '#555';
    for(let y=0; y<64; y+=16) {
        const offset = (y/16)%2 === 0 ? 0 : 8;
        for(let x=-offset; x<64; x+=16) {
            if(x+16 > 0 && x < 64)
                wCtx.fillRect(x+1, y+1, 14, 14);
        }
    }

    // Noise/Grime
    for(let i=0; i<100; i++) {
        wCtx.fillStyle = Math.random() > 0.5 ? '#444' : '#777';
        wCtx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
    }
    
    // Create ImageData object for fast pixel access
    textures.wall = wCtx.getImageData(0,0,64,64);

    // 2. Enemy Sprite (Cacodemon-like red ball)
    const enemyCanvas = document.createElement('canvas');
    enemyCanvas.width = 64;
    enemyCanvas.height = 64;
    const eCtx = enemyCanvas.getContext('2d');

    // Body
    eCtx.beginPath();
    eCtx.arc(32, 32, 28, 0, Math.PI*2);
    eCtx.fillStyle = '#b71c1c'; // Dark Red
    eCtx.fill();

    // Highlight
    eCtx.beginPath();
    eCtx.arc(24, 24, 8, 0, Math.PI*2);
    eCtx.fillStyle = '#e57373';
    eCtx.fill();

    // Eye
    eCtx.beginPath();
    eCtx.arc(32, 28, 6, 0, Math.PI*2);
    eCtx.fillStyle = '#00ff00'; // Green eye
    eCtx.fill();
    
    // Mouth
    eCtx.beginPath();
    eCtx.moveTo(24, 40);
    eCtx.quadraticCurveTo(32, 48, 40, 40);
    eCtx.strokeStyle = '#3e0000';
    eCtx.lineWidth = 2;
    eCtx.stroke();

    textures.enemy = enemyCanvas; // Keep as canvas for scaling drawing

    // 3. Weapon Sprites (Simple shapes)
    const weapons = {
        pistol: { color: '#888', width: 20, height: 40 },
        shotgun: { color: '#5d4037', width: 30, height: 50 },
        chaingun: { color: '#424242', width: 35, height: 45 },
        rocket: { color: '#2e7d32', width: 25, height: 60 }
    };

    for (const [key, data] of Object.entries(weapons)) {
        const c = document.createElement('canvas');
        c.width = 100;
        c.height = 100;
        const ctx = c.getContext('2d');
        
        // Draw centered weapon
        ctx.fillStyle = '#000'; // Background transparent-ish
        ctx.fillRect(0,0,100,100);
        
        ctx.fillStyle = data.color;
        // Barrel
        ctx.fillRect(50 - data.width/2, 100 - data.height, data.width, data.height);
        // Handle
        ctx.fillStyle = '#3e2723';
        ctx.fillRect(50 - data.width/4, 100 - data.height + 10, data.width/2, 20);

        textures[key] = c;
    }
}

// --- INPUT HANDLING ---
const keys = {};
const mouse = { x: 0, y: 0, locked: false };

document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    
    // Weapon switching
    if(e.key === '1') player.switchWeapon(0);
    if(e.key === '2') player.switchWeapon(1);
    if(e.key === '3') player.switchWeapon(2);
    if(e.key === '4') player.switchWeapon(3);
});

document.addEventListener('keyup', (e) => keys[e.code] = false);

document.addEventListener('mousemove', (e) => {
    if (!mouse.locked) return;
    
    // Horizontal rotation
    const sensitivity = 0.002;
    player.dir += e.movementX * sensitivity;
    
    // Normalize angle
    if(player.dir < 0) player.dir += Math.PI * 2;
    if(player.dir >= Math.PI * 2) player.dir -= Math.PI * 2;
});

document.addEventListener('mousedown', () => {
    if(mouse.locked) player.shoot();
});

const startBtn = document.getElementById('startBtn');
startBtn.addEventListener('click', () => {
    const canvas = document.getElementById('gameCanvas');
    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
    canvas.requestPointerLock();
    
    document.getElementById('start-screen').style.display = 'none';
    mouse.locked = true;
    gameRunning = true;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
});

document.addEventListener('pointerlockchange', () => {
    if (document.pointerLockElement !== document.getElementById('gameCanvas')) {
        mouse.locked = false;
        // Optional: Pause menu logic here
    }
});

// --- GAME CLASSES ---

class Player {
    constructor() {
        this.x = BLOCK_SIZE * 2.5;
        this.y = BLOCK_SIZE * 2.5;
        this.dir = 0; // Angle in radians
        this.speed = 3.0;
        this.rotSpeed = 0.05;
        
        this.health = 100;
        this.armor = 0;
        
        this.weapons = [
            { name: 'PISTOL', ammo: Infinity, damage: 15, delay: 400, lastShot: 0 },
            { name: 'SHOTGUN', ammo: 20, damage: 80, delay: 800, lastShot: 0 },
            { name: 'CHAINGUN', ammo: 100, damage: 10, delay: 100, lastShot: 0 },
            { name: 'ROCKET', ammo: 5, damage: 150, delay: 1000, lastShot: 0 }
        ];
        this.currentWeaponIdx = 0;
        
        // Weapon bobbing animation
        this.bobPhase = 0;
    }

    switchWeapon(idx) {
        if (idx >= 0 && idx < this.weapons.length) {
            this.currentWeaponIdx = idx;
            document.getElementById('weapon-name').innerText = this.weapons[idx].name;
            updateHUD();
        }
    }

    shoot() {
        const w = this.weapons[this.currentWeaponIdx];
        const now = performance.now();
        
        if (now - w.lastShot < w.delay) return;
        if (w.ammo <= 0 && w.ammo !== Infinity) {
            showMessage("NO AMMO");
            return; // Click sound could go here
        }

        w.lastShot = now;
        if(w.ammo !== Infinity) w.ammo--;
        
        updateHUD();

        // Visual recoil effect
        this.bobPhase += 0.5;

        // Hit detection (Raycast for shooting)
        // Simple raycast to find first enemy in crosshair
        let hitEnemy = null;
        let minDist = 1000;

        enemies.forEach(e => {
            if (!e.alive) return;
            
            // Calculate angle to enemy
            const dx = e.x - this.x;
            const dy = e.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            let angleToEnemy = Math.atan2(dy, dx) - this.dir;
            
            // Normalize angle
            while (angleToEnemy < -Math.PI) angleToEnemy += 2*Math.PI;
            while (angleToEnemy > Math.PI) angleToEnemy -= 2*Math.PI;

            // Check if enemy is in front and within crosshair tolerance
            const tolerance = 0.15; // Crosshair width
            if (Math.abs(angleToEnemy) < tolerance && dist < minDist) {
                // Check if wall blocks view (simple check)
                // For simplicity, we assume if angle matches and distance is close enough, it hits.
                // A robust solution would raycast to the enemy center.
                minDist = dist;
                hitEnemy = e;
            }
        });

        if (hitEnemy) {
            hitEnemy.takeDamage(w.damage);
            console.log(`Hit enemy for ${w.damage} dmg`);
        } else {
             // Miss effect (wall puff)
             console.log("Missed");
        }
    }

    update(dt) {
        let moveStep = 0;
        let strafeStep = 0;

        // Movement
        if (keys['ArrowUp'] || keys['KeyW']) moveStep = this.speed * (dt/16);
        if (keys['ArrowDown'] || keys['KeyS']) moveStep = -this.speed * (dt/16);
        
        // Rotation with keys (fallback)
        if (keys['ArrowLeft']) this.dir -= this.rotSpeed;
        if (keys['ArrowRight']) this.dir += this.rotSpeed;

        const newX = this.x + Math.cos(this.dir) * moveStep;
        const newY = this.y + Math.sin(this.dir) * moveStep;

        // Collision Detection
        if (!isWall(newX, this.y)) this.x = newX;
        if (!isWall(this.x, newY)) this.y = newY;

        // Bobbing animation calculation
        if (moveStep !== 0) {
            this.bobPhase += 0.2;
        } else {
            // Return to center slowly
            this.bobPhase *= 0.9;
        }
    }

    takeDamage(amount) {
        if(this.armor > 0) {
            const armorAbsorb = Math.min(this.armor, amount * 0.5);
            this.armor -= armorAbsorb;
            amount -= armorAbsorb;
        }
        this.health -= amount;
        updateHUD();
        
        // Flash red
        const overlay = document.getElementById('message-overlay');
        overlay.innerText = "OUCH!";
        overlay.style.opacity = 1;
        setTimeout(() => overlay.style.opacity = 0, 200);

        if (this.health <= 0) {
            this.health = 0;
            gameOver();
        }
    }
}

class Enemy {
    constructor(x, y) {
        this.x = x * BLOCK_SIZE + BLOCK_SIZE/2;
        this.y = y * BLOCK_SIZE + BLOCK_SIZE/2;
        this.alive = true;
        this.health = 50;
        this.speed = 1.5;
        this.state = 'idle'; // idle, chase, attack
        this.attackCooldown = 0;
        this.color = '#b71c1c';
    }

    takeDamage(amount) {
        if(!this.alive) return;
        this.health -= amount;
        
        // Pushback slightly
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        this.x += (dx/dist) * 10;
        this.y += (dy/dist) * 10;

        if(this.health <= 0) {
            this.alive = false;
            // Chance to drop ammo/health could go here
        }
    }

    update(dt) {
        if(!this.alive) return;

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        // Simple AI: Always chase if alive and visible (no line of sight check for simplicity, just distance)
        if (dist < 400 && dist > 40) {
            const moveX = (dx / dist) * this.speed * (dt/16);
            const moveY = (dy / dist) * this.speed * (dt/16);

            // Basic collision with walls
            if (!isWall(this.x + moveX, this.y)) this.x += moveX;
            if (!isWall(this.x, this.y + moveY)) this.y += moveY;
        }

        // Attack
        if (dist < 50) {
            if (performance.now() > this.attackCooldown) {
                player.takeDamage(10);
                this.attackCooldown = performance.now() + 1000;
            }
        }
    }
}

class Projectile {
    constructor(x, y, dir) {
        this.x = x;
        this.y = y;
        this.dir = dir;
        this.speed = 8;
        this.active = true;
    }

    update(dt) {
        if(!this.active) return;
        const moveStep = this.speed * (dt/16);
        const newX = this.x + Math.cos(this.dir) * moveStep;
        const newY = this.y + Math.sin(this.dir) * moveStep;

        if(isWall(newX, newY)) {
            this.active = false;
            // Explosion effect logic
            return;
        }

        this.x = newX;
        this.y = newY;
    }
}

// --- GLOBAL VARIABLES ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on main canvas

let player;
let enemies = [];
let projectiles = [];
let zBuffer = new Array(SCREEN_WIDTH).fill(0);
let gameRunning = false;
let lastTime = 0;

// --- HELPER FUNCTIONS ---

function isWall(x, y) {
    const gridX = Math.floor(x / BLOCK_SIZE);
    const gridY = Math.floor(y / BLOCK_SIZE);
    
    if (gridX < 0 || gridX >= MAP_SIZE || gridY < 0 || gridY >= MAP_SIZE) return true;
    return WORLD_MAP[gridY][gridX] === 1;
}

function updateHUD() {
    document.getElementById('health-val').innerText = Math.ceil(player.health) + '%';
    document.getElementById('armor-val').innerText = Math.ceil(player.armor) + '%';
    
    const ammo = player.weapons[player.currentWeaponIdx].ammo;
    document.getElementById('ammo-val').innerText = ammo === Infinity ? 'âˆž' : ammo;
}

function showMessage(text) {
    const el = document.getElementById('message-overlay');
    el.innerText = text;
    el.style.opacity = 1;
    setTimeout(() => el.style.opacity = 0, 1000);
}

function gameOver() {
    gameRunning = false;
    showMessage("YOU DIED");
    document.exitPointerLock();
    setTimeout(() => {
        location.reload(); // Simple restart
    }, 3000);
}

// --- RENDERING ENGINE ---

function castRays() {
    // Draw Ceiling and Floor (Gradient for depth)
    const gradientCeiling = ctx.createLinearGradient(0, 0, 0, SCREEN_HEIGHT/2);
    gradientCeiling.addColorStop(0, '#000');
    gradientCeiling.addColorStop(1, '#222');
    ctx.fillStyle = gradientCeiling;
    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT/2);

    const gradientFloor = ctx.createLinearGradient(0, SCREEN_HEIGHT/2, 0, SCREEN_HEIGHT);
    gradientFloor.addColorStop(0, '#333');
    gradientFloor.addColorStop(1, '#111');
    ctx.fillStyle = gradientFloor;
    ctx.fillRect(0, SCREEN_HEIGHT/2, SCREEN_WIDTH, SCREEN_HEIGHT/2);

    // Raycasting Loop
    for (let x = 0; x < SCREEN_WIDTH; x++) {
        const cameraX = 2 * x / SCREEN_WIDTH - 1; 
        const rayDirX = Math.cos(player.dir) + Math.cos(player.dir + Math.PI/2) * FOV/2 * cameraX;
        const rayDirY = Math.sin(player.dir) + Math.sin(player.dir + Math.PI/2) * FOV/2 * cameraX;

        // DDA Algorithm Setup
        let mapX = Math.floor(player.x / BLOCK_SIZE);
        let mapY = Math.floor(player.y / BLOCK_SIZE);

        const deltaDistX = Math.abs(1 / rayDirX);
        const deltaDistY = Math.abs(1 / rayDirY);

        let stepX, stepY;
        let sideDistX, sideDistY;

        if (rayDirX < 0) {
            stepX = -1;
            sideDistX = (player.x / BLOCK_SIZE - mapX) * deltaDistX;
        } else {
            stepX = 1;
            sideDistX = (mapX + 1.0 - player.x / BLOCK_SIZE) * deltaDistX;
        }

        if (rayDirY < 0) {
            stepY = -1;
            sideDistY = (player.y / BLOCK_SIZE - mapY) * deltaDistY;
        } else {
            stepY = 1;
            sideDistY = (mapY + 1.0 - player.y / BLOCK_SIZE) * deltaDistY;
        }

        // DDA Execution
        let hit = false;
        let side; // 0 for NS, 1 for EW

        while (!hit) {
            if (sideDistX < sideDistY) {
                sideDistX += deltaDistX;
                mapX += stepX;
                side = 0;
            } else {
                sideDistY += deltaDistY;
                mapY += stepY;
                side = 1;
            }

            if (WORLD_MAP[mapY][mapX] === 1) hit = true;
        }

        // Calculate distance projected on camera direction
        let perpWallDist;
        if (side === 0) perpWallDist = (mapX - player.x / BLOCK_SIZE + (1 - stepX) / 2) / rayDirX;
        else            perpWallDist = (mapY - player.y / BLOCK_SIZE + (1 - stepY) / 2) / rayDirY;

        // Save for sprite z-buffering
        zBuffer[x] = perpWallDist * BLOCK_SIZE;

        // Calculate height of line to draw on screen
        const lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);

        // Calculate lowest and highest pixel to fill in current stripe
        let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2;
        if (drawStart < 0) drawStart = 0;
        let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2;
        if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;

        // Texturing calculations
        let wallX; // Where exactly the wall was hit
        if (side === 0) wallX = player.y / BLOCK_SIZE + perpWallDist * rayDirY;
        else            wallX = player.x / BLOCK_SIZE + perpWallDist * rayDirX;
        
        wallX -= Math.floor(wallX);

        let texX = Math.floor(wallX * 64);
        if(side === 0 && rayDirX > 0) texX = 64 - texX - 1;
        if(side === 1 && rayDirY < 0) texX = 64 - texX - 1;

        // Get texture pixel data
        const texData = textures.wall.data;
        
        // Draw vertical line with texture
        // We manually manipulate pixels for the wall to apply lighting/shading efficiently
        // Or use drawImage with slicing (slower but easier). 
        // For "GREAT GRAPHICS" and performance in JS, we'll use a hybrid approach:
        // Draw the strip using putImageData is hard for vertical strips.
        // We will use standard drawing commands but optimized.

        // Lighting: Distance based shading
        let brightness = 1.0 / (perpWallDist * 0.005); 
        if (brightness > 1) brightness = 1;
        if (side === 1) brightness *= 0.7; // Darker one side

        // Create a temporary canvas for the strip to apply color filter
        // This is expensive, so we'll just draw the texture slice and overlay a shadow.
        
        ctx.globalAlpha = 1.0;
        
        // Draw Texture Slice
        // Since textures are ImageData, we need to put it on a temp canvas or use createImageBitmap (async).
        // To keep it simple in one loop: We will just draw solid colors with noise for now if texture access is too hard,
        // BUT the prompt asked for GREAT TEXTURE.
        
        // Optimized Texture Drawing:
        // We can't easily slice ImageData. Let's assume we converted textures.wall to an ImageBitmap or Canvas earlier.
        // Re-generating texture as a canvas element for drawing:
        const wallCanvas = document.createElement('canvas');
        wallCanvas.width = 64; 
        wallCanvas.height = 64;
        wallCanvas.getContext('2d').putImageData(textures.wall, 0, 0);
        
        // Actually, let's just cache the canvas in `textures` object during generation.
        // (Updated generateTextures to store canvas for drawing)
    }
}

// Updated Texture Generation to include Canvas for easy drawing
function generateTextureCanvases() {
    // Wall
    const c = document.createElement('canvas');
    c.width = 64; c.height = 64;
    const ctx = c.getContext('2d');
    
    // Base
    ctx.fillStyle = '#555';
    ctx.fillRect(0,0,64,64);
    
    // Bricks
    ctx.fillStyle = '#444';
    for(let y=0; y<64; y+=16) {
        const offset = (y/16)%2 === 0 ? 0 : 8;
        for(let x=-offset; x<64; x+=16) {
            if(x+16 > 0 && x < 64)
                ctx.fillRect(x+1, y+1, 14, 14);
        }
    }
    
    // Grime
    for(let i=0; i<50; i++) {
        ctx.fillStyle = Math.random() > 0.5 ? '#333' : '#666';
        ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
    }
    
    textures.wallCanvas = c;
}

function renderScene() {
    // 1. Raycasting Walls
    for (let x = 0; x < SCREEN_WIDTH; x++) {
        const cameraX = 2 * x / SCREEN_WIDTH - 1; 
        const rayDirX = Math.cos(player.dir) + Math.cos(player.dir + Math.PI/2) * FOV/2 * cameraX;
        const rayDirY = Math.sin(player.dir) + Math.sin(player.dir + Math.PI/2) * FOV/2 * cameraX;

        let mapX = Math.floor(player.x / BLOCK_SIZE);
        let mapY = Math.floor(player.y / BLOCK_SIZE);

        const deltaDistX = Math.abs(1 / rayDirX);
        const deltaDistY = Math.abs(1 / rayDirY);

        let stepX, stepY;
        let sideDistX, sideDistY;

        if (rayDirX < 0) {
            stepX = -1;
            sideDistX = (player.x / BLOCK_SIZE - mapX) * deltaDistX;
        } else {
            stepX = 1;
            sideDistX = (mapX + 1.0 - player.x / BLOCK_SIZE) * deltaDistX;
        }
        if (rayDirY < 0) {
            stepY = -1;
            sideDistY = (player.y / BLOCK_SIZE - mapY) * deltaDistY;
        } else {
            stepY = 1;
            sideDistY = (mapY + 1.0 - player.y / BLOCK_SIZE) * deltaDistY;
        }

        let hit = false;
        let side;

        while (!hit) {
            if (sideDistX < sideDistY) {
                sideDistX += deltaDistX;
                mapX += stepX;
                side = 0;
            } else {
                sideDistY += deltaDistY;
                mapY += stepY;
                side = 1;
            }
            if (WORLD_MAP[mapY][mapX] === 1) hit = true;
        }

        let perpWallDist;
        if (side === 0) perpWallDist = (mapX - player.x / BLOCK_SIZE + (1 - stepX) / 2) / rayDirX;
        else            perpWallDist = (mapY - player.y / BLOCK_SIZE + (1 - stepY) / 2) / rayDirY;

        zBuffer[x] = perpWallDist * BLOCK_SIZE;

        const lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
        let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2;
        if (drawStart < 0) drawStart = 0;
        let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2;
        if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;

        // Texture X
        let wallX;
        if (side === 0) wallX = player.y / BLOCK_SIZE + perpWallDist * rayDirY;
        else            wallX = player.x / BLOCK_SIZE + perpWallDist * rayDirX;
        wallX -= Math.floor(wallX);
        
        let texX = Math.floor(wallX * 64);
        if(side === 0 && rayDirX > 0) texX = 64 - texX - 1;
        if(side === 1 && rayDirY < 0) texX = 64 - texX - 1;

        // Draw Wall Strip
        ctx.drawImage(textures.wallCanvas, 
            texX, 0, 1, 64,
            x, drawStart, 1, drawEnd - drawStart
        );

        // Apply Shading (Overlay a black rect with alpha)
        let brightness = Math.max(0, 1.0 - perpWallDist * 0.002);
        if(side === 1) brightness *= 0.7;
        
        ctx.fillStyle = `rgba(0,0,0,${1-brightness})`;
        ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
    }

    // 2. Render Sprites (Enemies)
    // Sort sprites by distance (far to near)
    const spriteOrder = enemies.map((e, i) => {
        return { 
            id: i, 
            dist: ((player.x - e.x)**2 + (player.y - e.y)**2) 
        };
    }).sort((a, b) => b.dist - a.dist);

    for(let i=0; i<spriteOrder.length; i++) {
        const enemy = enemies[spriteOrder[i].id];
        if(!enemy.alive) continue;

        // Transform sprite with the inverse camera matrix
        const spriteDx = enemy.x - player.x;
        const spriteDy = enemy.y - player.y;

        const invDet = 1.0 / (Math.cos(player.dir + Math.PI/2) * Math.sin(player.dir) - Math.cos(player.dir) * Math.sin(player.dir + Math.PI/2));
        
        // Simplified transform relative to player view plane
        // Actually, standard formula:
        const spriteX = (invDet * (Math.sin(player.dir) * spriteDx - Math.cos(player.dir) * spriteDy)); // Depth? No.
        // Let's use angle difference method for simpler projection in this specific engine setup
        
        const dist = Math.sqrt(spriteDx*spriteDx + spriteDy*spriteDy);
        
        // Angle to sprite
        let spriteAngle = Math.atan2(spriteDy, spriteDx) - player.dir;
        while (spriteAngle < -Math.PI) spriteAngle += 2*Math.PI;
        while (spriteAngle > Math.PI) spriteAngle -= 2*Math.PI;

        // Check if in FOV
        if(Math.abs(spriteAngle) < FOV / 1.5) {
            const screenX = (0.5 * (spriteAngle / (FOV/2)) + 0.5) * SCREEN_WIDTH;
            
            const spriteHeight = Math.abs(SCREEN_HEIGHT / (dist / BLOCK_SIZE));
            const spriteWidth = spriteHeight; // Square sprites
            const spriteTop = (SCREEN_HEIGHT - spriteHeight) / 2;

            // Check Z-Buffer (Simple column check)
            // Only draw if closer than wall at center of sprite
            const centerIdx = Math.floor(screenX);
            if(centerIdx >= 0 && centerIdx < SCREEN_WIDTH && dist < zBuffer[centerIdx]) {
                
                // Draw Sprite
                ctx.drawImage(textures.enemy, 
                    screenX - spriteWidth/2, spriteTop, 
                    spriteWidth, spriteHeight
                );

                // Shading for enemy
                const brightness = Math.max(0.2, 1.0 - dist * 0.003);
                ctx.fillStyle = `rgba(0,0,0,${1-brightness})`;
                ctx.fillRect(screenX - spriteWidth/2, spriteTop, spriteWidth, spriteHeight);
            }
        }
    }

    // 3. Draw Weapon
    const weaponKey = ['pistol', 'shotgun', 'chaingun', 'rocket'][player.currentWeaponIdx];
    const wTex = textures[weaponKey];
    
    // Bobbing effect
    const bobX = Math.sin(player.bobPhase) * 10;
    const bobY = Math.abs(Math.cos(player.bobPhase)) * 10;
    
    const weaponW = 200;
    const weaponH = 200;
    const weaponX = SCREEN_WIDTH/2 - weaponW/2 + bobX;
    const weaponY = SCREEN_HEIGHT - weaponH + 20 + bobY;

    ctx.drawImage(wTex, weaponX, weaponY, weaponW, weaponH);
}

// --- MAIN LOOP ---

function init() {
    generateTextures();
    generateTextureCanvases(); // Ensure we have the canvas version for walls
    
    player = new Player();
    
    // Spawn Enemies in empty spots
    enemies = [];
    for(let y=1; y<MAP_SIZE-1; y++) {
        for(let x=1; x<MAP_SIZE-1; x++) {
            if(WORLD_MAP[y][x] === 0 && Math.random() < 0.1) {
                // Ensure not too close to player start
                const dist = Math.sqrt((x*BLOCK_SIZE - player.x)**2 + (y*BLOCK_SIZE - player.y)**2);
                if(dist > 200) {
                    enemies.push(new Enemy(x, y));
                }
            }
        }
    }

    updateHUD();
}

function gameLoop(timestamp) {
    if(!gameRunning) return;

    const dt = timestamp - lastTime;
    lastTime = timestamp;

    // Update
    player.update(dt);
    
    enemies.forEach(e => e.update(dt));
    projectiles.forEach(p => p.update(dt));

    // Render
    ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    renderScene();

    requestAnimationFrame(gameLoop);
}

// Start initialization
init();

</script>
</body>
</html>