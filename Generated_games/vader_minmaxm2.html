<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders - 1978 Taito Original</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        canvas {
            border: 2px solid #0f0;
            background: #000;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .controls {
            color: #0f0;
            margin-top: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="controls">
            ← → Move | SPACE Fire | ENTER Start
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const ALIEN_ROWS = 5;
        const ALIENS_PER_ROW = 11;
        const TOTAL_ALIENS = ALIEN_ROWS * ALIENS_PER_ROW;
        
        // Colors
        const COLORS = {
            background: '#000000',
            player: '#00ff00',
            alienSquid: '#00ffff',
            alienBug: '#ffff00', 
            alienOctopus: '#ff00ff',
            bullet: '#ffffff',
            bomb: '#ff4444',
            ufo: '#ffaa00',
            bunker: '#00ff00',
            text: '#00ff00'
        };

        // Game state
        let gameState = 'menu'; // menu, playing, gameOver
        let score = 0;
        let highScore = localStorage.getItem('spaceInvadersHighScore') || 0;
        let lives = 3;
        let level = 1;

        // Player
        const player = {
            x: GAME_WIDTH / 2 - 20,
            y: GAME_HEIGHT - 80,
            width: 40,
            height: 30,
            speed: 5,
            canFire: true,
            fireCooldown: 0
        };

        // Bullets and bombs
        const bullets = [];
        const bombs = [];
        const particles = [];

        // Aliens formation
        let aliens = [];
        let alienDirection = 1; // 1 for right, -1 for left
        let alienSpeed = 1;
        let alienDropDistance = 20;
        let lastAlienMove = 0;
        let alienMoveInterval = 500; // milliseconds

        // UFO
        let ufo = null;
        let ufoTimer = 0;
        let nextUfoTime = Math.random() * 10000 + 15000; // Random between 15-25 seconds

        // Bunkers
        const bunkers = [];

        // Input handling
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (gameState === 'menu' && e.code === 'Enter') {
                startGame();
            } else if (gameState === 'gameOver' && e.code === 'Enter') {
                startGame();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Initialize game
        function init() {
            createAliens();
            createBunkers();
            gameState = 'menu';
        }

        function startGame() {
            score = 0;
            lives = 3;
            level = 1;
            bullets.length = 0;
            bombs.length = 0;
            particles.length = 0;
            ufo = null;
            player.x = GAME_WIDTH / 2 - 20;
            player.canFire = true;
            createAliens();
            createBunkers();
            gameState = 'playing';
        }

        function createAliens() {
            aliens = [];
            const alienWidth = 30;
            const alienHeight = 25;
            const spacingX = 50;
            const spacingY = 40;
            const startX = (GAME_WIDTH - (ALIENS_PER_ROW * spacingX)) / 2 + 25;
            const startY = 100;

            for (let row = 0; row < ALIEN_ROWS; row++) {
                for (let col = 0; col < ALIENS_PER_ROW; col++) {
                    let type, points;
                    if (row <= 1) { // Top 2 rows - Squid
                        type = 'squid';
                        points = 30;
                    } else if (row <= 3) { // Middle 2 rows - Bug  
                        type = 'bug';
                        points = 20;
                    } else { // Bottom row - Octopus
                        type = 'octopus';
                        points = 10;
                    }

                    aliens.push({
                        x: startX + col * spacingX,
                        y: startY + row * spacingY,
                        width: alienWidth,
                        height: alienHeight,
                        type: type,
                        points: points,
                        alive: true,
                        animationFrame: 0,
                        lastAnimationTime: 0
                    });
                }
            }

            alienDirection = 1;
            alienSpeed = 5 + (level - 1) * 0.2;
            alienMoveInterval = Math.max(20, 50 - (level - 1) * 10);
        }

        function createBunkers() {
            bunkers.length = 0;
            const bunkerWidth = 80;
            const bunkerHeight = 60;
            const spacing = (GAME_WIDTH - 4 * bunkerWidth) / 5;

            for (let i = 0; i < 4; i++) {
                const bunkerX = spacing + i * (bunkerWidth + spacing);
                const bunkerY = GAME_HEIGHT - 140;
                
                // Create bunker as grid of blocks
                const blocks = [];
                const blockSize = 8;
                for (let row = 0; row < Math.floor(bunkerHeight / blockSize); row++) {
                    for (let col = 0; col < Math.floor(bunkerWidth / blockSize); col++) {
                        // Create classic bunker shape with gaps
                        if ((row > 1 && row < 6) || 
                            (col > 2 && col < 7) ||
                            (row === 0 && col > 3 && col < 6)) {
                            
                            blocks.push({
                                x: bunkerX + col * blockSize,
                                y: bunkerY + row * blockSize,
                                width: blockSize,
                                height: blockSize,
                                health: 1
                            });
                        }
                    }
                }

                bunkers.push({ blocks, x: bunkerX, y: bunkerY, width: bunkerWidth, height: bunkerHeight });
            }
        }

        function createUFO() {
            ufo = {
                x: -100,
                y: 50,
                width: 60,
                height: 30,
                speed: 2 + Math.random() * 2,
                points: Math.floor(Math.random() * 500) + 100
            };
        }

        function updatePlayer(deltaTime) {
            if (keys['ArrowLeft'] && player.x > 0) {
                player.x -= player.speed;
            }
            if (keys['ArrowRight'] && player.x < GAME_WIDTH - player.width) {
                player.x += player.speed;
            }
            
            // Shooting
            if (keys['Space'] && player.canFire && bullets.length === 0) {
                fireBullet();
            }

            // Update fire cooldown
            if (!player.canFire) {
                player.fireCooldown -= deltaTime;
                if (player.fireCooldown <= 0) {
                    player.canFire = true;
                }
            }
        }

        function fireBullet() {
            bullets.push({
                x: player.x + player.width / 2 - 2,
                y: player.y,
                width: 4,
                height: 10,
                speed: 8
            });
            player.canFire = false;
            player.fireCooldown = 300; // 300ms cooldown
            
            // Add muzzle flash particles
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: player.x + player.width / 2,
                    y: player.y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: Math.random() * -3 - 1,
                    life: 200,
                    color: '#ffffff',
                    size: 2
                });
            }
        }

        function updateAliens(deltaTime, currentTime) {
            // Check if any alien has reached the edge
            let leftmost = Infinity;
            let rightmost = -Infinity;
            let bottommost = -Infinity;

            for (const alien of aliens) {
                if (!alien.alive) continue;
                
                leftmost = Math.min(leftmost, alien.x);
                rightmost = Math.max(rightmost, alien.x + alien.width);
                bottommost = Math.max(bottommost, alien.y + alien.height);

                // Animate alien
                if (currentTime - alien.lastAnimationTime > 200) {
                    alien.animationFrame = (alien.animationFrame + 1) % 2;
                    alien.lastAnimationTime = currentTime;
                }
            }

            // Move aliens
            if (currentTime - lastAlienMove > alienMoveInterval) {
                let shouldDrop = false;

                // Check if aliens hit the edge
                if ((rightmost >= GAME_WIDTH - 20 && alienDirection === 1) || 
                    (leftmost <= 20 && alienDirection === -1)) {
                    shouldDrop = true;
                }

                for (const alien of aliens) {
                    if (!alien.alive) continue;
                    
                    if (shouldDrop) {
                        alien.y += alienDropDistance;
                    } else {
                        alien.x += alienSpeed * alienDirection;
                    }
                }

                // Reverse direction after dropping
                if (shouldDrop) {
                    alienDirection *= -1;
                    alienSpeed *= 1.05; // Speed up slightly
                }

                lastAlienMove = currentTime;

                // Check if aliens reached the bottom
                if (bottommost >= player.y - 50) {
                    gameOver();
                    return;
                }
            }

            // Alien shooting
            const aliveAliens = aliens.filter(a => a.alive);
            if (aliveAliens.length > 0 && Math.random() < 0.002 + (1 - aliveAliens.length / TOTAL_ALIENS) * 0.003) {
                shootAlienBomb();
            }

            // Update speed based on remaining aliens
            const aliveCount = aliveAliens.length;
            if (aliveCount > 0) {
                alienSpeed = 1 + (level - 1) * 0.2 + (TOTAL_ALIENS - aliveCount) * 0.01;
                alienMoveInterval = Math.max(20,50 - (TOTAL_ALIENS - aliveCount) * 5);
            }
        }

        function shootAlienBomb() {
            // Find bottom-most alien in each column
            const columns = {};
            
            for (const alien of aliens) {
                if (!alien.alive) continue;
                
                const colIndex = Math.floor((alien.x - 25) / 50);
                if (!columns[colIndex] || alien.y > columns[colIndex].y) {
                    columns[colIndex] = alien;
                }
            }

            // Randomly select a column to shoot from
            const columnKeys = Object.keys(columns);
            if (columnKeys.length > 0) {
                const randomCol = columns[columnKeys[Math.floor(Math.random() * columnKeys.length)]];
                
                bombs.push({
                    x: randomCol.x + randomCol.width / 2 - 3,
                    y: randomCol.y + randomCol.height,
                    width: 6,
                    height: 12,
                    speed: 3 + Math.random() * 2
                });
            }
        }

        function updateBullets(deltaTime) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.y -= bullet.speed;

                // Remove if off screen
                if (bullet.y < -10) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with aliens
                for (const alien of aliens) {
                    if (!alien.alive) continue;
                    
                    if (bullet.x < alien.x + alien.width &&
                        bullet.x + bullet.width > alien.x &&
                        bullet.y < alien.y + alien.height &&
                        bullet.y + bullet.height > alien.y) {
                        
                        // Hit alien
                        alien.alive = false;
                        bullets.splice(i, 1);
                        score += alien.points;
                        
                        // Explosion particles
                        createExplosion(alien.x + alien.width / 2, alien.y + alien.height / 2, getAlienColor(alien.type));
                        
                        break;
                    }
                }

                // Check collision with bunkers
                if (i < bullets.length) { // Bullet still exists
                    for (const bunker of bunkers) {
                        for (let j = bunker.blocks.length - 1; j >= 0; j--) {
                            const block = bunker.blocks[j];
                            
                            if (bullet.x < block.x + block.width &&
                                bullet.x + bullet.width > block.x &&
                                bullet.y < block.y + block.height &&
                                bullet.y + bullet.height > block.y) {
                                
                                // Hit bunker block
                                bunker.blocks.splice(j, 1);
                                bullets.splice(i, 1);
                                
                                // Impact particles
                                createExplosion(block.x + block.width / 2, block.y + block.height / 2, COLORS.bunker);
                                break;
                            }
                        }
                    }
                }

                // Check collision with UFO
                if (ufo && i < bullets.length) {
                    if (bullet.x < ufo.x + ufo.width &&
                        bullet.x + bullet.width > ufo.x &&
                        bullet.y < ufo.y + ufo.height &&
                        bullet.y + bullet.height > ufo.y) {
                        
                        score += ufo.points;
                        createExplosion(ufo.x + ufo.width / 2, ufo.y + ufo.height / 2, COLORS.ufo);
                        ufo = null;
                        bullets.splice(i, 1);
                    }
                }
            }
        }

        function updateBombs(deltaTime) {
            for (let i = bombs.length - 1; i >= 0; i--) {
                const bomb = bombs[i];
                bomb.y += bomb.speed;

                // Remove if off screen
                if (bomb.y > GAME_HEIGHT + 10) {
                    bombs.splice(i, 1);
                    continue;
                }

                // Check collision with player
                if (bomb.x < player.x + player.width &&
                    bomb.x + bomb.width > player.x &&
                    bomb.y < player.y + player.height &&
                    bomb.y + bomb.height > player.y) {
                    
                    bombs.splice(i, 1);
                    loseLife();
                    continue;
                }

                // Check collision with bunkers
                for (const bunker of bunkers) {
                    for (let j = bunker.blocks.length - 1; j >= 0; j--) {
                        const block = bunker.blocks[j];
                        
                        if (bomb.x < block.x + block.width &&
                            bomb.x + bomb.width > block.x &&
                            bomb.y < block.y + block.height &&
                            bomb.y + bomb.height > block.y) {
                            
                            // Hit bunker block
                            bunker.blocks.splice(j, 1);
                            bombs.splice(i, 1);
                            
                            // Explosion particles
                            createExplosion(block.x + block.width / 2, block.y + block.height / 2, COLORS.bomb);
                            break;
                        }
                    }
                }
            }
        }

        function updateUFO(deltaTime) {
            if (!ufo) {
                ufoTimer += deltaTime;
                if (ufoTimer >= nextUfoTime) {
                    createUFO();
                    ufoTimer = 0;
                    nextUfoTime = Math.random() * 10000 + 15000;
                }
            } else {
                ufo.x += ufo.speed;
                
                // Remove UFO if it goes off screen
                if (ufo.x > GAME_WIDTH) {
                    ufo = null;
                }
            }
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= deltaTime;
                particle.vy += 0.1; // Gravity

                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function loseLife() {
            lives--;
            
            // Explosion at player position
            createExplosion(player.x + player.width / 2, player.y + player.height / 2, COLORS.player);
            
            if (lives <= 0) {
                gameOver();
            } else {
                // Reset player position and clear bombs
                player.x = GAME_WIDTH / 2 - 20;
                bombs.length = 0;
                
                // Brief invincibility
                setTimeout(() => {
                    // Player is vulnerable again
                }, 2000);
            }
        }

        function gameOver() {
            gameState = 'gameOver';
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('spaceInvadersHighScore', highScore);
            }
        }

        function checkLevelComplete() {
            const aliveAliens = aliens.filter(a => a.alive).length;
            if (aliveAliens === 0) {
                level++;
                createAliens();
                
                // Restore some bunker blocks
                for (const bunker of bunkers) {
                    // Add back some blocks to make it challenging but fair
                    const missingBlocks = Math.floor(bunker.blocks.length * 0.3);
                    for (let i = 0; i < missingBlocks && bunker.blocks.length > 0; i++) {
                        const randomIndex = Math.floor(Math.random() * bunker.blocks.length);
                        // This is simplified - in a full game you'd regenerate more intelligently
                    }
                }
            }
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: Math.random() * 500 + 300,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        function getAlienColor(type) {
            switch (type) {
                case 'squid': return COLORS.alienSquid;
                case 'bug': return COLORS.alienBug;
                case 'octopus': return COLORS.alienOctopus;
                default: return '#ffffff';
            }
        }

        function drawPlayer() {
            ctx.fillStyle = COLORS.player;
            
            // Draw classic cannon shape
            ctx.fillRect(player.x + 15, player.y, 10, 20); // Cannon barrel
            ctx.fillRect(player.x + 5, player.y + 15, 30, 15); // Base
            
            // Add some detail lines for better appearance
            ctx.fillStyle = '#008800';
            ctx.fillRect(player.x + 8, player.y + 18, 24, 3);
        }

        function drawAlien(alien) {
            if (!alien.alive) return;
            
            const colors = getAlienColor(alien.type);
            ctx.fillStyle = colors;
            
            // Draw based on type and animation frame
            switch (alien.type) {
                case 'squid':
                    drawSquid(alien.x, alien.y, alien.animationFrame);
                    break;
                case 'bug':
                    drawBug(alien.x, alien.y, alien.animationFrame);
                    break;
                case 'octopus':
                    drawOctopus(alien.x, alien.y, alien.animationFrame);
                    break;
            }
        }

        function drawSquid(x, y, frame) {
            // Squid shape - more rounded
            if (frame === 0) {
                ctx.fillRect(x + 5, y + 5, 20, 8);
                ctx.fillRect(x + 2, y + 10, 26, 6);
                ctx.fillRect(x + 4, y + 16, 22, 6);
                // Tentacles
                ctx.fillRect(x + 3, y + 20, 4, 5);
                ctx.fillRect(x + 23, y + 20, 4, 5);
            } else {
                ctx.fillRect(x + 5, y + 8, 20, 8);
                ctx.fillRect(x + 2, y + 13, 26, 6);
                ctx.fillRect(x + 4, y + 19, 22, 6);
                // Tentacles
                ctx.fillRect(x + 3, y + 15, 4, 5);
                ctx.fillRect(x + 23, y + 15, 4, 5);
            }
        }

        function drawBug(x, y, frame) {
            // Bug shape - more angular
            if (frame === 0) {
                ctx.fillRect(x + 3, y + 8, 24, 10);
                ctx.fillRect(x + 6, y + 5, 18, 4);
                ctx.fillRect(x + 2, y + 15, 26, 4);
                // Legs
                ctx.fillRect(x, y + 12, 6, 3);
                ctx.fillRect(x + 24, y + 12, 6, 3);
            } else {
                ctx.fillRect(x + 3, y + 10, 24, 10);
                ctx.fillRect(x + 6, y + 7, 18, 4);
                ctx.fillRect(x + 2, y + 17, 26, 4);
                // Legs
                ctx.fillRect(x, y + 14, 6, 3);
                ctx.fillRect(x + 24, y + 14, 6, 3);
            }
        }

        function drawOctopus(x, y, frame) {
            // Octopus shape - more tentacles
            if (frame === 0) {
                ctx.fillRect(x + 4, y + 5, 22, 8);
                ctx.fillRect(x + 2, y + 10, 26, 6);
                ctx.fillRect(x + 3, y + 16, 24, 6);
                // Many tentacles
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(x + i * 7, y + 20, 4, 5);
                }
            } else {
                ctx.fillRect(x + 4, y + 8, 22, 8);
                ctx.fillRect(x + 2, y + 13, 26, 6);
                ctx.fillRect(x + 3, y + 19, 24, 6);
                // Many tentacles
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(x + i * 7, y + 15, 4, 5);
                }
            }
        }

        function drawBunkers() {
            for (const bunker of bunkers) {
                ctx.fillStyle = COLORS.bunker;
                
                for (const block of bunker.blocks) {
                    // Add some shading for depth
                    ctx.fillStyle = '#00aa00';
                    ctx.fillRect(block.x, block.y, block.width, 2);
                    
                    ctx.fillStyle = COLORS.bunker;
                    ctx.fillRect(block.x, block.y + 2, block.width, block.height - 2);
                }
            }
        }

        function drawBullets() {
            ctx.fillStyle = COLORS.bullet;
            
            for (const bullet of bullets) {
                // Add glow effect
                ctx.shadowColor = COLORS.bullet;
                ctx.shadowBlur = 5;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                ctx.shadowBlur = 0;
            }
        }

        function drawBombs() {
            for (const bomb of bombs) {
                // Bomb with trail effect
                const gradient = ctx.createLinearGradient(bomb.x, bomb.y - 20, bomb.x, bomb.y + bomb.height);
                gradient.addColorStop(0, 'transparent');
                gradient.addColorStop(1, COLORS.bomb);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(bomb.x, bomb.y - 20, bomb.width, bomb.height + 20);
                
                // Bomb core
                ctx.fillStyle = COLORS.bomb;
                ctx.shadowColor = COLORS.bomb;
                ctx.shadowBlur = 8;
                ctx.fillRect(bomb.x, bomb.y, bomb.width, bomb.height);
                ctx.shadowBlur = 0;
            }
        }

        function drawUFO() {
            if (!ufo) return;
            
            // UFO with glow effect
            ctx.shadowColor = COLORS.ufo;
            ctx.shadowBlur = 10;
            ctx.fillStyle = COLORS.ufo;
            
            // Saucer body
            ctx.fillRect(ufo.x + 5, ufo.y + 10, 50, 15);
            ctx.fillRect(ufo.x + 15, ufo.y + 5, 30, 8);
            
            // Lights
            for (let i = 0; i < 6; i++) {
                const lightX = ufo.x + 10 + i * 8;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(lightX, ufo.y + 12, 3, 3);
            }
            
            ctx.shadowBlur = 0;
        }

        function drawParticles() {
            for (const particle of particles) {
                const alpha = Math.max(0, particle.life / 500);
                ctx.globalAlpha = alpha;
                
                ctx.fillStyle = particle.color;
                ctx.shadowColor = particle.color;
                ctx.shadowBlur = particle.size;
                ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
            }
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        function drawUI() {
            // Score
            ctx.fillStyle = COLORS.text;
            ctx.font = '24px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`SCORE: ${score.toString().padStart(6, '0')}`, 20, 35);
            
            // High score
            ctx.textAlign = 'center';
            ctx.fillText(`HI-SCORE: ${highScore.toString().padStart(6, '0')}`, GAME_WIDTH / 2, 35);
            
            // Level and lives
            ctx.textAlign = 'right';
            ctx.fillText(`LEVEL: ${level}`, GAME_WIDTH - 20, 35);
            
            // Lives (draw small cannons)
            for (let i = 0; i < lives; i++) {
                const x = 20 + i * 30;
                const y = 60;
                
                ctx.fillStyle = COLORS.player;
                ctx.fillRect(x + 5, y, 6, 8);
                ctx.fillRect(x, y + 6, 16, 6);
            }
        }

        function drawMenu() {
            ctx.fillStyle = COLORS.text;
            ctx.font = '48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('SPACE INVADERS', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 100);
            
            ctx.font = '24px Courier New';
            ctx.fillText('1978 TAITO ORIGINAL', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 60);
            
            ctx.font = '20px Courier New';
            ctx.fillText('← → MOVE    SPACE FIRE', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 40);
            ctx.fillText('PRESS ENTER TO START', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 80);
        }

        function drawGameOver() {
            ctx.fillStyle = COLORS.text;
            ctx.font = '48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50);
            
            ctx.font = '24px Courier New';
            ctx.fillText(`FINAL SCORE: ${score}`, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 20);
            ctx.fillText('PRESS ENTER TO RESTART', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 60);
        }

        // Main game loop
        let lastTime = 0;
        
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear screen
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            if (gameState === 'menu') {
                drawMenu();
            } else if (gameState === 'playing') {
                updatePlayer(deltaTime);
                updateAliens(deltaTime, currentTime);
                updateBullets(deltaTime);
                updateBombs(deltaTime);
                updateUFO(deltaTime);
                updateParticles(deltaTime);
                
                checkLevelComplete();

                // Draw everything
                drawUI();
                drawPlayer();
                drawBunkers();
                
                for (const alien of aliens) {
                    drawAlien(alien);
                }
                
                drawBullets();
                drawBombs();
                drawUFO();
                drawParticles();
            } else if (gameState === 'gameOver') {
                drawGameOver();
            }

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>