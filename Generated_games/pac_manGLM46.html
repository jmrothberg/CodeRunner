<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man - Classic Arcade Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        .game-container {
            text-align: center;
        }
        
        canvas {
            border: 2px solid #00f;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .score-display {
            color: #fff;
            font-size: 20px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 0 #00f;
        }
        
        .controls {
            color: #0ff;
            margin-top: 10px;
            font-size: 14px;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f00;
            font-size: 48px;
            text-shadow: 3px 3px 0 #000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="score-display">
            SCORE: <span id="score">0</span> | HIGH: <span id="highScore">0</span> | LIVES: <span id="lives">3</span> | LEVEL: <span id="level">1</span>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            Use ARROW KEYS to move â€¢ SPACE to start/pause
        </div>
        <div class="game-over" id="gameOver">GAME OVER</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const CELL_SIZE = 20;
        const MAZE_WIDTH = 19;
        const MAZE_HEIGHT = 21;
        const PACMAN_SPEED = 0.15;
        const GHOST_SPEED = 0.08;
        const POWER_DURATION = 6000; // milliseconds
        
        canvas.width = MAZE_WIDTH * CELL_SIZE;
        canvas.height = MAZE_HEIGHT * CELL_SIZE;
        
        // Maze layout (1 = wall, 0 = dot, 2 = empty, 3 = power pellet, 4 = ghost house)
        const mazeLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,3,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,3,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,1,2,2,2,1,0,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,1,2,2,2,1,0,0,0,0,0,0,1],
            [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,1,1,1],
            [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
            [1,3,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,3,1],
            [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        // Game state
        let gameState = {
            score: 0,
            highScore: localStorage.getItem('pacmanHighScore') || 0,
            lives: 3,
            level: 1,
            dotsRemaining: 0,
            powerMode: false,
            powerTimer: null,
            gameRunning: false,
            gamePaused: false,
            gameOver: false
        };
        
        // Pac-Man object
        const pacman = {
            x: 9.5,
            y: 15,
            direction: 'right',
            nextDirection: null,
            mouthOpen: true,
            mouthAngle: 0,
            animationFrame: 0
        };
        
        // Ghost objects with distinct personalities
        class Ghost {
            constructor(name, color, startX, startY, personality) {
                this.name = name;
                this.color = color;
                this.x = startX;
                this.y = startY;
                this.startX = startX;
                this.startY = startY;
                this.direction = 'up';
                this.personality = personality; // chase, ambush, flank, erratic
                this.scared = false;
                this.eaten = false;
                this.animationFrame = 0;
                this.targetX = 0;
                this.targetY = 0;
            }
            
            reset() {
                this.x = this.startX;
                this.y = this.startY;
                this.direction = 'up';
                this.scared = false;
                this.eaten = false;
            }
        }
        
        const ghosts = [
            new Ghost('Blinky', '#ff0000', 9, 9, 'chase'),
            new Ghost('Pinky', '#ffb8ff', 9, 10, 'ambush'),
            new Ghost('Inky', '#00ffff', 8, 10, 'flank'),
            new Ghost('Clyde', '#ffb852', 10, 10, 'erratic')
        ];
        
        // Initialize maze
        let maze = [];
        function initializeMaze() {
            maze = JSON.parse(JSON.stringify(mazeLayout));
            gameState.dotsRemaining = 0;
            
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 0 || maze[y][x] === 3) {
                        gameState.dotsRemaining++;
                    }
                }
            }
            
            console.log(`Level ${gameState.level} initialized with ${gameState.dotsRemaining} dots`);
        }
        
        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === ' ') {
                e.preventDefault();
                if (!gameState.gameRunning && !gameState.gameOver) {
                    startGame();
                } else if (gameState.gameRunning) {
                    gameState.gamePaused = !gameState.gamePaused;
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // Movement functions
        function canMove(x, y) {
            const gridX = Math.floor(x);
            const gridY = Math.floor(y);
            
            if (gridX < 0 || gridX >= MAZE_WIDTH || gridY < 0 || gridY >= MAZE_HEIGHT) {
                return false;
            }
            
            return maze[gridY][gridX] !== 1;
        }
        
        function updatePacman() {
            // Handle direction change
            if (pacman.nextDirection) {
                let testX = pacman.x;
                let testY = pacman.y;
                
                switch(pacman.nextDirection) {
                    case 'up': testY -= PACMAN_SPEED; break;
                    case 'down': testY += PACMAN_SPEED; break;
                    case 'left': testX -= PACMAN_SPEED; break;
                    case 'right': testX += PACMAN_SPEED; break;
                }
                
                if (canMove(testX, testY)) {
                    pacman.direction = pacman.nextDirection;
                    pacman.nextDirection = null;
                }
            }
            
            // Move in current direction
            let newX = pacman.x;
            let newY = pacman.y;
            
            switch(pacman.direction) {
                case 'up': newY -= PACMAN_SPEED; break;
                case 'down': newY += PACMAN_SPEED; break;
                case 'left': newX -= PACMAN_SPEED; break;
                case 'right': newX += PACMAN_SPEED; break;
            }
            
            // Handle screen wrapping through tunnels
            if (newX < -0.5) newX = MAZE_WIDTH - 0.5;
            if (newX > MAZE_WIDTH - 0.5) newX = -0.5;
            
            if (canMove(newX, newY)) {
                pacman.x = newX;
                pacman.y = newY;
                
                // Eat dots
                const gridX = Math.floor(pacman.x);
                const gridY = Math.floor(pacman.y);
                
                if (maze[gridY][gridX] === 0) {
                    maze[gridY][gridX] = 2;
                    gameState.score += 10;
                    gameState.dotsRemaining--;
                    
                    // Check for level completion
                    if (gameState.dotsRemaining === 0) {
                        nextLevel();
                    }
                } else if (maze[gridY][gridX] === 3) {
                    maze[gridY][gridX] = 2;
                    gameState.score += 50;
                    gameState.dotsRemaining--;
                    activatePowerMode();
                    
                    if (gameState.dotsRemaining === 0) {
                        nextLevel();
                    }
                }
            } else {
                // Stop at wall
                pacman.x = Math.round(pacman.x);
                pacman.y = Math.round(pacman.y);
            }
            
            // Update animation
            pacman.animationFrame++;
            pacman.mouthAngle = Math.abs(Math.sin(pacman.animationFrame * 0.2)) * 0.4;
        }
        
        function updateGhosts() {
            ghosts.forEach(ghost => {
                if (ghost.eaten) {
                    // Return to ghost house
                    const targetX = 9;
                    const targetY = 10;
                    
                    if (Math.abs(ghost.x - targetX) < 0.1 && Math.abs(ghost.y - targetY) < 0.1) {
                        ghost.eaten = false;
                        ghost.scared = false;
                    } else {
                        moveGhostTowards(ghost, targetX, targetY, GHOST_SPEED * 2);
                    }
                } else if (ghost.scared) {
                    // Run away from Pac-Man
                    const dx = ghost.x - pacman.x;
                    const dy = ghost.y - pacman.y;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        moveGhostTowards(ghost, ghost.x + Math.sign(dx), ghost.y, GHOST_SPEED * 0.8);
                    } else {
                        moveGhostTowards(ghost, ghost.x, ghost.y + Math.sign(dy), GHOST_SPEED * 0.8);
                    }
                } else {
                    // Normal AI behavior
                    updateGhostAI(ghost);
                }
                
                // Update animation
                ghost.animationFrame++;
            });
        }
        
        function updateGhostAI(ghost) {
            let targetX = pacman.x;
            let targetY = pacman.y;
            
            switch(ghost.personality) {
                case 'chase': // Blinky - directly chase Pac-Man
                    break;
                    
                case 'ambush': // Pinky - ambush 4 tiles ahead of Pac-Man
                    switch(pacman.direction) {
                        case 'up': targetY -= 4; break;
                        case 'down': targetY += 4; break;
                        case 'left': targetX -= 4; break;
                        case 'right': targetX += 4; break;
                    }
                    break;
                    
                case 'flank': // Inky - complex flanking behavior
                    const blinky = ghosts[0];
                    const vectorX = (pacman.x + getOffsetX(pacman.direction, 2)) - blinky.x;
                    const vectorY = (pacman.y + getOffsetY(pacman.direction, 2)) - blinky.y;
                    targetX = blinky.x + vectorX * 2;
                    targetY = blinky.y + vectorY * 2;
                    break;
                    
                case 'erratic': // Clyde - chase when far, scatter when near
                    const distance = Math.sqrt(Math.pow(ghost.x - pacman.x, 2) + Math.pow(ghost.y - pacman.y, 2));
                    if (distance > 8) {
                        // Chase mode
                    } else {
                        // Scatter to bottom-left corner
                        targetX = 1;
                        targetY = MAZE_HEIGHT - 2;
                    }
                    break;
            }
            
            moveGhostTowards(ghost, targetX, targetY, GHOST_SPEED);
        }
        
        function getOffsetX(direction, distance) {
            switch(direction) {
                case 'left': return -distance;
                case 'right': return distance;
                default: return 0;
            }
        }
        
        function getOffsetY(direction, distance) {
            switch(direction) {
                case 'up': return -distance;
                case 'down': return distance;
                default: return 0;
            }
        }
        
        function moveGhostTowards(ghost, targetX, targetY, speed) {
            const dx = targetX - ghost.x;
            const dy = targetY - ghost.y;
            
            let newX = ghost.x;
            let newY = ghost.y;
            
            // Choose best direction
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0 && canMove(ghost.x + speed, ghost.y)) {
                    newX += speed;
                    ghost.direction = 'right';
                } else if (dx < 0 && canMove(ghost.x - speed, ghost.y)) {
                    newX -= speed;
                    ghost.direction = 'left';
                } else if (dy > 0 && canMove(ghost.x, ghost.y + speed)) {
                    newY += speed;
                    ghost.direction = 'down';
                } else if (dy < 0 && canMove(ghost.x, ghost.y - speed)) {
                    newY -= speed;
                    ghost.direction = 'up';
                }
            } else {
                if (dy > 0 && canMove(ghost.x, ghost.y + speed)) {
                    newY += speed;
                    ghost.direction = 'down';
                } else if (dy < 0 && canMove(ghost.x, ghost.y - speed)) {
                    newY -= speed;
                    ghost.direction = 'up';
                } else if (dx > 0 && canMove(ghost.x + speed, ghost.y)) {
                    newX += speed;
                    ghost.direction = 'right';
                } else if (dx < 0 && canMove(ghost.x - speed, ghost.y)) {
                    newX -= speed;
                    ghost.direction = 'left';
                }
            }
            
            // Handle screen wrapping
            if (newX < -0.5) newX = MAZE_WIDTH - 0.5;
            if (newX > MAZE_WIDTH - 0.5) newX = -0.5;
            
            if (canMove(newX, newY)) {
                ghost.x = newX;
                ghost.y = newY;
            }
        }
        
        function checkCollisions() {
            ghosts.forEach(ghost => {
                const distance = Math.sqrt(Math.pow(pacman.x - ghost.x, 2) + Math.pow(pacman.y - ghost.y, 2));
                
                if (distance < 0.5) {
                    if (ghost.scared && !ghost.eaten) {
                        // Eat ghost
                        gameState.score += 200;
                        ghost.eaten = true;
                        console.log(`Pac-Man ate ${ghost.name}! Score: ${gameState.score}`);
                    } else if (!ghost.eaten && !gameState.powerMode) {
                        // Pac-Man dies
                        loseLife();
                    }
                }
            });
        }
        
        function activatePowerMode() {
            gameState.powerMode = true;
            
            ghosts.forEach(ghost => {
                if (!ghost.eaten) {
                    ghost.scared = true;
                }
            });
            
            clearTimeout(gameState.powerTimer);
            gameState.powerTimer = setTimeout(() => {
                gameState.powerMode = false;
                ghosts.forEach(ghost => {
                    ghost.scared = false;
                });
            }, POWER_DURATION);
        }
        
        function loseLife() {
            gameState.lives--;
            console.log(`Pac-Man lost a life! Lives remaining: ${gameState.lives}`);
            
            if (gameState.lives <= 0) {
                gameOver();
            } else {
                resetPositions();
            }
        }
        
        function resetPositions() {
            pacman.x = 9.5;
            pacman.y = 15;
            pacman.direction = 'right';
            pacman.nextDirection = null;
            
            ghosts.forEach((ghost, index) => {
                ghost.reset();
            });
        }
        
        function nextLevel() {
            gameState.level++;
            console.log(`Level ${gameState.level} reached!`);
            
            // Increase difficulty
            if (gameState.level % 2 === 0) {
                GHOST_SPEED += 0.01;
            }
            
            initializeMaze();
            resetPositions();
        }
        
        function gameOver() {
            gameState.gameOver = true;
            gameState.gameRunning = false;
            
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('pacmanHighScore', gameState.highScore);
            }
            
            document.getElementById('gameOver').style.display = 'block';
            console.log(`Game Over! Final Score: ${gameState.score}`);
        }
        
        function startGame() {
            gameState.gameRunning = true;
            gameState.gamePaused = false;
            gameState.gameOver = false;
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            
            document.getElementById('gameOver').style.display = 'none';
            
            initializeMaze();
            resetPositions();
        }
        
        // Drawing functions
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw maze
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const cell = maze[y][x];
                    
                    if (cell === 1) {
                        // Wall
                        ctx.fillStyle = '#0000ff';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        
                        // Add wall highlights for depth
                        ctx.strokeStyle = '#4040ff';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x * CELL_SIZE + 1, y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                    } else if (cell === 0) {
                        // Dot
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x * CELL_SIZE + CELL_SIZE/2, y * CELL_SIZE + CELL_SIZE/2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (cell === 3) {
                        // Power pellet
                        const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 1;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x * CELL_SIZE + CELL_SIZE/2, y * CELL_SIZE + CELL_SIZE/2, 4 * pulse, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (cell === 4) {
                        // Ghost house
                        ctx.strokeStyle = '#ff00ff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
            
            // Draw Pac-Man
            drawPacman();
            
            // Draw ghosts
            ghosts.forEach(ghost => {
                drawGhost(ghost);
            });
            
            // Update UI
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('highScore').textContent = gameState.highScore;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('level').textContent = gameState.level;
        }
        
        function drawPacman() {
            ctx.save();
            ctx.translate(pacman.x * CELL_SIZE + CELL_SIZE/2, pacman.y * CELL_SIZE + CELL_SIZE/2);
            
            // Rotate based on direction
            let rotation = 0;
            switch(pacman.direction) {
                case 'right': rotation = 0; break;
                case 'down': rotation = Math.PI / 2; break;
                case 'left': rotation = Math.PI; break;
                case 'up': rotation = -Math.PI / 2; break;
            }
            ctx.rotate(rotation);
            
            // Draw Pac-Man body
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(0, 0, CELL_SIZE/2 - 1, pacman.mouthAngle, Math.PI * 2 - pacman.mouthAngle);
            ctx.lineTo(0, 0);
            ctx.closePath();
            ctx.fill();
            
            // Add shine effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(-3, -3, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawGhost(ghost) {
            const x = ghost.x * CELL_SIZE + CELL_SIZE/2;
            const y = ghost.y * CELL_SIZE + CELL_SIZE/2;
            
            // Ghost body
            if (ghost.scared && !ghost.eaten) {
                // Blue scared color with flashing
                ctx.fillStyle = Math.floor(Date.now() / 200) % 2 ? '#0000ff' : '#ffffff';
            } else if (ghost.eaten) {
                // Eyes only when eaten
                ctx.fillStyle = 'transparent';
            } else {
                ctx.fillStyle = ghost.color;
            }
            
            // Draw ghost shape
            ctx.beginPath();
            ctx.arc(x, y - 2, CELL_SIZE/2 - 1, Math.PI, 0);
            ctx.lineTo(x + CELL_SIZE/2 - 1, y + CELL_SIZE/2 - 3);
            
            // Wavy bottom
            for (let i = 0; i < 3; i++) {
                const waveX = x + CELL_SIZE/2 - 1 - (i + 1) * (CELL_SIZE - 2) / 3;
                const waveY = y + CELL_SIZE/2 - 3 + Math.sin(ghost.animationFrame * 0.1 + i) * 2;
                ctx.lineTo(waveX, waveY);
            }
            
            ctx.closePath();
            ctx.fill();
            
            // Draw eyes
            if (!ghost.eaten) {
                // Eye whites
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(x - 4, y - 2, 3, 0, Math.PI * 2);
                ctx.arc(x + 4, y - 2, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = ghost.scared ? '#ffffff' : '#000000';
                const pupilOffset = ghost.scared ? 0 : 1;
                ctx.beginPath();
                ctx.arc(x - 4 + pupilOffset, y - 2, 1.5, 0, Math.PI * 2);
                ctx.arc(x + 4 + pupilOffset, y - 2, 1.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Draw eyes only when eaten
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x - 4, y - 2);
                ctx.lineTo(x - 2, y);
                ctx.moveTo(x + 4, y - 2);
                ctx.lineTo(x + 2, y);
                ctx.stroke();
            }
        }
        
        // Game loop
        function gameLoop() {
            if (gameState.gameRunning && !gameState.gamePaused) {
                // Handle input
                if (keys['ArrowUp']) pacman.nextDirection = 'up';
                if (keys['ArrowDown']) pacman.nextDirection = 'down';
                if (keys['ArrowLeft']) pacman.nextDirection = 'left';
                if (keys['ArrowRight']) pacman.nextDirection = 'right';
                
                // Update game state
                updatePacman();
                updateGhosts();
                checkCollisions();
            }
            
            // Draw everything
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize and start
        initializeMaze();
        gameLoop();
        
        console.log('Pac-Man game initialized! Press SPACE to start.');
    </script>
</body>
</html>