<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Space Invaders 3D</title>
    <style>
        :root {
            --primary-color: #00ffcc;
            --danger-color: #ff0055;
            --ui-bg: rgba(0, 10, 20, 0.85);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }

        /* Game Container */
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* HUD */
        .hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 1.5rem;
            text-shadow: 0 0 10px var(--primary-color);
            font-weight: bold;
        }

        .score-box span { color: var(--primary-color); }
        .lives-box span { color: var(--danger-color); }

        /* Screens (Start / Game Over) */
        .screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--ui-bg);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.3);
            pointer-events: auto; /* Enable buttons */
            transition: opacity 0.3s ease;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            display: none; /* Remove from flow */
        }

        h1 {
            margin-top: 0;
            font-size: 3rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            background: linear-gradient(to right, #00ffcc, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p { color: #ccc; margin-bottom: 30px; line-height: 1.6; }

        .btn {
            background: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            padding: 15px 40px;
            font-size: 1.2rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .btn:hover {
            background: var(--primary-color);
            color: #000;
            box-shadow: 0 0 20px var(--primary-color);
        }

        /* Controls hint */
        .controls-hint {
            margin-top: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
        }
        
        kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            border-bottom: 2px solid #555;
            font-family: monospace;
        }
    </style>
    
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <!-- 3D Canvas Container -->
    <div id="game-container"></div>

    <!-- UI Overlay -->
    <main id="ui-layer">
        <header class="hud">
            <div class="score-box">SCORE: <span id="score-display">0</span></div>
            <div class="lives-box">LIVES: <span id="lives-display">3</span></div>
        </header>

        <!-- Start Screen -->
        <section id="start-screen" class="screen">
            <h1>Neon Invaders 3D</h1>
            <p>Defend the grid from the alien swarm.</p>
            <button id="start-btn" class="btn">Start Mission</button>
            <div class="controls-hint">
                Controls: <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> to Move | <kbd>Space</kbd> to Shoot
            </div>
        </section>

        <!-- Game Over Screen -->
        <section id="game-over-screen" class="screen hidden">
            <h1 style="-webkit-text-fill-color: var(--danger-color);">Mission Failed</h1>
            <p>Final Score: <span id="final-score">0</span></p>
            <button id="restart-btn" class="btn">Try Again</button>
        </section>
        
        <!-- Win Screen -->
        <section id="win-screen" class="screen hidden">
            <h1 style="-webkit-text-fill-color: #ffff00;">Sector Cleared!</h1>
            <p>You have defeated the invasion.</p>
            <p>Final Score: <span id="win-score">0</span></p>
            <button id="play-again-btn" class="btn">Next Wave</button>
        </section>
    </main>

    <!-- Game Logic -->
    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const CONFIG = {
            playerSpeed: 0.8,
            bulletSpeed: 1.5,
            enemyBulletSpeed: 0.6,
            fireRate: 250, // ms
            enemyMoveSpeed: 0.05,
            enemyDropDistance: 2.0,
            boundsX: 35,
            boundsY: 18,
            colors: {
                player: 0x00ffcc,
                bullet: 0xffff00,
                enemy: 0xff0055,
                enemyBullet: 0xff5500
            }
        };

        // --- Global State ---
        let scene, camera, renderer;
        let player;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let score = 0;
        let lives = 3;
        let isGameRunning = false;
        let lastFireTime = 0;
        
        // Enemy Movement State
        let enemyDirection = 1; // 1 = right, -1 = left
        let enemyStepTimer = 0;
        let enemyMoveInterval = 60; // Frames between moves (decreases as they die)

        // Input State
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Space: false
        };

        // --- Audio System (Web Audio API) ---
        class SoundManager {
            constructor() {
                this.ctx = null;
                this.initialized = false;
            }

            init() {
                if (!this.initialized) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.initialized = true;
                    console.log("Audio System Initialized");
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            playShoot() {
                if (!this.initialized) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
                
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }

            playExplosion() {
                if (!this.initialized) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.3);

                gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.35);
            }

            playEnemyShoot() {
                if (!this.initialized) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'square';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(150, this.ctx.currentTime + 0.1);

                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);

                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
            }
        }

        const audio = new SoundManager();

        // --- Initialization ---
        function init() {
            console.log("Initializing 3D Space Invaders...");

            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            // Camera (Perspective)
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, -10, 40); // Positioned behind and slightly below
            camera.lookAt(0, 5, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Environment (Starfield)
            createStarfield();

            // Grid Floor
            const gridHelper = new THREE.GridHelper(200, 50, 0x00ffcc, 0x111111);
            gridHelper.position.y = -15;
            scene.add(gridHelper);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => handleKey(e, true));
            document.addEventListener('keyup', (e) => handleKey(e, false));

            // Start Loop
            animate();
        }

        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 1000; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200 - 50
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        // --- Game Objects ---

        function createPlayer() {
            if (player) scene.remove(player.mesh);

            const geometry = new THREE.ConeGeometry(1, 3, 4); // Simple futuristic ship
            const material = new THREE.MeshPhongMaterial({ 
                color: CONFIG.colors.player,
                emissive: 0x004433,
                flatShading: true
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2; // Point forward (towards positive Z)
            mesh.position.set(0, -10, 0);

            // Engine glow
            const light = new THREE.PointLight(CONFIG.colors.player, 1, 10);
            light.position.set(0, 0, 1.5);
            mesh.add(light);

            player = { mesh: mesh };
            scene.add(mesh);
        }

        function createEnemies() {
            // Clear existing
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];

            const rows = 4;
            const cols = 8;
            const startX = -20;
            const startY = 10;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    // Procedural Enemy Mesh
                    const group = new THREE.Group();
                    
                    // Body
                    const bodyGeo = new THREE.BoxGeometry(1.5, 1.5, 1);
                    const bodyMat = new THREE.MeshPhongMaterial({ color: CONFIG.colors.enemy });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    group.add(body);

                    // Eyes (Glowing)
                    const eyeGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                    leftEye.position.set(-0.3, 0.2, 0.5);
                    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                    rightEye.position.set(0.3, 0.2, 0.5);
                    group.add(leftEye);
                    group.add(rightEye);

                    // Position
                    group.position.set(startX + c * 4, startY - r * 3, 0);
                    
                    scene.add(group);
                    enemies.push({ 
                        mesh: group, 
                        active: true,
                        initialX: group.position.x,
                        offset: Math.random() * Math.PI * 2 // For animation
                    });
                }
            }
        }

        function createBullet(position, isEnemy = false) {
            const color = isEnemy ? CONFIG.colors.enemyBullet : CONFIG.colors.bullet;
            const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
            const material = new THREE.MeshBasicMaterial({ color: color });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = Math.PI / 2; // Align with Z axis
            mesh.position.copy(position);

            scene.add(mesh);
            
            bullets.push({
                mesh: mesh,
                velocity: isEnemy ? CONFIG.enemyBulletSpeed : -CONFIG.bulletSpeed,
                isEnemy: isEnemy,
                active: true
            });

            if (isEnemy) audio.playEnemyShoot();
            else audio.playShoot();
        }

        function createExplosion(position, color) {
            const particleCount = 15;
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const material = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.copy(position);
                
                // Random velocity
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.8,
                    (Math.random() - 0.5) * 0.8,
                    (Math.random() - 0.5) * 0.8
                );

                scene.add(mesh);
                particles.push({ mesh: mesh, velocity: vel, life: 1.0 });
            }
            audio.playExplosion();
        }

        // --- Logic & Updates ---

        function handleKey(e, isDown) {
            if (e.code === 'ArrowUp') keys.ArrowUp = isDown;
            if (e.code === 'ArrowDown') keys.ArrowDown = isDown;
            if (e.code === 'ArrowLeft') keys.ArrowLeft = isDown;
            if (e.code === 'ArrowRight') keys.ArrowRight = isDown;
            if (e.code === 'Space') {
                keys.Space = isDown;
                // Prevent scrolling with space
                e.preventDefault(); 
            }
        }

        function updatePlayer() {
            if (!player) return;

            // Movement
            if (keys.ArrowLeft && player.mesh.position.x > -CONFIG.boundsX) 
                player.mesh.position.x -= CONFIG.playerSpeed;
            if (keys.ArrowRight && player.mesh.position.x < CONFIG.boundsX) 
                player.mesh.position.x += CONFIG.playerSpeed;
            if (keys.ArrowUp && player.mesh.position.y < 5) // Limit forward movement
                player.mesh.position.y += CONFIG.playerSpeed;
            if (keys.ArrowDown && player.mesh.position.y > -CONFIG.boundsY) 
                player.mesh.position.y -= CONFIG.playerSpeed;

            // Banking effect (visual tilt)
            const targetRotationZ = (keys.ArrowLeft ? 0.3 : 0) + (keys.ArrowRight ? -0.3 : 0);
            player.mesh.rotation.z += (targetRotationZ - player.mesh.rotation.z) * 0.1;

            // Shooting
            if (keys.Space && Date.now() - lastFireTime > CONFIG.fireRate) {
                createBullet(player.mesh.position.clone().add(new THREE.Vector3(0, 0, -2)), false);
                lastFireTime = Date.now();
            }
        }

        function updateEnemies() {
            let hitEdge = false;
            const activeEnemies = enemies.filter(e => e.active);

            // Speed up as fewer enemies remain
            const currentInterval = Math.max(5, enemyMoveInterval - (40 - activeEnemies.length));

            if (activeEnemies.length === 0) {
                gameWin();
                return;
            }

            // Move logic based on timer to simulate "steps"
            enemyStepTimer++;
            
            // Animate hover
            const time = Date.now() * 0.002;
            enemies.forEach(e => {
                e.mesh.position.y += Math.sin(time + e.offset) * 0.01;
            });

            if (enemyStepTimer > currentInterval) {
                enemyStepTimer = 0;

                // Check edges
                activeEnemies.forEach(e => {
                    const nextX = e.mesh.position.x + (CONFIG.enemyMoveSpeed * 2 * enemyDirection);
                    if (nextX > CONFIG.boundsX || nextX < -CONFIG.boundsX) {
                        hitEdge = true;
                    }
                });

                if (hitEdge) {
                    // Move down and flip direction
                    activeEnemies.forEach(e => {
                        e.mesh.position.z -= CONFIG.enemyDropDistance; // Move closer to player
                        e.mesh.rotation.y += Math.PI; // Flip face
                    });
                    enemyDirection *= -1;
                } else {
                    // Move sideways
                    activeEnemies.forEach(e => {
                        e.mesh.position.x += (CONFIG.enemyMoveSpeed * 2 * enemyDirection);
                    });
                }

                // Random Enemy Shooting
                if (Math.random() < 0.3 + (0.05 * (40 - activeEnemies.length))) { // Shoot more as they die
                    const shooter = activeEnemies[Math.floor(Math.random() * activeEnemies.length)];
                    createBullet(shooter.mesh.position.clone().add(new THREE.Vector3(0, 0, 1)), true);
                }

                // Check if enemies reached player level (Game Over)
                activeEnemies.forEach(e => {
                    if (e.mesh.position.z < -5) { // Close to camera Z
                        gameOver();
                    }
                });
            }
        }

        function updateBullets() {
            bullets.forEach(b => {
                b.mesh.position.z += b.velocity;

                // Cleanup out of bounds
                if (b.mesh.position.z > 50 || b.mesh.position.z < -20) {
                    b.active = false;
                }
            });

            // Collision Detection
            bullets.forEach(bullet => {
                if (!bullet.active) return;

                if (bullet.isEnemy) {
                    // Check collision with Player
                    const dist = bullet.mesh.position.distanceTo(player.mesh.position);
                    if (dist < 2.0) {
                        playerHit();
                        bullet.active = false;
                    }
                } else {
                    // Check collision with Enemies
                    enemies.forEach(enemy => {
                        if (!enemy.active) return;
                        const dist = bullet.mesh.position.distanceTo(enemy.mesh.position);
                        if (dist < 1.5) {
                            enemyHit(enemy, bullet);
                        }
                    });
                }
            });

            // Remove inactive bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                if (!bullets[i].active) {
                    scene.remove(bullets[i].mesh);
                    bullets.splice(i, 1);
                }
            }
        }

        function updateParticles() {
            particles.forEach(p => {
                p.mesh.position.add(p.velocity);
                p.life -= 0.05;
                p.mesh.scale.setScalar(p.life);
                p.mesh.rotation.x += 0.1;
            });

            for (let i = particles.length - 1; i >= 0; i--) {
                if (particles[i].life <= 0) {
                    scene.remove(particles[i].mesh);
                    particles.splice(i, 1);
                }
            }
        }

        // --- Game Events ---

        function enemyHit(enemy, bullet) {
            enemy.active = false;
            bullet.active = false;
            
            createExplosion(enemy.mesh.position, CONFIG.colors.enemy);
            scene.remove(enemy.mesh); // Remove from scene immediately
            
            score += 100;
            updateHUD();
        }

        function playerHit() {
            createExplosion(player.mesh.position, CONFIG.colors.player);
            lives--;
            updateHUD();

            if (lives <= 0) {
                gameOver();
            } else {
                // Respawn effect / reset position
                player.mesh.position.set(0, -10, 0);
            }
        }

        function startGame() {
            audio.init(); // Initialize audio context on user gesture
            
            score = 0;
            lives = 3;
            enemyMoveInterval = 60;
            
            updateHUD();
            
            createPlayer();
            createEnemies();
            
            // Clear old bullets/particles
            bullets.forEach(b => scene.remove(b.mesh));
            bullets = [];
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('win-screen').classList.add('hidden');

            isGameRunning = true;
            console.log("Game Started");
        }

        function gameOver() {
            isGameRunning = false;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-screen').classList.remove('hidden');
            console.log("Game Over - Score: " + score);
        }

        function gameWin() {
            isGameRunning = false;
            document.getElementById('win-score').innerText = score;
            document.getElementById('win-screen').classList.remove('hidden');
            console.log("Sector Cleared - Score: " + score);
        }

        function updateHUD() {
            document.getElementById('score-display').innerText = score;
            document.getElementById('lives-display').innerText = lives;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (isGameRunning) {
                updatePlayer();
                updateEnemies();
                updateBullets();
                updateParticles();
                
                // Dynamic Camera follow (subtle)
                camera.position.x += (player.mesh.position.x * 0.3 - camera.position.x) * 0.05;
            }

            renderer.render(scene, camera);
        }

        // --- UI Bindings ---
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);
        document.getElementById('play-again-btn').addEventListener('click', startGame);

        // Boot
        init();

    </script>
</body>
</html>