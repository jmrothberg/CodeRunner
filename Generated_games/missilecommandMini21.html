<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Missile Command - Arcade Tribute</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            border: 4px solid #333;
        }

        canvas {
            display: block;
            background-color: #000000;
            cursor: none; /* Hide default cursor */
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
            color: #00ff00;
            font-size: 20px;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border: 2px solid #00ff00;
            display: none;
        }

        h1 { margin-top: 0; color: #ff0000; text-shadow: 0 0 10px #ff0000; font-size: 40px; }
        p { color: #fff; line-height: 1.5; }
        .blink { animation: blinker 1s linear infinite; }
        
        @keyframes blinker {
            50% { opacity: 0; }
        }

        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            font-size: 18px;
        }
        button:hover { background: #fff; }

    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div>SCORE: <span id="scoreEl">0</span></div>
        <div>HIGH: <span id="highScoreEl">0</span></div>
        <div>CITIES: <span id="citiesEl">6</span></div>
    </div>

    <div id="start-screen" style="display: block;">
        <h1>MISSILE COMMAND</h1>
        <p>DEFEND YOUR CITIES!</p>
        <p>Mouse to Aim & Click to Fire<br>or Arrow Keys + Spacebar</p>
        <button onclick="startGame()">START GAME</button>
    </div>

    <div id="game-over-screen">
        <h1>GAME OVER</h1>
        <p>FINAL SCORE: <span id="finalScoreEl">0</span></p>
        <button onclick="resetGame()">TRY AGAIN</button>
    </div>
</div>

<script>
/**
 * MISSILE COMMAND - ATARI TRIBUTE
 * 
 * Core Systems:
 * 1. Game Loop (Update/Draw)
 * 2. Entity Management (Missiles, Explosions, Particles)
 * 3. Collision Detection
 * 4. Audio Synthesis (Web Audio API)
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- AUDIO SYSTEM (Synthesized) ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;

function initAudio() {
    if (!audioCtx) audioCtx = new AudioCtx();
    if (audioCtx.state === 'suspended') audioCtx.resume();
}

const Sound = {
    playTone: (freq, type, duration) => {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    },
    playNoise: (duration) => {
        if (!audioCtx) return;
        const bufferSize = audioCtx.sampleRate * duration;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        noise.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    },
    sfxLaunch: () => Sound.playTone(800, 'square', 0.1),
    sfxExplosion: () => Sound.playNoise(0.4),
    sfxHit: () => Sound.playTone(200, 'sawtooth', 0.1),
    sfxGameOver: () => {
        Sound.playTone(300, 'sawtooth', 0.2);
        setTimeout(() => Sound.playTone(250, 'sawtooth', 0.4), 200);
    }
};

// --- GAME CONSTANTS ---
const COLORS = {
    sky: '#000011',
    ground: '#000022',
    cityAlive: '#00FF00',
    cityDead: '#550000',
    battery: '#00AA00',
    missileEnemy: '#FFFFFF',
    missileFriendly: '#FFFF00', // Yellowish
    explosionCore: '#FFFFFF',
    explosionMid: '#FF0000',
    explosionOuter: '#0000FF'
};

const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;

// --- STATE ---
let gameState = {
    running: false,
    score: 0,
    highScore: localStorage.getItem('mc_highscore') || 0,
    level: 1,
    cities: [],
    missiles: [], // Both enemy and friendly
    explosions: [],
    particles: [],
    stars: [],
    crosshair: { x: GAME_WIDTH/2, y: GAME_HEIGHT/2 },
    ammo: 0,
    waveInProgress: false,
    enemiesToSpawn: 0,
    spawnTimer: 0,
    mouseControl: true
};

// --- CLASSES ---

class Star {
    constructor() {
        this.x = Math.random() * GAME_WIDTH;
        this.y = Math.random() * (GAME_HEIGHT - 50);
        this.size = Math.random() * 1.5;
        this.blinkSpeed = 0.02 + Math.random() * 0.05;
        this.alpha = Math.random();
    }
    draw(ctx) {
        this.alpha += this.blinkSpeed;
        if (this.alpha > 1 || this.alpha < 0) this.blinkSpeed *= -1;
        ctx.fillStyle = `rgba(255, 255, 255, ${Math.abs(this.alpha)})`;
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

class City {
    constructor(x) {
        this.x = x;
        this.y = GAME_HEIGHT - 15; // Ground level
        this.width = 40;
        this.height = 20;
        this.alive = true;
    }
    draw(ctx) {
        if (!this.alive) return;
        
        ctx.fillStyle = COLORS.cityAlive;
        // Draw simplified city skyline
        ctx.fillRect(this.x - 15, this.y, 5, -10);
        ctx.fillRect(this.x - 8, this.y, 6, -15);
        ctx.fillRect(this.x + 2, this.y, 8, -12);
        ctx.fillRect(this.x + 12, this.y, 4, -8);
        
        // Windows
        ctx.fillStyle = '#AAFFAA';
        if (Math.random() > 0.9) ctx.fillRect(this.x - 7, this.y - 10, 2, 2);
        if (Math.random() > 0.9) ctx.fillRect(this.x + 4, this.y - 8, 2, 2);
    }
}

class Battery {
    constructor() {
        this.x = GAME_WIDTH / 2;
        this.y = GAME_HEIGHT - 10;
        this.ammo = 30; // Classic starts with limited ammo
    }
    
    draw(ctx) {
        ctx.fillStyle = COLORS.battery;
        // Base
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - 20, this.y + 10);
        ctx.lineTo(this.x + 20, this.y + 10);
        ctx.fill();
        
        // Silos (Visual)
        ctx.fillStyle = '#005500';
        ctx.fillRect(this.x - 15, this.y - 5, 8, 5);
        ctx.fillRect(this.x + 7, this.y - 5, 8, 5);

        // Ammo readout
        if (this.ammo > 0) {
            ctx.fillStyle = '#00FF00';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(this.ammo, this.x, this.y + 25);
        } else {
            ctx.fillStyle = '#FF0000';
            ctx.fillText("EMPTY", this.x, this.y + 25);
        }
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 3;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = 0.02 + Math.random() * 0.03;
        this.color = color || '#FFFF00';
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
    }
    
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 2, 2);
        ctx.globalAlpha = 1.0;
    }
}

class Explosion {
    constructor(x, y, maxRadius = 40) {
        this.x = x;
        this.y = y;
        this.r = 1;
        this.maxR = maxRadius;
        this.growing = true;
        this.active = true; // Can destroy enemies
        this.colorStep = 0;
    }
    
    update() {
        if (this.growing) {
            this.r += 1.5; // Expansion speed
            if (this.r >= this.maxR) this.growing = false;
        } else {
            this.r -= 0.3; // Contraction speed
            if (this.r <= 0) this.active = false;
        }
    }
    
    draw(ctx) {
        if (!this.active) return;

        // Color transition: White -> Red -> Blue
        let color;
        const ratio = this.r / this.maxR;
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        
        if (ratio > 0.7) {
            ctx.fillStyle = COLORS.explosionCore; // White center
            ctx.shadowBlur = 20;
            ctx.shadowColor = "white";
        } else if (ratio > 0.3) {
            ctx.fillStyle = COLORS.explosionMid; // Red ring
            ctx.shadowBlur = 10;
            ctx.shadowColor = "red";
        } else {
            ctx.fillStyle = COLORS.explosionOuter; // Blue fade
            ctx.shadowBlur = 0;
        }
        
        ctx.fill();
        ctx.shadowBlur = 0; // Reset
        
        // Inner flash effect
        if (this.growing && this.r < 10) {
             ctx.fillStyle = '#FFFFFF';
             ctx.beginPath();
             ctx.arc(this.x, this.y, this.r * 0.5, 0, Math.PI*2);
             ctx.fill();
        }
    }
}

class Missile {
    constructor(startX, startY, targetX, targetY, isEnemy) {
        this.startX = startX;
        this.startY = startY;
        this.x = startX;
        this.y = startY;
        this.targetX = targetX;
        this.targetY = targetY;
        
        this.isEnemy = isEnemy;
        this.active = true;
        this.speed = isEnemy ? (0.5 + Math.random() * 0.5) : 2.5; // Friendly faster
        
        // Calculate velocity vector
        const dx = targetX - startX;
        const dy = targetY - startY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        this.vx = (dx / dist) * this.speed;
        this.vy = (dy / dist) * this.speed;
        
        // Trail history
        this.trail = [];
        this.maxTrail = 10;

        // Special Enemy Logic: Splitting
        if (isEnemy && Math.random() < 0.3 + (gameState.level * 0.05)) {
            this.canSplit = true;
            this.splitTriggered = false;
            this.splitY = startY - (Math.random() * 100 + 50); // Height to split
        } else {
            this.canSplit = false;
        }
    }

    update() {
        // Update position
        this.x += this.vx;
        this.y += this.vy;

        // Trail logic
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > this.maxTrail) this.trail.shift();

        // Enemy Logic: Splitting
        if (this.isEnemy && this.canSplit && !this.splitTriggered && this.y < this.splitY) {
            this.split();
        }

        // Check bounds / Impact
        if (this.isEnemy) {
            // Hit Ground or City?
            if (this.y >= GAME_HEIGHT - 20 || this.checkCityHit()) {
                this.explode(true); // Boom
            }
        } else {
            // Friendly reached target?
            const dx = this.x - this.targetX;
            const dy = this.y - this.targetY;
            if (Math.sqrt(dx*dx + dy*dy) < 5) {
                this.explode(false);
            }
        }
    }

    checkCityHit() {
        // Simple box collision for cities
        for (let city of gameState.cities) {
            if (!city.alive) continue;
            if (this.x > city.x - 20 && this.x < city.x + 20 && this.y >= city.y - 10) {
                city.alive = false;
                createExplosion(this.x, this.y, 60); // Big explosion
                Sound.sfxHit();
                checkGameOver();
                return true;
            }
        }
        return false;
    }

    split() {
        this.active = false; // Kill parent
        
        // Create 3 warheads
        for (let i = -1; i <= 1; i++) {
            let newTargetX = this.targetX + (i * 100);
            // Clamp target to screen
            if (newTargetX < 50) newTargetX = 50;
            if (newTargetX > GAME_WIDTH - 50) newTargetX = GAME_WIDTH - 50;

            let m = new Missile(this.x, this.y, newTargetX, GAME_HEIGHT - 20, true);
            // Make warheads slightly faster
            m.speed *= 1.2; 
            gameState.missiles.push(m);
        }
        
        // Visual flair for split
        for(let k=0; k<5; k++) {
             gameState.particles.push(new Particle(this.x, this.y, '#FFF'));
        }
    }

    explode(isBig) {
        this.active = false;
        const radius = isBig ? 50 : 30;
        createExplosion(this.x, this.y, radius);
        
        if (isBig) {
            // Check for chain reaction on other enemies
            gameState.missiles.forEach(m => {
                if (m.isEnemy && m.active) {
                    const dist = Math.hypot(m.x - this.x, m.y - this.y);
                    if (dist < radius + 20) {
                        m.explode(true); // Chain reaction!
                    }
                }
            });
        } else {
             Sound.sfxExplosion();
        }
    }

    draw(ctx) {
        ctx.beginPath();
        if (this.trail.length > 0) {
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (let p of this.trail) ctx.lineTo(p.x, p.y);
        }
        
        ctx.strokeStyle = this.isEnemy ? COLORS.missileEnemy : COLORS.missileFriendly;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Head
        ctx.fillStyle = '#FFF';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI*2);
        ctx.fill();
    }
}

// --- GAME LOGIC FUNCTIONS ---

function createExplosion(x, y, r) {
    gameState.explosions.push(new Explosion(x, y, r));
}

function spawnEnemy() {
    // Logic to determine target
    let targetX;
    
    // 70% chance to aim at a city, 30% random ground
    const liveCities = gameState.cities.filter(c => c.alive);
    
    if (liveCities.length > 0 && Math.random() < 0.7) {
        const targetCity = liveCities[Math.floor(Math.random() * liveCities.length)];
        targetX = targetCity.x;
    } else {
        // Aim for ground between cities
        targetX = 50 + Math.random() * (GAME_WIDTH - 100);
    }

    const startX = 20 + Math.random() * (GAME_WIDTH - 40);
    const startY = 10; // Top of screen

    gameState.missiles.push(new Missile(startX, startY, targetX, GAME_HEIGHT - 20, true));
}

function fireMissile() {
    if (!gameState.running) return;
    
    // Check ammo
    let battery = new Battery(); // Just to access logic, or store globally. 
    // Let's assume we have infinite ammo for simplicity in this version, 
    // OR implement the classic limited ammo system.
    // Classic: You get ammo back at start of wave.
    
    if (gameState.ammo <= 0) {
        // Click sound for empty?
        return;
    }

    gameState.ammo--;
    Sound.sfxLaunch();
    
    const batteryX = GAME_WIDTH / 2;
    const batteryY = GAME_HEIGHT - 10;
    
    gameState.missiles.push(new Missile(batteryX, batteryY, gameState.crosshair.x, gameState.crosshair.y, false));
}

function checkCollisions() {
    // Check if Enemy Missiles hit Active Explosions
    for (let m of gameState.missiles) {
        if (!m.active || m.isEnemy) continue; // Only check active enemies against explosions

        for (let e of gameState.explosions) {
            if (!e.active) continue;
            
            const dist = Math.hypot(m.x - e.x, m.y - e.y);
            if (dist < e.r + 5) { // +5 tolerance
                m.explode(false); // Destroy enemy
                
                // Score logic
                gameState.score += 25; // Base score
                updateUI();
                
                // Particles
                for(let k=0; k<8; k++) {
                    gameState.particles.push(new Particle(m.x, m.y, '#FFF'));
                }
            }
        }
    }
}

function checkWaveStatus() {
    if (!gameState.waveInProgress) return;

    const activeEnemies = gameState.missiles.filter(m => m.isEnemy && m.active).length;
    
    // If no enemies left to spawn and no active enemies
    if (gameState.enemiesToSpawn <= 0 && activeEnemies === 0) {
        endWave();
    }
}

function startNextWave() {
    gameState.level++;
    gameState.ammo += 20 + (gameState.level * 5); // Refill ammo
    
    // Bonus cities logic
    if (gameState.score > 1500 && gameState.cities.filter(c=>c.alive).length < 6) {
        // Find a dead city and revive it? 
        // Original didn't really revive, but gave new ones. 
        // We'll just keep count or add to score for simplicity.
    }

    startWave();
}

function endWave() {
    gameState.waveInProgress = false;
    
    // Bonus points for cities saved
    const liveCities = gameState.cities.filter(c => c.alive).length;
    gameState.score += (liveCities * 100);
    updateUI();

    setTimeout(startNextWave, 2000); // Delay before next wave
}

function startWave() {
    gameState.waveInProgress = true;
    
    // Difficulty scaling
    const count = 5 + Math.floor(gameState.level * 2.5);
    gameState.enemiesToSpawn = count;
    
    console.log(`Starting Wave ${gameState.level} with ${count} enemies.`);
}

function checkGameOver() {
    const liveCities = gameState.cities.filter(c => c.alive).length;
    if (liveCities === 0) {
        gameOver();
    }
}

function gameOver() {
    gameState.running = false;
    Sound.sfxGameOver();
    
    document.getElementById('game-over-screen').style.display = 'block';
    document.getElementById('finalScoreEl').innerText = gameState.score;
    
    if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem('mc_highscore', gameState.highScore);
    }
}

function updateUI() {
    document.getElementById('scoreEl').innerText = gameState.score;
    document.getElementById('highScoreEl').innerText = gameState.highScore;
    
    const liveCities = gameState.cities.filter(c => c.alive).length;
    let cityStr = "";
    for(let i=0; i<6; i++) {
        if (i < liveCities) cityStr += "I ";
        else cityStr += ". ";
    }
    document.getElementById('citiesEl').innerText = cityStr;
}

// --- MAIN LOOP ---

function update() {
    if (!gameState.running) return;

    // Spawning Logic
    if (gameState.waveInProgress && gameState.enemiesToSpawn > 0) {
        gameState.spawnTimer++;
        // Spawn rate increases with level
        const spawnRate = Math.max(20, 100 - (gameState.level * 5)); 
        
        if (gameState.spawnTimer > spawnRate) {
            spawnEnemy();
            gameState.enemiesToSpawn--;
            gameState.spawnTimer = 0;
        }
    }

    // Update Entities
    gameState.missiles.forEach(m => m.update());
    gameState.explosions.forEach(e => e.update());
    gameState.particles.forEach(p => p.update());

    // Cleanup Inactive
    gameState.missiles = gameState.missiles.filter(m => m.active);
    gameState.explosions = gameState.explosions.filter(e => e.active);
    gameState.particles = gameState.particles.filter(p => p.life > 0);

    checkCollisions();
    checkWaveStatus();
}

function draw() {
    // Clear Screen
    ctx.fillStyle = COLORS.sky;
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Draw Stars
    gameState.stars.forEach(s => s.draw(ctx));

    // Draw Ground/Horizon
    ctx.fillStyle = COLORS.ground;
    ctx.fillRect(0, GAME_HEIGHT - 20, GAME_WIDTH, 20);
    
    // Horizon Line Glow
    const gradient = ctx.createLinearGradient(0, GAME_HEIGHT-50, 0, GAME_HEIGHT);
    gradient.addColorStop(0, "transparent");
    gradient.addColorStop(1, "#0000AA");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, GAME_HEIGHT - 50, GAME_WIDTH, 30);

    // Draw Cities
    gameState.cities.forEach(c => c.draw(ctx));

    // Draw Battery
    const b = new Battery();
    b.ammo = gameState.ammo; // Sync
    b.draw(ctx);

    // Draw Missiles
    gameState.missiles.forEach(m => m.draw(ctx));

    // Draw Explosions
    gameState.explosions.forEach(e => e.draw(ctx));
    
    // Draw Particles
    gameState.particles.forEach(p => p.draw(ctx));

    // Draw Crosshair
    drawCrosshair(ctx, gameState.crosshair.x, gameState.crosshair.y);
}

function drawCrosshair(ctx, x, y) {
    ctx.strokeStyle = '#FF0000';
    ctx.lineWidth = 2;
    
    // Circle
    ctx.beginPath();
    ctx.arc(x, y, 15, 0, Math.PI * 2);
    ctx.stroke();

    // Lines
    ctx.beginPath();
    ctx.moveTo(x - 20, y); ctx.lineTo(x + 20, y);
    ctx.moveTo(x, y - 20); ctx.lineTo(x, y + 20);
    ctx.stroke();

    // Center dot
    ctx.fillStyle = '#FF0000';
    ctx.beginPath();
    ctx.arc(x, y, 2, 0, Math.PI*2);
    ctx.fill();
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// --- INPUT HANDLING ---

// Mouse
canvas.addEventListener('mousemove', (e) => {
    if (!gameState.running) return;
    const rect = canvas.getBoundingClientRect();
    gameState.crosshair.x = e.clientX - rect.left;
    gameState.crosshair.y = e.clientY - rect.top;
    gameState.mouseControl = true;
});

canvas.addEventListener('mousedown', (e) => {
    if(gameState.running) fireMissile();
});

// Keyboard
const keys = {};
window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    
    // Space to fire
    if (e.code === 'Space' && gameState.running) {
        fireMissile();
        e.preventDefault(); // Stop scrolling
    }
});

window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});

// Keyboard Movement Logic (in loop for smoothness)
setInterval(() => {
    if (!gameState.running) return;
    
    let moved = false;
    const speed = 5;

    // If using keyboard, disable mouse lock temporarily or just override
    if (keys['ArrowUp'] || keys['ArrowDown'] || keys['ArrowLeft'] || keys['ArrowRight']) {
        gameState.mouseControl = false;
    }

    if (!gameState.mouseControl) {
        if (keys['ArrowLeft']) { gameState.crosshair.x -= speed; moved=true; }
        if (keys['ArrowRight']) { gameState.crosshair.x += speed; moved=true; }
        if (keys['ArrowUp']) { gameState.crosshair.y -= speed; moved=true; }
        if (keys['ArrowDown']) { gameState.crosshair.y += speed; moved=true; }

        // Clamp
        if (gameState.crosshair.x < 0) gameState.crosshair.x = 0;
        if (gameState.crosshair.x > GAME_WIDTH) gameState.crosshair.x = GAME_WIDTH;
        if (gameState.crosshair.y < 0) gameState.crosshair.y = 0;
        if (gameState.crosshair.y > GAME_HEIGHT - 20) gameState.crosshair.y = GAME_HEIGHT - 20;
    }
}, 16);


// --- INITIALIZATION ---

function initGame() {
    // Generate Stars
    for(let i=0; i<100; i++) gameState.stars.push(new Star());
    
    updateUI();
}

function startGame() {
    initAudio();
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('game-over-screen').style.display = 'none';
    
    // Reset State
    gameState.score = 0;
    gameState.level = 0; // Will become 1 in startWave
    gameState.ammo = 30;
    gameState.cities = [];
    gameState.missiles = [];
    gameState.explosions = [];
    gameState.particles = [];
    
    // Create Cities (6 cities)
    const spacing = GAME_WIDTH / 7;
    for(let i=1; i<=6; i++) {
        gameState.cities.push(new City(i * spacing));
    }
    
    gameState.running = true;
    updateUI();
    startNextWave(); // Starts Wave 1
}

function resetGame() {
    startGame();
}

// Start the render loop immediately (shows stars)
initGame();
loop();

</script>
</body>
</html>