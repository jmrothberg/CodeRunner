<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q*bert - Arcade Classic</title>
    <style>
        :root {
            --bg-color: #111;
            --ui-font: 'Courier New', Courier, monospace;
            --accent-color: #ff0055;
            --text-shadow: 2px 2px 0px #000;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: white;
            font-family: var(--ui-font);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background: radial-gradient(circle, #2a2a55 0%, #000000 100%);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            text-shadow: var(--text-shadow);
            font-weight: bold;
        }

        .score-box, .lives-box, .level-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid #444;
        }

        /* Start / Game Over Screens */
        #menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            font-size: 60px;
            color: #ffcc00;
            text-shadow: 4px 4px 0 #d35400, -2px -2px 0 #fff;
            margin-bottom: 20px;
            transform: skew(-10deg);
        }

        .btn {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            border: 4px solid #fff;
            color: white;
            padding: 15px 40px;
            font-size: 24px;
            font-family: var(--ui-font);
            cursor: pointer;
            text-transform: uppercase;
            font-weight: bold;
            box-shadow: 0 6px 0 #922b21, 0 10px 10px rgba(0,0,0,0.5);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #922b21, 0 4px 4px rgba(0,0,0,0.5);
        }

        .controls-info {
            margin-top: 30px;
            text-align: center;
            color: #aaa;
            line-height: 1.6;
        }

        .key-badge {
            display: inline-block;
            background: #444;
            padding: 2px 8px;
            border-radius: 4px;
            border-bottom: 2px solid #222;
            color: white;
            font-weight: bold;
            margin: 0 2px;
        }

        /* Floating text for scores */
        .floating-text {
            position: absolute;
            color: yellow;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 1px 1px 0 #000;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }

        #message-area {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 40px;
            color: #fff;
            text-shadow: 3px 3px 0 #000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <!-- HUD -->
    <div class="ui-layer">
        <div class="hud-top">
            <div class="score-box">SCORE: <span id="scoreVal">0</span></div>
            <div class="level-box">LEVEL: <span id="levelVal">1</span></div>
            <div class="lives-box">LIVES: <span id="livesVal">3</span></div>
        </div>
    </div>

    <!-- Floating Message -->
    <div id="message-area"></div>

    <!-- Menu / Game Over -->
    <div id="menu-overlay">
        <h1>Q*BERT</h1>
        <p style="color: #eee; margin-bottom: 20px;">REMAKE EDITION</p>
        <button class="btn" id="startBtn">INSERT COIN (START)</button>
        
        <div class="controls-info">
            <p>USE <span class="key-badge">Q</span> <span class="key-badge">W</span> <span class="key-badge">E</span> <span class="key-badge">A</span> FOR DIAGONAL MOVES</p>
            <p>OR ARROW KEYS: <span class="key-badge">↑</span> <span class="key-badge">↓</span> <span class="key-badge">←</span> <span class="key-badge">→</span></p>
            <p style="font-size: 0.9em; margin-top:10px;">CHANGE ALL CUBES TO THE TARGET COLOR.<br>AVOID COILY, UGG & WRONGWAY.</p>
        </div>
    </div>
</div>

<script>
/**
 * Q*BERT GAME LOGIC
 * 
 * Architecture:
 * - Game Loop: Handles update and draw cycles.
 * - Input Manager: Maps keyboard to diagonal directions.
 * - Audio Synth: Generates arcade sounds using Web Audio API (no external files).
 * - Entities: Qbert, Enemies (Coily, Slick, Sam, Ugg, Wrongway), Discs.
 * - Map System: Isometric grid logic.
 */

// --- CONSTANTS & CONFIG ---
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const FPS = 60;

// Colors
const PALETTE = {
    bgTop: '#2a2a55',
    bgBottom: '#000000',
    cubeFace1: '#d35400', // Dark Orange (Left)
    cubeFace2: '#e67e22', // Light Orange (Right)
    cubeFace3: '#f39c12', // Top (Yellowish)
    cubeTarget: '#3498db', // Blue (Target color)
    qbert: '#ff0055',
    coily: '#27ae60',
    slick: '#2ecc71',
    sam: '#bdc3c7',
    ugg: '#9b59b6',
    wrongway: '#8e44ad',
    disc: '#f1c40f'
};

// Isometric Config
const TILE_WIDTH = 50;
const TILE_HEIGHT = 25; // Half of width for 2:1 iso ratio
const PYRAMID_ROWS = 7;

// Game States
const STATE = {
    MENU: 0,
    PLAYING: 1,
    LEVEL_TRANSITION: 2,
    GAME_OVER: 3,
    WAITING_FOR_DISC_RIDE: 4
};

// --- AUDIO SYSTEM (Web Audio API) ---
const AudioSys = {
    ctx: null,
    
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
    },

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },

    playJump() {
        // Classic "Swatch" sound
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.frequency.setValueAtTime(200, t);
        osc.frequency.linearRampToValueAtTime(400, t + 0.1);
        
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.1);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(t + 0.1);
    },

    playLand() {
        this.playTone(100, 'square', 0.05, 0.15);
    },

    playChangeColor() {
        // High pitched blip
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, t);
        osc.frequency.linearRampToValueAtTime(900, t + 0.1);
        
        gain.gain.setValueAtTime(0.05, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.1);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(t + 0.1);
    },

    playDeath() {
        // Falling noise
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, t);
        osc.frequency.exponentialRampToValueAtTime(50, t + 0.8);
        
        gain.gain.setValueAtTime(0.2, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.8);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(t + 0.8);
    },

    playCatch() {
        this.playTone(800, 'square', 0.1, 0.1);
        setTimeout(() => this.playTone(1200, 'square', 0.2, 0.1), 100);
    }
};

// --- INPUT HANDLING ---
const Input = {
    keys: {},
    
    init() {
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);
    },

    getDirection() {
        // QWERTY / Arrow mapping
        // Up-Left (Q or 7), Up-Right (E or 9)
        // Down-Left (A or 1), Down-Right (D or 3) - Wait, standard iso controls:
        
        // Let's use intuitive diagonal mapping relative to screen
        // Q: Top Left, W: Top Right? No, let's stick to classic layout.
        // Classic Arcade: Joystick. 
        // PC Mapping often used:
        // 7 (Home): Up-Left | 9 (PgUp): Up-Right
        // 1 (End): Down-Left | 3 (PgDn): Down-Right
        
        // Let's support QWEASD and Arrows
        if (this.keys['KeyQ'] || this.keys['Numpad7']) return { x: -1, y: -1 }; // Up Left
        if (this.keys['KeyE'] || this.keys['Numpad9']) return { x: 1, y: -1 };  // Up Right
        if (this.keys['KeyA'] || this.keys['Numpad1']) return { x: -1, y: 1 };  // Down Left
        if (this.keys['KeyD'] || this.keys['Numpad3']) return { x: 1, y: 1 };   // Down Right
        
        // Arrow keys approximation
        if (this.keys['ArrowUp']) return { x: 0, y: -1 }; // Just Up (handled by logic to pick side)
        if (this.keys['ArrowDown']) return { x: 0, y: 1 };
        
        return null;
    }
};

// --- MATH & UTILS ---
function lerp(start, end, t) {
    return start * (1 - t) + end * t;
}

// Convert Grid Coords to Screen Coords
// Grid: Row (0-6), Col (0-Row)
// Screen: Center X, Y
function gridToScreen(row, col) {
    // Calculate offset based on pyramid center
    const centerX = CANVAS_WIDTH / 2;
    const centerY = 150; // Top of pyramid

    // Isometric projection math
    // x moves right-down and right-up
    // y moves down
    
    // The grid is triangular.
    // Row increases downwards. Col increases to the right within the row.
    
    // Logic:
    // Each step 'down' (row++) adds half tile width X, full tile height Y
    // Each step 'right' (col++) adds full tile width X, 0 Y
    
    const x = centerX + (col - row / 2) * TILE_WIDTH;
    const y = centerY + row * (TILE_HEIGHT * 1.5); // 1.5 because cubes have height
    
    return { x, y };
}

// --- CLASSES ---

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.life = 1.0;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.05;
    }
    
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 4, 4);
        ctx.globalAlpha = 1.0;
    }
}

class Cube {
    constructor(row, col) {
        this.row = row;
        this.col = col;
        this.state = 0; // 0: Start Color, 1: Target Color
        this.targetState = 1;
        
        // Animation props
        this.colorLerp = 0; 
        this.pulse = 0;
    }

    reset() {
        this.state = 0;
        this.colorLerp = 0;
    }
    
    change() {
        if (this.state !== this.targetState) {
            this.state = this.targetState;
            AudioSys.playChangeColor();
            return true; // Changed
        } else {
            // In later levels, touching a finished cube might revert it? 
            // Classic Q*bert: Some rounds require 2 hops. For simplicity here: 1 hop to finish.
            // But let's add the "revert" mechanic for higher difficulty if needed.
            // For now, simple toggle logic or just stay done.
            return false;
        }
    }

    draw(ctx) {
        const pos = gridToScreen(this.row, this.col);
        
        // Draw Cube (Isometric)
        // Top Face
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y - TILE_HEIGHT); // Top tip
        ctx.lineTo(pos.x + TILE_WIDTH/2, pos.y - TILE_HEIGHT/2); // Right corner
        ctx.lineTo(pos.x, pos.y); // Bottom center
        ctx.lineTo(pos.x - TILE_WIDTH/2, pos.y - TILE_HEIGHT/2); // Left corner
        ctx.closePath();
        
        // Color Logic
        if (this.state === 0) {
            ctx.fillStyle = PALETTE.cubeFace3;
        } else {
            ctx.fillStyle = PALETTE.cubeTarget;
        }
        
        // Add a little pulse if active
        if (this.state === this.targetState && Game.levelCompleteCheck()) {
             this.pulse += 0.1;
             const glow = Math.sin(this.pulse) * 20;
             ctx.filter = `brightness(${100 + glow}%)`;
        }
        
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.filter = 'none';

        // Left Face
        ctx.beginPath();
        ctx.moveTo(pos.x - TILE_WIDTH/2, pos.y - TILE_HEIGHT/2);
        ctx.lineTo(pos.x, pos.y);
        ctx.lineTo(pos.x, pos.y + TILE_HEIGHT); // Bottom point (cube depth)
        ctx.lineTo(pos.x - TILE_WIDTH/2, pos.y + TILE_HEIGHT/2);
        ctx.closePath();
        ctx.fillStyle = PALETTE.cubeFace1;
        ctx.fill();
        ctx.stroke();

        // Right Face
        ctx.beginPath();
        ctx.moveTo(pos.x + TILE_WIDTH/2, pos.y - TILE_HEIGHT/2);
        ctx.lineTo(pos.x, pos.y);
        ctx.lineTo(pos.x, pos.y + TILE_HEIGHT);
        ctx.lineTo(pos.x + TILE_WIDTH/2, pos.y + TILE_HEIGHT/2);
        ctx.closePath();
        ctx.fillStyle = PALETTE.cubeFace2;
        ctx.fill();
        ctx.stroke();
    }
}

class Entity {
    constructor(row, col) {
        this.row = row;
        this.col = col;
        this.x = 0; // Screen X
        this.y = 0; // Screen Y
        this.z = 0; // Height for jumping
        
        this.targetRow = row;
        this.targetCol = col;
        
        this.isMoving = false;
        this.moveProgress = 0;
        this.speed = 0.1; // Jump speed
        
        this.startPos = {x:0, y:0};
        this.endPos = {x:0, y:0};
        
        this.facing = 'downRight'; // Visual direction
    }
    
    update() {
        if (this.isMoving) {
            this.moveProgress += this.speed;
            
            // Parabolic arc for jump
            const height = Math.sin(this.moveProgress * Math.PI) * 30;
            this.z = height;

            if (this.moveProgress >= 1) {
                this.finishMove();
            } else {
                // Lerp X and Y
                this.x = lerp(this.startPos.x, this.endPos.x, this.moveProgress);
                this.y = lerp(this.startPos.y, this.endPos.y, this.moveProgress);
            }
        } else {
            // Idle position update (in case of resize or something)
            const pos = gridToScreen(this.row, this.col);
            this.x = pos.x;
            this.y = pos.y - TILE_HEIGHT/2; // Sit on top
        }
    }
    
    startMove(dRow, dCol) {
        if (this.isMoving) return false;
        
        const nextR = this.row + dRow;
        const nextC = this.col + dCol;
        
        // Boundary Check
        if (nextR < 0 || nextR >= PYRAMID_ROWS || nextC < 0 || nextC > nextR) {
            return false; // Invalid move
        }
        
        this.targetRow = nextR;
        this.targetCol = nextC;
        
        const currentScreen = gridToScreen(this.row, this.col);
        const targetScreen = gridToScreen(nextR, nextC);
        
        this.startPos = { x: currentScreen.x, y: currentScreen.y - TILE_HEIGHT/2 };
        this.endPos = { x: targetScreen.x, y: targetScreen.y - TILE_HEIGHT/2 };
        
        // Adjust start Y to be on top of cube
        this.startPos.y += TILE_HEIGHT; 
        this.endPos.y += TILE_HEIGHT;

        this.isMoving = true;
        this.moveProgress = 0;
        
        return true;
    }
    
    finishMove() {
        this.row = this.targetRow;
        this.col = this.targetCol;
        this.isMoving = false;
        this.z = 0;
        const pos = gridToScreen(this.row, this.col);
        this.x = pos.x;
        this.y = pos.y - TILE_HEIGHT/2 + TILE_HEIGHT; // Land on top
        
        AudioSys.playLand();
    }
    
    draw(ctx) {
        // Base draw method
        ctx.fillStyle = 'white';
        ctx.fillRect(this.x - 10, this.y - 20 - this.z, 20, 20);
    }
}

class Qbert extends Entity {
    constructor() {
        super(0, 0); // Starts at top
        this.noseDir = 1; // 1 right, -1 left
        this.isDead = false;
    }

    update() {
        super.update();
        
        if (!this.isMoving && !this.isDead) {
            const dir = Input.getDirection();
            
            // Map input to grid changes
            // Grid: Row increases down. Col increases right.
            // Up-Left (Q): row - 1, col stays same? No.
            // Visual:
            //   / \ 
            //  /   \
            // Top is (0,0).
            // Down-Right is (row+1, col+1).
            // Down-Left is (row+1, col).
            
            let dRow = 0;
            let dCol = 0;
            
            if (dir) {
                if (dir.x === -1 && dir.y === -1) { // Up Left
                    dRow = -1; 
                    dCol = 0;
                    this.noseDir = -1;
                } else if (dir.x === 1 && dir.y === -1) { // Up Right
                    dRow = -1;
                    dCol = -1; // Wait, logic check.
                    // If I am at (1,1), Up-Right goes to (0,0).
                    // Row decreases by 1. Col decreases by 1? 
                    // Let's trace: (0,0) -> Down Right is (1,1). So Up Right from (1,1) is (0,0).
                    // Correct.
                    this.noseDir = 1;
                } else if (dir.x === -1 && dir.y === 1) { // Down Left
                    dRow = 1;
                    dCol = 0;
                    this.noseDir = -1;
                } else if (dir.x === 1 && dir.y === 1) { // Down Right
                    dRow = 1;
                    dCol = 1;
                    this.noseDir = 1;
                }
                
                if (dRow !== 0 || dCol !== 0) {
                    if (this.startMove(dRow, dCol)) {
                        AudioSys.playJump();
                    } else {
                        // Attempted to jump off edge
                        this.die();
                    }
                }
            }
        }
    }

    die() {
        if (this.isDead || Game.state === STATE.WAITING_FOR_DISC_RIDE) return;
        
        this.isDead = true;
        AudioSys.playDeath();
        
        // Simple fall animation logic handled in draw/update
        // For now, just trigger game over life loss
        setTimeout(() => {
            Game.loseLife();
        }, 1000);
    }

    draw(ctx) {
        if (this.isDead && this.y < CANVAS_HEIGHT + 50) {
            this.y += 10; // Fall down
            this.x += (Math.random() - 0.5) * 5;
        }
        
        ctx.save();
        ctx.translate(this.x, this.y - this.z);
        
        // Draw Q*bert (Orange ball with nose and feet)
        
        // Body
        ctx.fillStyle = PALETTE.qbert;
        ctx.beginPath();
        ctx.arc(0, -15, 14, 0, Math.PI * 2);
        ctx.fill();
        
        // Nose (Snout)
        ctx.fillStyle = '#ffccaa';
        ctx.beginPath();
        const noseX = this.noseDir === 1 ? 8 : -8;
        ctx.ellipse(noseX, -15, 6, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(-5 + (this.noseDir*2), -20, 4, 0, Math.PI * 2);
        ctx.arc(5 + (this.noseDir*2), -20, 4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(-5 + (this.noseDir*3), -20, 1.5, 0, Math.PI * 2);
        ctx.arc(5 + (this.noseDir*3), -20, 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Feet
        ctx.fillStyle = '#ffccaa';
        ctx.beginPath();
        ctx.ellipse(-8, 0, 4, 6, 0.5, 0, Math.PI*2);
        ctx.ellipse(8, 0, 4, 6, -0.5, 0, Math.PI*2);
        ctx.fill();

        // Collar
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-10, -12);
        ctx.lineTo(10, -12);
        ctx.stroke();
        
        ctx.restore();
    }
}

class Enemy extends Entity {
    constructor(row, col, type) {
        super(row, col);
        this.type = type; // 'coily', 'slick', 'sam', 'ugg', 'wrongway'
        this.active = false;
        this.timer = 0;
        
        // Config based on type
        switch(type) {
            case 'coily': this.speed = 0.08; break;
            case 'slick': 
            case 'sam': this.speed = 0.12; break; // Fast
            case 'ugg':
            case 'wrongway': this.speed = 0.06; break; // Slow
        }
    }

    update() {
        if (!this.active) return;
        
        super.update();
        
        if (!this.isMoving) {
            this.timer++;
            
            // Movement frequency based on difficulty
            const moveThreshold = Math.max(10, 60 - (Game.level * 5));
            
            if (this.timer > moveThreshold) {
                this.moveAI();
                this.timer = 0;
            }
        }
    }
    
    moveAI() {
        let dRow = 0;
        let dCol = 0;
        
        // Specific AI behaviors
        if (this.type === 'coily') {
            // Coily chases Qbert
            // Simple logic: reduce row/col distance
            if (Game.qbert.row > this.row) dRow = 1;
            else if (Game.qbert.row < this.row) dRow = -1;
            
            if (Game.qbert.col > this.col) dCol = 1;
            else if (Game.qbert.col < this.col) dCol = -1;
            
            // Coily can only move diagonally down or up? 
            // In original, Coily bounces then chases.
            // Simplified: Moves towards Qbert validly.
        } 
        else if (this.type === 'slick' || this.type === 'sam') {
            // Move randomly downwards
            dRow = 1;
            dCol = Math.random() > 0.5 ? 0 : 1;
            
            // If at bottom, reset
            if (this.row >= PYRAMID_ROWS - 1) {
                this.active = false; 
                return;
            }
        }
        else if (this.type === 'ugg' || this.type === 'wrongway') {
            // Move along sides randomly
            const dirs = [
                {r:0, c:-1}, {r:0, c:1} // Horizontal-ish on grid? No.
            ];
            
            // Ugg/Wrongway move on the "sides" of the cubes (row+1, col) or (row+1, col-1)?
            // They are actually on the sides of the pyramid blocks.
            // For this 2D iso implementation, we treat them as entities hopping on valid grid spots
            // but maybe restricted to edges?
            
            // Simplified: Random valid move
            const moves = [
                {r: -1, c: 0}, {r: -1, c: -1},
                {r: 1, c: 0}, {r: 1, c: 1}
            ];
            const m = moves[Math.floor(Math.random() * moves.length)];
            dRow = m.r;
            dCol = m.c;
        }
        
        // Check validity
        if (dRow !== 0 || dCol !== 0) {
             // Coily special check: he starts as an egg, then hatches.
             // We skip egg phase for simplicity, spawn as snake at top or bottom?
             // Original spawns at top as ball, bounces down, turns into snake.
             
             if (this.startMove(dRow, dCol)) {
                 // Move successful
             } else {
                 // Hit edge or invalid
                 if (this.type === 'ugg' || this.type === 'wrongway') {
                     // They fall off? No, they walk on sides. 
                     // In our grid logic, if move fails, they just pick another.
                     this.moveAI(); 
                 } else if (this.type === 'coily') {
                     // Coily falls off if he chases Qbert off edge
                     this.active = false;
                     Game.addScore(500);
                 }
             }
        }
    }

    draw(ctx) {
        if (!this.active) return;
        
        ctx.save();
        ctx.translate(this.x, this.y - this.z);
        
        if (this.type === 'coily') {
            // Draw Snake
            ctx.fillStyle = PALETTE.coily;
            // Coiled body
            for(let i=0; i<3; i++) {
                ctx.beginPath();
                ctx.arc(0, 5 + (i*8), 10 - i, 0, Math.PI*2);
                ctx.fill();
            }
            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(-4, -5, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(4, -5, 3, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'black'; ctx.fillRect(-3, -6, 2, 2); ctx.fillRect(3, -6, 2, 2);
        }
        else if (this.type === 'slick' || this.type === 'sam') {
            // Green Balls
            ctx.fillStyle = this.type === 'slick' ? PALETTE.slick : PALETTE.sam;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI*2);
            ctx.fill();
            // Glasses for Sam?
            if (this.type === 'sam') {
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeRect(-8, -4, 16, 6);
            }
        }
        else {
            // Ugg / Wrongway
            ctx.fillStyle = this.type === 'ugg' ? PALETTE.ugg : PALETTE.wrongway;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI*2);
            ctx.fill();
            // Angry eyes
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(-6, -4); ctx.lineTo(-2, -2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(6, -4); ctx.lineTo(2, -2); ctx.stroke();
        }
        
        ctx.restore();
    }
}

class Disc {
    constructor(row, side) { // side: -1 (left), 1 (right)
        this.row = row;
        this.side = side; 
        this.active = true;
        
        // Calculate position floating beside the pyramid
        const gridPos = gridToScreen(row, side === -1 ? 0 : row);
        this.x = gridPos.x + (side * TILE_WIDTH);
        this.y = gridPos.y;
    }
    
    draw(ctx) {
        if (!this.active) return;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Draw Disc
        ctx.fillStyle = PALETTE.disc;
        ctx.beginPath();
        ctx.ellipse(0, 0, 15, 8, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Hover animation
        const hover = Math.sin(Date.now() / 200) * 5;
        ctx.translate(0, hover - 20); // Float above cube
        
        ctx.restore();
    }
}

// --- GAME MANAGER ---
const Game = {
    canvas: null,
    ctx: null,
    state: STATE.MENU,
    
    level: 1,
    score: 0,
    lives: 3,
    
    cubes: [],
    qbert: null,
    enemies: [],
    discs: [],
    particles: [],
    
    lastTime: 0,
    
    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        Input.init();
        
        // UI Listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            AudioSys.init();
            this.startGame();
        });
        
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    },
    
    startGame() {
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.updateHUD();
        
        document.getElementById('menu-overlay').style.display = 'none';
        
        this.startLevel();
    },
    
    startLevel() {
        this.state = STATE.PLAYING;
        this.cubes = [];
        this.enemies = [];
        this.discs = [];
        this.particles = [];
        
        // Build Pyramid
        for (let r = 0; r < PYRAMID_ROWS; r++) {
            for (let c = 0; c <= r; c++) {
                this.cubes.push(new Cube(r, c));
            }
        }
        
        // Spawn Qbert
        this.qbert = new Qbert();
        
        // Spawn Discs (Left and Right at specific rows)
        this.discs.push(new Disc(1, -1)); // Left side near top
        this.discs.push(new Disc(1, 1));  // Right side near top
        
        // Start Enemy Spawner
        this.scheduleEnemy();
        
        this.showMessage(`LEVEL ${this.level}`);
    },
    
    scheduleEnemy() {
        if (this.state !== STATE.PLAYING) return;
        
        const delay = Math.max(2000, 10000 - (this.level * 500));
        
        setTimeout(() => {
            if (this.state === STATE.PLAYING) {
                this.spawnEnemy();
                this.scheduleEnemy();
            }
        }, delay);
    },
    
    spawnEnemy() {
        // Determine type based on level
        const rand = Math.random();
        let type = 'ugg';
        
        if (this.level > 1 && rand < 0.3) type = 'slick'; // Green ball
        else if (this.level > 2 && rand < 0.4) type = 'sam';
        else if (this.level > 3 && rand < 0.6) type = 'coily'; // The Snake
        
        const enemy = new Enemy(0, 0, type); // Start at top usually
        
        // Slick and Sam start at top
        // Ugg and Wrongway start at bottom corners? 
        if (type === 'ugg' || type === 'wrongway') {
            enemy.row = PYRAMID_ROWS - 1;
            enemy.col = Math.random() > 0.5 ? 0 : PYRAMID_ROWS - 1;
            const pos = gridToScreen(enemy.row, enemy.col);
            enemy.x = pos.x;
            enemy.y = pos.y;
        }
        
        this.enemies.push(enemy);
    },
    
    update(dt) {
        if (this.state !== STATE.PLAYING && this.state !== STATE.WAITING_FOR_DISC_RIDE) return;
        
        // Update Qbert
        this.qbert.update();
        
        // Check Cube Interaction
        if (!this.qbert.isMoving && !this.qbert.isDead) {
            const cube = this.getCube(this.qbert.row, this.qbert.col);
            if (cube && cube.change()) {
                this.addScore(25);
                this.spawnParticles(this.qbert.x, this.qbert.y - 20, PALETTE.cubeTarget);
                
                // Check Level Complete
                if (this.levelCompleteCheck()) {
                    this.handleLevelComplete();
                }
            }
        }
        
        // Update Enemies
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const e = this.enemies[i];
            e.update();
            
            // Collision with Qbert
            if (!e.isMoving && !this.qbert.isMoving && 
                e.row === this.qbert.row && e.col === this.qbert.col) {
                
                if (e.type === 'slick' || e.type === 'sam') {
                    // Catching Slick/Sam gives bonus
                    this.addScore(300);
                    this.enemies.splice(i, 1);
                    AudioSys.playCatch();
                    this.spawnParticles(this.qbert.x, this.qbert.y, '#00ff00');
                } else if (e.type === 'coily' || e.type === 'ugg' || e.type === 'wrongway') {
                    // Death
                    this.qbert.die();
                }
            }
            
            // Remove inactive enemies
            if (!e.active) this.enemies.splice(i, 1);
        }
        
        // Update Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }

        // Disc Ride Logic
        if (this.state === STATE.WAITING_FOR_DISC_RIDE) {
            // Qbert floats to top
            this.qbert.y -= 2;
            this.qbert.x += (CANVAS_WIDTH/2 - this.qbert.x) * 0.05;
            
            if (this.qbert.y < 100) {
                // Teleport back to top
                this.qbert.row = 0;
                this.qbert.col = 0;
                const pos = gridToScreen(0,0);
                this.qbert.x = pos.x;
                this.qbert.y = pos.y + TILE_HEIGHT; // Reset height
                this.state = STATE.PLAYING;
                
                // Remove used disc
                this.discs = []; 
            }
        } else {
            // Check Disc Collision (Normal Play)
             for (let d of this.discs) {
                 if (!d.active) continue;
                 const dx = Math.abs(this.qbert.x - d.x);
                 const dy = Math.abs((this.qbert.y - TILE_HEIGHT) - d.y); // Adjust for Qbert height
                 
                 if (dx < 20 && dy < 20) {
                     this.state = STATE.WAITING_FOR_DISC_RIDE;
                     AudioSys.playCatch();
                     this.addScore(500); // Bonus for disc ride
                 }
             }
        }
    },
    
    draw() {
        // Clear Background
        const grad = this.ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
        grad.addColorStop(0, PALETTE.bgTop);
        grad.addColorStop(1, PALETTE.bgBottom);
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // Draw Background Elements (Floating Platforms)
        this.drawBackgroundDecor();
        
        // Draw Cubes
        for (let c of this.cubes) {
            c.draw(this.ctx);
        }
        
        // Draw Discs
        for (let d of this.discs) {
            d.draw(this.ctx);
        }
        
        // Draw Enemies
        for (let e of this.enemies) {
            e.draw(this.ctx);
        }
        
        // Draw Qbert
        if (this.qbert) this.qbert.draw(this.ctx);
        
        // Draw Particles
        for (let p of this.particles) {
            p.draw(this.ctx);
        }
    },
    
    drawBackgroundDecor() {
        // Simple animated floating squares in background
        const time = Date.now() / 1000;
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        
        for(let i=0; i<5; i++) {
            const x = (Math.sin(time + i) * 200) + CANVAS_WIDTH/2;
            const y = (Math.cos(time * 0.5 + i*2) * 100) + CANVAS_HEIGHT/2;
            this.ctx.fillRect(x, y, 40, 40);
        }
    },
    
    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;
        
        this.update(dt);
        this.draw();
        
        requestAnimationFrame(this.loop);
    },
    
    // --- HELPERS ---
    
    getCube(r, c) {
        return this.cubes.find(cube => cube.row === r && cube.col === c);
    },
    
    levelCompleteCheck() {
        return this.cubes.every(c => c.state === c.targetState);
    },
    
    handleLevelComplete() {
        if (this.state !== STATE.PLAYING) return;
        
        this.state = STATE.LEVEL_TRANSITION;
        this.addScore(1000 * this.level); // Level bonus
        this.showMessage("LEVEL COMPLETE!");
        
        setTimeout(() => {
            this.level++;
            this.updateHUD();
            this.startLevel();
        }, 2000);
    },
    
    loseLife() {
        this.lives--;
        this.updateHUD();
        
        if (this.lives <= 0) {
            this.gameOver();
        } else {
            // Reset Level positions
            this.qbert = new Qbert();
            this.enemies = []; // Clear enemies
            this.showMessage("OUCH!");
            
            setTimeout(() => {
                this.state = STATE.PLAYING;
            }, 1000);
        }
    },
    
    gameOver() {
        this.state = STATE.GAME_OVER;
        document.getElementById('menu-overlay').style.display = 'flex';
        document.querySelector('#menu-overlay h1').innerText = "GAME OVER";
        document.getElementById('startBtn').innerText = "TRY AGAIN";
    },
    
    addScore(points) {
        this.score += points;
        this.updateHUD();
        
        // Visual popup
        const el = document.createElement('div');
        el.className = 'floating-text';
        el.innerText = `+${points}`;
        el.style.left = (this.qbert.x + 400 - CANVAS_WIDTH/2) + 'px'; // Approximate centering fix
        el.style.top = (this.qbert.y) + 'px';
        
        // Need to adjust for canvas offset in DOM if needed, 
        // but here canvas is centered in container.
        // Let's just append to game-container and position absolute relative to it.
        const container = document.getElementById('game-container');
        el.style.left = (this.qbert.x) + 'px';
        el.style.top = (this.qbert.y - 50) + 'px';
        
        container.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    },
    
    updateHUD() {
        document.getElementById('scoreVal').innerText = this.score;
        document.getElementById('levelVal').innerText = this.level;
        document.getElementById('livesVal').innerText = this.lives;
    },
    
    showMessage(text) {
        const msg = document.getElementById('message-area');
        msg.innerText = text;
        msg.style.opacity = 1;
        
        setTimeout(() => {
            msg.style.opacity = 0;
        }, 1500);
    },
    
    spawnParticles(x, y, color) {
        for(let i=0; i<8; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }
};

// Start
window.onload = () => Game.init();

</script>
</body>
</html>