<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centipede - Arcade Classic</title>
    <style>
        :root {
            --bg-color: #111;
            --frame-color: #444;
            --text-color: #fff;
            --accent-green: #39ff14;
            --accent-red: #ff3333;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            border: 4px solid var(--frame-color);
            background-color: #000;
        }

        canvas {
            display: block;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px #000;
        }

        /* Start/Game Over Screens */
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            text-align: center;
            z-index: 10;
        }

        h1 {
            font-size: 48px;
            color: var(--accent-green);
            margin: 0 0 20px 0;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 0 10px var(--accent-green);
        }

        p {
            font-size: 18px;
            line-height: 1.5;
            margin-bottom: 30px;
            color: #ddd;
        }

        .btn {
            background: var(--accent-red);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--accent-red);
        }

        .hidden {
            display: none !important;
        }

        /* Scanline effect for retro feel */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="600" height="720"></canvas>
    
    <!-- Visual Polish Overlay -->
    <div class="scanlines"></div>

    <!-- HUD -->
    <div id="ui-layer">
        <div class="hud-top">
            <span id="scoreDisplay">SCORE: 00000</span>
            <span id="highScoreDisplay">HI-SCORE: 00000</span>
        </div>
        <div style="text-align: center; font-size: 16px;">
            <span id="livesDisplay"></span>
        </div>
    </div>

    <!-- Menu / Game Over Screen -->
    <div id="overlay-screen">
        <h1 id="titleText">CENTIPEDE</h1>
        <p id="infoText">
            ARROWS to Move • SPACE to Shoot<br>
            Destroy Mushrooms (4 hits)<br>
            Watch out for Spiders, Fleas, and Scorpions!
        </p>
        <button class="btn" id="startBtn">INSERT COIN</button>
    </div>
</div>

<script>
/**
 * CENTIPEDE ARCADE CLONE
 * 
 * Architecture:
 * - Game Loop: Handles updating and drawing entities.
 * - Grid System: The game world is a 30x36 grid (20px tiles).
 * - Entities: Player, Bullet, Mushroom, Centipede (Segments), Spider, Flea, Scorpion.
 * - State Management: Menu -> Playing -> Wave Transition -> Game Over.
 */

// --- CONFIGURATION ---
const CANVAS_WIDTH = 600;
const CANVAS_HEIGHT = 720;
const TILE_SIZE = 20; // 30 cols x 36 rows
const COLS = CANVAS_WIDTH / TILE_SIZE;
const ROWS = CANVAS_HEIGHT / TILE_SIZE;
const PLAYER_AREA_ROWS = 5; // Bottom 5 rows reserved for player

// Colors (Vivid Arcade Style)
const COLORS = {
    BLACK: '#000000',
    WHITE: '#ffffff',
    RED: '#ff3333',
    GREEN: '#39ff14',     // Centipede Head
    YELLOW: '#ffff00',   // Centipede Body
    MUSHROOM_1: '#ff6666', // Healthy
    MUSHROOM_2: '#cc5555',
    MUSHROOM_3: '#994444',
    MUSHROOM_4: '#663333', // Critical
    POISON_MUSHROOM: '#bf00ff', // Scorpion poison
    SPIDER: '#ffffff',
    FLEA: '#00ffff',
    SCORPION: '#ff9900'
};

// --- AUDIO SYSTEM (Placeholders) ---
const AudioSys = {
    shoot: () => { /* console.log("Audio: Shoot"); */ },
    explode: () => { /* console.log("Audio: Explosion"); */ },
    mushroomHit: () => { /* console.log("Audio: Hit"); */ },
    extraLife: () => { /* console.log("Audio: Extra Life"); */ },
    spiderMove: () => {},
    fleaDrop: () => {}
};

// --- INPUT HANDLING ---
const Input = {
    keys: {},
    init() {
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        
        // Bind start button
        document.getElementById('startBtn').addEventListener('click', () => {
            Game.start();
        });
    },
    isDown(code) { return !!this.keys[code]; }
};

// --- UTILITIES ---
const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const rectIntersect = (r1, r2) => {
    return !(r2.x > r1.x + r1.w || 
             r2.x + r2.w < r1.x || 
             r2.y > r1.y + r1.h || 
             r2.y + r2.h < r1.y);
};

// --- GAME CLASSES ---

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 0.5) * 6;
        this.life = 1.0;
        this.color = color;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.05;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 4, 4);
        ctx.globalAlpha = 1.0;
    }
}

class Bullet {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 4;
        this.h = 8;
        this.speed = 10;
        this.active = true;
    }

    update() {
        this.y -= this.speed;
        if (this.y < 0) this.active = false;
    }

    draw(ctx) {
        ctx.fillStyle = COLORS.WHITE;
        ctx.fillRect(this.x - this.w/2, this.y, this.w, this.h);
    }
}

class Mushroom {
    constructor(c, r) {
        this.c = c; // Grid Column
        this.r = r; // Grid Row
        this.health = 4; // 0-3 is alive, <0 destroyed. Actually let's do 1-4 visual states.
        this.poisoned = false;
    }

    getBounds() {
        return { x: this.c * TILE_SIZE + 2, y: this.r * TILE_SIZE + 2, w: TILE_SIZE - 4, h: TILE_SIZE - 4 };
    }

    hit() {
        this.health--;
        AudioSys.mushroomHit();
        if (this.health <= 0) {
            return true; // Destroyed
        }
        return false;
    }

    draw(ctx) {
        const x = this.c * TILE_SIZE;
        const y = this.r * TILE_SIZE;
        
        let color = COLORS.MUSHROOM_1;
        if (this.poisoned) color = COLORS.POISON_MUSHROOM;
        else if (this.health === 3) color = COLORS.MUSHROOM_2;
        else if (this.health === 2) color = COLORS.MUSHROOM_3;
        else if (this.health === 1) color = COLORS.MUSHROOM_4;

        ctx.fillStyle = color;
        
        // Draw Mushroom Shape (Procedural)
        const sizeMod = this.health / 4; 
        
        // Cap
        ctx.beginPath();
        ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, (TILE_SIZE/2 - 2) * sizeMod, Math.PI, 0);
        ctx.fill();

        // Stem (only if healthy enough)
        if (this.health > 1) {
            ctx.fillRect(x + TILE_SIZE/2 - 3, y + TILE_SIZE/2, 6, (TILE_SIZE/2 - 4));
        }
        
        // Detail dots
        if (this.health === 4 && !this.poisoned) {
            ctx.fillStyle = COLORS.BLACK;
            ctx.fillRect(x + 7, y + 5, 2, 2);
            ctx.fillRect(x + 12, y + 8, 2, 2);
        }
    }
}

class Player {
    constructor() {
        this.w = TILE_SIZE * 0.8;
        this.h = TILE_SIZE * 0.8;
        this.reset();
    }

    reset() {
        this.x = CANVAS_WIDTH / 2;
        this.y = CANVAS_HEIGHT - (TILE_SIZE * 1.5);
        this.speed = 4;
        this.cooldown = 0;
        this.dead = false;
        this.invincibleTimer = 0;
    }

    update() {
        if (this.dead) return;

        // Movement
        if (Input.isDown('ArrowLeft')) this.x -= this.speed;
        if (Input.isDown('ArrowRight')) this.x += this.speed;
        if (Input.isDown('ArrowUp')) this.y -= this.speed; 
        if (Input.isDown('ArrowDown')) this.y += this.speed;

        // Clamp to screen and player area
        this.x = Math.max(this.w/2, Math.min(CANVAS_WIDTH - this.w/2, this.x));
        
        const minY = CANVAS_HEIGHT - (PLAYER_AREA_ROWS * TILE_SIZE);
        this.y = Math.max(minY, Math.min(CANVAS_HEIGHT - this.h, this.y));

        // Shooting
        if (this.cooldown > 0) this.cooldown--;
        if (Input.isDown('Space') && this.cooldown <= 0) {
            Game.bullets.push(new Bullet(this.x, this.y));
            this.cooldown = 15; // Fire rate
            AudioSys.shoot();
        }

        if (this.invincibleTimer > 0) this.invincibleTimer--;
    }

    getBounds() {
        return { x: this.x - this.w/2 + 4, y: this.y - this.h/2 + 4, w: this.w - 8, h: this.h - 8 };
    }

    draw(ctx) {
        if (this.dead) return;
        
        // Flicker if invincible
        if (this.invincibleTimer > 0 && Math.floor(Date.now() / 100) % 2 === 0) return;

        ctx.fillStyle = '#33ccff';
        
        // Draw Ship/Character shape
        const cx = this.x;
        const cy = this.y;

        // Main body
        ctx.beginPath();
        ctx.moveTo(cx, cy - this.h/2); // Top tip
        ctx.lineTo(cx + this.w/2, cy + this.h/2); // Bottom right
        ctx.lineTo(cx, cy + this.h/4); // Inner notch
        ctx.lineTo(cx - this.w/2, cy + this.h/2); // Bottom left
        ctx.closePath();
        ctx.fill();

        // Engine glow
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(cx - 4, cy + this.h/3, 8, 6);
    }
    
    die() {
        if (this.invincibleTimer > 0 || this.dead) return;
        
        AudioSys.explode();
        Game.spawnExplosion(this.x, this.y, '#33ccff');
        this.dead = true;
        Game.lives--;
        
        setTimeout(() => {
            if (Game.lives > 0) {
                this.reset();
                this.invincibleTimer = 180; // 3 seconds at 60fps
            } else {
                Game.gameOver();
            }
        }, 1500);
    }
}

// --- ENEMIES ---

class Spider {
    constructor() {
        this.active = false;
        this.w = TILE_SIZE;
        this.h = TILE_SIZE;
        this.timer = 0;
        this.x = 0;
        this.y = 0;
        this.dx = 2;
        this.dy = 2;
        this.directionX = 1; // 1 right, -1 left
    }

    spawn() {
        if (this.active) return;
        this.active = true;
        this.y = rnd(ROWS / 2, ROWS - PLAYER_AREA_ROWS) * TILE_SIZE;
        this.x = this.directionX === 1 ? -TILE_SIZE : CANVAS_WIDTH + TILE_SIZE;
        this.timer = 600; // Live for 10 seconds
    }

    update() {
        if (!this.active) return;

        this.x += this.dx * this.directionX;
        
        // Zigzag movement logic
        this.y += Math.sin(this.x / 30) * 3;

        // Bounds check Y
        const minY = (ROWS/2) * TILE_SIZE;
        const maxY = (ROWS - 1) * TILE_SIZE;
        if (this.y < minY || this.y > maxY) {
            // Bounce vertically roughly by reversing sine phase logic (simplified here)
             // Actually just let it drift, but clamp
             this.y = Math.max(minY, Math.min(maxY, this.y));
        }

        // Bounds check X (Despawn)
        if ((this.directionX === 1 && this.x > CANVAS_WIDTH + TILE_SIZE) ||
            (this.directionX === -1 && this.x < -TILE_SIZE)) {
            this.active = false;
            this.directionX *= -1; // Switch side for next spawn
        }

        this.timer--;
        if (this.timer <= 0) this.active = false;

        // Collision with Player
        const bounds = { x: this.x, y: this.y, w: this.w, h: this.h };
        if (rectIntersect(bounds, Game.player.getBounds())) {
            Game.player.die();
        }
    }

    draw(ctx) {
        if (!this.active) return;
        ctx.fillStyle = COLORS.SPIDER;
        
        // Draw a spiky spider shape
        const cx = this.x + TILE_SIZE/2;
        const cy = this.y + TILE_SIZE/2;
        
        ctx.beginPath();
        for(let i=0; i<8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const r = i % 2 === 0 ? TILE_SIZE/2 : TILE_SIZE/1.5; // Legs
            ctx.lineTo(cx + Math.cos(angle)*r, cy + Math.sin(angle)*r);
        }
        ctx.fill();
    }
}

class Flea {
    constructor() {
        this.active = false;
        this.x = 0;
        this.y = 0;
        this.speed = 3;
    }

    spawn() {
        if (this.active) return;
        
        // Check bottom area mushroom count
        let bottomShrooms = 0;
        const startRow = ROWS - PLAYER_AREA_ROWS - 5;
        for(let r=startRow; r<ROWS-PLAYER_AREA_ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if (Game.mushrooms[`${c},${r}`]) bottomShrooms++;
            }
        }

        if (bottomShrooms < 5 && Math.random() < 0.01) { // Low chance per frame if empty
            this.active = true;
            this.x = rnd(1, COLS-2) * TILE_SIZE;
            this.y = -TILE_SIZE;
        }
    }

    update() {
        if (!this.active) return;

        this.y += this.speed;

        // Drop mushrooms randomly
        if (Math.random() < 0.05 && this.y > 0 && this.y < CANVAS_HEIGHT - PLAYER_AREA_ROWS*TILE_SIZE) {
            const c = Math.floor(this.x / TILE_SIZE);
            const r = Math.floor(this.y / TILE_SIZE);
            if (!Game.mushrooms[`${c},${r}`]) {
                Game.mushrooms[`${c},${r}`] = new Mushroom(c, r);
                AudioSys.fleaDrop();
            }
        }

        // Despawn
        if (this.y > CANVAS_HEIGHT) {
            this.active = false;
        }

        // Collision with Player or Bullet
        const bounds = { x: this.x + 4, y: this.y + 4, w: TILE_SIZE-8, h: TILE_SIZE-8 };
        
        // Player hit
        if (rectIntersect(bounds, Game.player.getBounds())) {
            Game.player.die();
        }

        // Bullet hit
        for (let b of Game.bullets) {
            if (b.active && rectIntersect(bounds, {x: b.x-b.w/2, y:b.y, w:b.w, h:b.h})) {
                this.active = false;
                b.active = false;
                Game.addScore(200, this.x, this.y);
                Game.spawnExplosion(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2, COLORS.FLEA);
                return;
            }
        }
    }

    draw(ctx) {
        if (!this.active) return;
        ctx.fillStyle = COLORS.FLEA;
        // Draw elongated shape
        ctx.beginPath();
        ctx.moveTo(this.x + TILE_SIZE/2, this.y);
        ctx.lineTo(this.x + TILE_SIZE, this.y + TILE_SIZE);
        ctx.lineTo(this.x, this.y + TILE_SIZE);
        ctx.fill();
        
        // Wings (lines)
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y + 5);
        ctx.lineTo(this.x - 5, this.y + 10);
        ctx.moveTo(this.x + TILE_SIZE, this.y + 5);
        ctx.lineTo(this.x + TILE_SIZE + 5, this.y + 10);
        ctx.stroke();
    }
}

class Scorpion {
    constructor() {
        this.active = false;
        this.x = 0;
        this.y = 0;
        this.speed = 2;
        this.dir = 1; // 1 right, -1 left
    }

    spawn() {
        if (this.active) return;
        // Only appears in higher waves or randomly
        if (Game.wave < 2 && Math.random() > 0.005) return;

        if (Math.random() < 0.002) {
            this.active = true;
            this.dir = Math.random() > 0.5 ? 1 : -1;
            this.x = this.dir === 1 ? -TILE_SIZE : CANVAS_WIDTH + TILE_SIZE;
            this.y = rnd(1, ROWS/3) * TILE_SIZE; // Top third
        }
    }

    update() {
        if (!this.active) return;

        this.x += this.speed * this.dir;

        // Poison mushrooms it passes over
        const c = Math.floor((this.x + TILE_SIZE/2) / TILE_SIZE);
        const r = Math.floor((this.y + TILE_SIZE/2) / TILE_SIZE);
        
        if (c >= 0 && c < COLS) {
            const key = `${c},${r}`;
            if (Game.mushrooms[key] && !Game.mushrooms[key].poisoned) {
                Game.mushrooms[key].poisoned = true;
            }
        }

        // Despawn
        if ((this.dir === 1 && this.x > CANVAS_WIDTH + TILE_SIZE) ||
            (this.dir === -1 && this.x < -TILE_SIZE)) {
            this.active = false;
        }
        
        // Collision with Player/Bullet (Optional: usually scorpions don't kill, just poison)
    }

    draw(ctx) {
        if (!this.active) return;
        ctx.fillStyle = COLORS.SCORPION;
        
        // S-Curve shape or segmented body
        const segments = 5;
        for(let i=0; i<segments; i++) {
            let sx = this.x + (i * (TILE_SIZE/2) * this.dir);
            if (this.dir === -1) sx = this.x + TILE_SIZE - (i * (TILE_SIZE/2)); // Flip visual
            
            ctx.beginPath();
            ctx.arc(sx, this.y + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI*2);
            ctx.fill();
        }
        
        // Tail
        ctx.strokeStyle = COLORS.SCORPION;
        ctx.lineWidth = 3;
        ctx.beginPath();
        let tailX = this.dir === 1 ? this.x : this.x + TILE_SIZE;
        ctx.moveTo(tailX, this.y + TILE_SIZE/2);
        ctx.lineTo(tailX - (10*this.dir), this.y); // Curve up
        ctx.stroke();
    }
}

class CentipedeSegment {
    constructor(c, r, isHead, prev = null) {
        this.c = c;
        this.r = r;
        this.pixelX = c * TILE_SIZE;
        this.pixelY = r * TILE_SIZE;
        this.isHead = isHead;
        this.dirX = 1; // 1 = Right, -1 = Left
        this.active = true;
        
        // Movement smoothing
        this.moveTimer = 0;
        this.moveInterval = 5; // Frames per grid movement (Speed)
    }

    update() {
        if (!this.active) return;

        // Smoothly interpolate pixel position to grid position
        const targetX = this.c * TILE_SIZE;
        const targetY = this.r * TILE_SIZE;
        
        // Simple lerp for smoothness
        this.pixelX += (targetX - this.pixelX) * 0.4;
        this.pixelY += (targetY - this.pixelY) * 0.4;

        if (!this.isHead) return; // Body logic handled by CentipedeManager

        // Head Logic
        this.moveTimer++;
        
        // Calculate speed based on wave
        let currentSpeed = Math.max(1, this.moveInterval - Math.floor(Game.wave / 2));
        if (this.r * TILE_SIZE >= CANVAS_HEIGHT - (PLAYER_AREA_ROWS*TILE_SIZE)) {
             currentSpeed = 1; // Speed up in player area
        }

        if (this.moveTimer < currentSpeed) return;
        this.moveTimer = 0;

        // Proposed new position
        let nextC = this.c + this.dirX;
        let nextR = this.r;

        // Check collision with walls or mushrooms
        let hitObstacle = false;
        
        // Wall Collision
        if (nextC < 0 || nextC >= COLS) {
            hitObstacle = true;
        } else {
            // Mushroom Collision
            const key = `${nextC},${nextR}`;
            if (Game.mushrooms[key]) {
                hitObstacle = true;
            }
        }

        if (hitObstacle) {
            // Drop down and reverse direction
            nextR++;
            
            // If hitting bottom of screen, wrap to top? Or just bounce up?
            // Original: Bounces up until it leaves player area then wraps.
            if (nextR >= ROWS - 1) {
                 nextR--; // Go back up? No, original logic is complex. 
                 // Simplified: If at absolute bottom, move up until clear of player zone
                 nextR = this.r - 1; 
            } else {
                this.dirX *= -1; // Flip horizontal direction
            }
            
            // Check if the spot below is blocked (rare but possible)
            const keyBelow = `${this.c},${nextR}`;
            if (Game.mushrooms[keyBelow]) {
               // If blocked by mushroom below, try to move horizontally again? 
               // For simplicity: Just stay put or force overlap.
               // Original logic: It finds the open path. We'll just increment R.
            }
        }

        // Poisoned Mushroom Logic
        const currentKey = `${this.c},${this.r}`;
        if (Game.mushrooms[currentKey] && Game.mushrooms[currentKey].poisoned) {
             // Dive straight down to bottom
             nextR++;
             nextC = this.c; // Don't move horizontally
        }

        this.c = nextC;
        this.r = nextR;
    }
}

// --- MAIN GAME ENGINE ---

const Game = {
    canvas: null,
    ctx: null,
    player: null,
    
    // Entities
    bullets: [],
    mushrooms: {}, // Key: "c,r", Value: Mushroom Object
    centipedes: [], // Array of Arrays (Centipede chains)
    particles: [],
    spider: new Spider(),
    flea: new Flea(),
    scorpion: new Scorpion(),

    // State
    state: 'MENU', // MENU, PLAYING, GAMEOVER
    score: 0,
    highScore: localStorage.getItem('centipede_highscore') || 0,
    lives: 3,
    wave: 1,
    
    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        Input.init();
        
        // Render Loop
        const loop = () => {
            if (this.state === 'PLAYING') {
                this.update();
            }
            this.draw();
            requestAnimationFrame(loop);
        };
        
        this.updateHighScoreDisplay();
        requestAnimationFrame(loop);
    },

    start() {
        document.getElementById('overlay-screen').classList.add('hidden');
        this.score = 0;
        this.lives = 3;
        this.wave = 1;
        this.player = new Player();
        this.resetLevel();
        this.state = 'PLAYING';
        this.updateHUD();
    },

    resetLevel() {
        this.bullets = [];
        this.particles = [];
        // Generate random mushrooms (sparse)
        this.mushrooms = {};
        for (let i = 0; i < rnd(20, 30); i++) {
            const c = rnd(0, COLS - 1);
            const r = rnd(0, ROWS - PLAYER_AREA_ROWS - 2); // Keep player area clear initially
            this.mushrooms[`${c},${r}`] = new Mushroom(c, r);
        }
        
        this.spawnCentipede();
    },

    spawnCentipede() {
        this.centipedes = [];
        const length = Math.min(12, 8 + this.wave); // Increase length with waves? Or count.
        // Actually original increases difficulty by speed and more mushrooms. 
        // Let's stick to standard length but maybe add a second one later?
        
        let chain = [];
        for(let i=0; i<length; i++) {
            chain.push(new CentipedeSegment(i, 0, i === 0));
        }
        this.centipedes.push(chain);
    },

    nextWave() {
        this.wave++;
        this.resetLevel();
        // Flash message
        const ui = document.getElementById('overlay-screen');
        const title = document.getElementById('titleText');
        const info = document.getElementById('infoText');
        const btn = document.getElementById('startBtn');
        
        title.innerText = `WAVE ${this.wave}`;
        info.innerText = "GET READY!";
        btn.classList.add('hidden');
        ui.classList.remove('hidden');
        
        setTimeout(() => {
            ui.classList.add('hidden');
            btn.classList.remove('hidden'); // Reset for game over
            this.state = 'PLAYING';
        }, 2000);
    },

    addScore(points, x, y) {
        this.score += points;
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('centipede_highscore', this.highScore);
            this.updateHighScoreDisplay();
        }
        
        // Extra life at 12k
        const livesEarned = Math.floor(this.score / 12000);
        const currentLivesBase = this.lives; 
        // Logic needs to track total lives awarded, simplified here:
        if (this.score > 0 && this.score % 12000 < points) {
             AudioSys.extraLife();
             this.lives++;
        }

        this.updateHUD();
        
        // Floating text effect could go here
    },

    spawnExplosion(x, y, color) {
        for(let i=0; i<10; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    },

    update() {
        if (this.state !== 'PLAYING') return;

        // Player
        this.player.update();

        // Bullets
        this.bullets.forEach(b => b.update());
        this.bullets = this.bullets.filter(b => b.active);

        // Particles
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => p.life > 0);

        // Enemies
        this.spider.spawn();
        this.spider.update();

        this.flea.spawn();
        this.flea.update();

        this.scorpion.spawn();
        this.scorpion.update();

        // Centipede Logic
        // We need to handle movement and splitting.
        // Structure: Array of Arrays. Inner array is a chain.
        
        let allSegmentsDead = true;

        for (let i = 0; i < this.centipedes.length; i++) {
            const chain = this.centipedes[i];
            
            // Move Head
            if (chain.length > 0) {
                allSegmentsDead = false;
                chain[0].update();
                
                // Check head collision with player
                const headBounds = { x: chain[0].pixelX, y: chain[0].pixelY, w: TILE_SIZE, h: TILE_SIZE };
                if (rectIntersect(headBounds, this.player.getBounds())) {
                    this.player.die();
                }
            }

            // Move Body segments follow the leader
            for (let j = 1; j < chain.length; j++) {
                const segment = chain[j];
                const leader = chain[j-1];
                
                // Movement Logic: Segment moves to where leader was.
                // To simulate grid following, we track leader's previous grid pos?
                // Simple approach: Interpolate towards Leader's current grid pos.
                // But that causes clumping. 
                // Better: Store a path history? Too complex for single file simple.
                // Robust Grid Approach:
                
                segment.moveTimer++;
                if (segment.moveTimer >= leader.moveInterval) {
                    segment.c = leader.c; // This is laggy visually
                    segment.r = leader.r;
                    
                    // Correct logic for following in grid:
                    // Actually, simpler visual trick: Just move to leader's old position.
                    // We need to store 'prevC' and 'prevR' on the leader.
                }
                
                // Let's implement a simple follow:
                // If segment is far from leader's previous spot, move there.
                // Since we didn't store history in the class, let's update logic slightly:
                // The head decides direction. Body just follows path.
            }
            
            // Rewrite Centipede Movement for correctness
            // Each segment has a 'target' grid cell provided by the one ahead.
        }

        // --- REVISED CENTIPEDE MOVEMENT ---
        this.centipedes.forEach((chain, chainIdx) => {
            if (chain.length === 0) return;
            
            // Move from back to front to avoid overwriting data needed for followers?
            // No, move Head first, then others follow.
            
            // 1. Determine Head Move
            const head = chain[0];
            const prevHeadC = head.c;
            const prevHeadR = head.r;
            
            head.update(); // Updates head.c and head.r
            
            // If head moved into player area, maybe change color? (Optional)

            // 2. Body Segments
            for (let i = 1; i < chain.length; i++) {
                const seg = chain[i];
                
                // We need to pass the "previous" position of the segment ahead down the chain.
                // But `update` changed it already.
                // Solution: Store old pos before update.
            }
        });
        
        // To fix the follow logic cleanly:
        this.centipedes.forEach(chain => {
             for(let i = chain.length - 1; i > 0; i--) {
                 const leader = chain[i-1];
                 const follower = chain[i];
                 
                 // Follower moves to where Leader IS (visually lagging behind)
                 // But strictly, in grid games, they occupy distinct cells.
                 // Let's assume the Leader moved from OldPos to NewPos.
                 // Follower should move from ItsOldPos to LeaderOldPos.
                 
                 if (!follower.isHead) {
                     follower.c = leader.prevC; // We need prevC stored
                     follower.r = leader.prevR;
                     follower.pixelX = follower.c * TILE_SIZE;
                     follower.pixelY = follower.r * TILE_SIZE;
                     
                     // Inherit direction from new head status?
                     if (i === 1) { 
                         follower.dirX = leader.dirX; 
                     }
                 }
             }
             
             // Update prev positions for next frame
             chain.forEach(s => {
                 s.prevC = s.c;
                 s.prevR = s.r;
             });
        });


        // Collisions: Bullets vs Centipede
        this.bullets.forEach(bullet => {
            if (!bullet.active) return;
            
            const bRect = { x: bullet.x - bullet.w/2, y: bullet.y, w: bullet.w, h: bullet.h };
            
            for (let cIdx = 0; cIdx < this.centipedes.length; cIdx++) {
                const chain = this.centipedes[cIdx];
                let hitIndex = -1;
                
                // Check collision with any segment in this chain
                for (let sIdx = 0; sIdx < chain.length; sIdx++) {
                    const seg = chain[sIdx];
                    const sRect = { x: seg.pixelX, y: seg.pixelY, w: TILE_SIZE, h: TILE_SIZE };
                    
                    if (rectIntersect(bRect, sRect)) {
                        hitIndex = sIdx;
                        break;
                    }
                }
                
                if (hitIndex !== -1) {
                    bullet.active = false;
                    const seg = chain[hitIndex];
                    
                    // Visuals
                    Game.spawnExplosion(seg.pixelX + TILE_SIZE/2, seg.pixelY + TILE_SIZE/2, seg.isHead ? COLORS.GREEN : COLORS.YELLOW);
                    
                    // Scoring
                    Game.addScore(seg.isHead ? 100 : 10, seg.pixelX, seg.pixelY);

                    // Logic: Create Mushroom at death spot?
                    // Original: Head becomes mushroom. Body does not.
                    if (seg.isHead) {
                         const key = `${seg.c},${seg.r}`;
                         if (!Game.mushrooms[key]) Game.mushrooms[key] = new Mushroom(seg.c, seg.r);
                    }

                    // Splitting
                    if (hitIndex === 0) {
                        // Head hit. Remove it. Next segment becomes head.
                        chain.shift(); 
                        if (chain.length > 0) chain[0].isHead = true;
                    } else {
                        // Body hit. Split into two chains.
                        const tailChain = chain.splice(hitIndex); // Cut off from hit index to end
                        // Remove the hit segment from the new tail
                        tailChain.shift(); 
                        
                        // If tail remains, make first element a head
                        if (tailChain.length > 0) {
                            tailChain[0].isHead = true;
                            this.centipedes.push(tailChain);
                        }
                    }
                    
                    break; // Bullet used
                }
            }
        });
        
        // Check collisions: Centipede vs Player (Body)
        this.centipedes.forEach(chain => {
             chain.forEach(seg => {
                 const sRect = { x: seg.pixelX + 4, y: seg.pixelY + 4, w: TILE_SIZE-8, h: TILE_SIZE-8 };
                 if (rectIntersect(sRect, this.player.getBounds())) {
                     Game.player.die();
                 }
             });
        });

        // Check collisions: Bullets vs Mushrooms
        this.bullets.forEach(bullet => {
            if (!bullet.active) return;
            
            const c = Math.floor((bullet.x) / TILE_SIZE);
            const r = Math.floor((bullet.y + bullet.h/2) / TILE_SIZE);
            const key = `${c},${r}`;
            
            if (this.mushrooms[key]) {
                // Check precise rect
                const mRect = this.mushrooms[key].getBounds();
                const bRect = { x: bullet.x - bullet.w/2, y: bullet.y, w: bullet.w, h: bullet.h };
                
                if (rectIntersect(mRect, bRect)) {
                    bullet.active = false;
                    const destroyed = this.mushrooms[key].hit();
                    if (destroyed) {
                        delete this.mushrooms[key];
                        Game.addScore(1, c*TILE_SIZE, r*TILE_SIZE); // Minimal points for mushroom
                    } else {
                        Game.addScore(1, c*TILE_SIZE, r*TILE_SIZE);
                    }
                }
            }
        });

        // Wave clear check
        if (this.centipedes.length === 0 || this.centipedes.every(c => c.length === 0)) {
            this.nextWave();
        }
    },

    draw() {
        // Clear background
        this.ctx.fillStyle = COLORS.BLACK;
        this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw Player Area Boundary (Subtle)
        this.ctx.strokeStyle = '#222';
        this.ctx.beginPath();
        this.ctx.moveTo(0, CANVAS_HEIGHT - PLAYER_AREA_ROWS * TILE_SIZE);
        this.ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT - PLAYER_AREA_ROWS * TILE_SIZE);
        this.ctx.stroke();

        // Draw Mushrooms
        for (let key in this.mushrooms) {
            this.mushrooms[key].draw(this.ctx);
        }

        // Draw Centipede
        this.centipedes.forEach(chain => {
            chain.forEach(seg => {
                seg.draw(this.ctx); // We need to implement draw method onSegment or here
                
                const x = seg.pixelX;
                const y = seg.pixelY;
                
                this.ctx.fillStyle = seg.isHead ? COLORS.GREEN : COLORS.YELLOW;
                
                if (seg.isHead) {
                    // Draw Head
                    this.ctx.beginPath();
                    this.ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, TILE_SIZE/2 - 1, 0, Math.PI*2);
                    this.ctx.fill();
                    
                    // Eyes
                    this.ctx.fillStyle = '#000';
                    const eyeOffsetX = seg.dirX === 1 ? 4 : -4;
                    this.ctx.fillRect(x + TILE_SIZE/2 + eyeOffsetX, y + 6, 2, 4);
                    this.ctx.fillRect(x + TILE_SIZE/2 + eyeOffsetX * 0.5, y + 6, 2, 4);

                    // Antennae
                    this.ctx.strokeStyle = seg.isHead ? COLORS.GREEN : COLORS.YELLOW;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + TILE_SIZE/2, y);
                    this.ctx.lineTo(x + TILE_SIZE/2 - (5*seg.dirX), y - 5);
                    this.ctx.moveTo(x + TILE_SIZE/2, y);
                    this.ctx.lineTo(x + TILE_SIZE/2 + (5*seg.dirX), y - 5);
                    this.ctx.stroke();
                } else {
                    // Draw Body Segment (Circle with cutout)
                    this.ctx.beginPath();
                    this.ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, TILE_SIZE/2 - 1, 0, Math.PI*2);
                    this.ctx.fill();
                    
                    // Inner detail to make it look connected
                    this.ctx.fillStyle = COLORS.BLACK;
                    this.ctx.fillRect(x + TILE_SIZE/4, y + TILE_SIZE/4, TILE_SIZE/2, TILE_SIZE/2);
                }
            });
        });

        // Draw Player
        if (this.player) this.player.draw(this.ctx);

        // Draw Enemies
        this.spider.draw(this.ctx);
        this.flea.draw(this.ctx);
        this.scorpion.draw(this.ctx);

        // Draw Bullets
        this.bullets.forEach(b => b.draw(this.ctx));

        // Draw Particles
        this.particles.forEach(p => p.draw(this.ctx));
    },

    updateHUD() {
        document.getElementById('scoreDisplay').innerText = `SCORE: ${this.score.toString().padStart(5, '0')}`;
        
        let livesStr = '';
        for(let i=0; i<this.lives; i++) livesStr += '▲ ';
        document.getElementById('livesDisplay').innerHTML = `<span style="color:#33ccff">${livesStr}</span>`;
    },
    
    updateHighScoreDisplay() {
         document.getElementById('highScoreDisplay').innerText = `HI-SCORE: ${this.highScore.toString().padStart(5, '0')}`;
    },

    gameOver() {
        this.state = 'GAMEOVER';
        const ui = document.getElementById('overlay-screen');
        const title = document.getElementById('titleText');
        const info = document.getElementById('infoText');
        const btn = document.getElementById('startBtn');

        title.innerText = "GAME OVER";
        title.style.color = COLORS.RED;
        info.innerHTML = `FINAL SCORE: ${this.score}<br>WAVE REACHED: ${this.wave}`;
        btn.innerText = "PLAY AGAIN";
        
        ui.classList.remove('hidden');
    }
};

// Start
window.onload = () => Game.init();

</script>
</body>
</html>