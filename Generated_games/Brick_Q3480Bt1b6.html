<!DOCTYPE html>
<html>
<head>
    <title>Atari Breakout</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
        }
        canvas {
            border: 2px solid white;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="672" height="528"></canvas>

    <script>
        // Game constants
        const CANVAS_WIDTH = 672;
        const CANVAS_HEIGHT = 528;
        let PADDLE_WIDTH = 96;
        const PADDLE_HEIGHT = 12;
        const BALL_RADIUS = 6;
        const BRICK_ROWS = 4; // Reduced from 8 to 4
        const BRICK_COLUMNS = 6; // Same number of columns but half the rows
        const BRICK_WIDTH = 96; // Increased width to maintain spacing with fewer bricks
        const BRICK_HEIGHT = 16;
        const BRICK_PADDING = 8;
        const BRICK_OFFSET_TOP = 80;
        const BRICK_OFFSET_LEFT = 32;
        const PADDLE_Y = CANVAS_HEIGHT - 20;

        // Game variables
        let canvas = document.getElementById("gameCanvas");
        let ctx = canvas.getContext("2d");
        let paddleX = (CANVAS_WIDTH - PADDLE_WIDTH) / 2;
        let balls = [];
        let bricks = [];
        let score = 0;
        let lives = 3;
        let rightPressed = false;
        let leftPressed = false;
        let gameRunning = true;
        let gameOver = false;
        let gameWon = false;
        let originalPaddleWidth = PADDLE_WIDTH;
        let shrinkThreshold1 = 2/3; // When 66% of bricks are cleared
        let shrinkThreshold2 = 0.33; // When 33% of bricks are cleared
        let paddleShrunkOnce = false;
        let paddleShrunkTwice = false;
        let totalBricks = BRICK_ROWS * BRICK_COLUMNS;
        let initialBallSpeed = 4;

        // Sound effects using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function createSound(frequency, duration, type = 'square') {
            if (!audioContext) return; // Skip sound if no context
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = type;
            oscillator.frequency.value = frequency;
            gainNode.gain.value = 0.1;
            
            oscillator.start();
            setTimeout(() => {
                oscillator.stop();
            }, duration);
        }

        // Brick colors (top to bottom)
        const brickColors = [
            '#FF0000', // Red
            '#FFA500', // Orange
            '#00FF00', // Green
            '#FFFF00'  // Yellow
        ];

        // Initialize bricks
        function initBricks() {
            for (let r = 0; r < BRICK_ROWS; r++) {
                bricks[r] = [];
                for (let c = 0; c < BRICK_COLUMNS; c++) {
                    let brickX = (c * (BRICK_WIDTH + BRICK_PADDING)) + BRICK_OFFSET_LEFT;
                    let brickY = (r * (BRICK_HEIGHT + BRICK_PADDING)) + BRICK_OFFSET_TOP;
                    bricks[r][c] = { x: brickX, y: brickY, status: 1 };
                }
            }
        }

        // Initialize balls
        function initBalls() {
            balls = [];
            let ball = {
                x: CANVAS_WIDTH / 2,
                y: PADDLE_Y - BALL_RADIUS,
                dx: initialBallSpeed * (Math.random() > 0.5 ? 1 : -1),
                dy: -initialBallSpeed,
                active: true
            };
            balls.push(ball);
        }

        // Draw paddle
        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, PADDLE_Y, PADDLE_WIDTH, PADDLE_HEIGHT);
            ctx.fillStyle = "#FFFFFF";
            ctx.fill();
            ctx.closePath();
        }

        // Draw ball
        function drawBall(ball) {
            if (!ball.active) return;
            
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = "#FFFFFF";
            ctx.fill();
            ctx.closePath();
        }

        // Draw bricks
        function drawBricks() {
            for (let r = 0; r < BRICK_ROWS; r++) {
                for (let c = 0; c < BRICK_COLUMNS; c++) {
                    if (bricks[r][c].status === 1) {
                        let brickX = bricks[r][c].x;
                        let brickY = bricks[r][c].y;
                        
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, BRICK_WIDTH, BRICK_HEIGHT);
                        ctx.fillStyle = brickColors[r];
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        // Draw walls and ceiling
        function drawBoundaries() {
            // Top boundary
            ctx.beginPath();
            ctx.moveTo(0, 24);
            ctx.lineTo(CANVAS_WIDTH, 24);
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Left boundary
            ctx.beginPath();
            ctx.moveTo(16, 5);
            ctx.lineTo(16, CANVAS_HEIGHT);
            ctx.stroke();
            
            // Right boundary
            ctx.beginPath();
            ctx.moveTo(CANVAS_WIDTH - 20, 8);
            ctx.lineTo(CANVAS_WIDTH - 20, CANVAS_HEIGHT);
            ctx.stroke();
        }

        // Draw score
        function drawScore() {
            // Clear the score area first
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, CANVAS_WIDTH, 24);
            
            ctx.font = "24px 'Courier New', monospace";
            ctx.fillStyle = "#FFFFFF";
            ctx.textAlign = "left";
            ctx.fillText("SCORE: " + score, 30, 18);
            
            ctx.textAlign = "right";
            ctx.fillText("BALLS: " + lives, CANVAS_WIDTH - 20, 19);
        }

        // Collision detection
        function collisionDetection() {
            for (let ball of balls) {
                if (!ball.active) continue;
                
                for (let r = 0; r < BRICK_ROWS; r++) {
                    for (let c = 0; c < BRICK_COLUMNS; c++) {
                        let brick = bricks[r][c];
                        if (brick.status === 1) {
                            // Check collision with brick
                            if (
                                ball.x + BALL_RADIUS > brick.x &&
                                ball.x - BALL_RADIUS < brick.x + BRICK_WIDTH &&
                                ball.y + BALL_RADIUS > brick.y &&
                                ball.y - BALL_RADIUS < brick.y + BRICK_HEIGHT
                            ) {
                                // Determine which side of the brick was hit
                                let fromLeft = Math.abs(ball.x + BALL_RADIUS - brick.x);
                                let fromRight = Math.abs(ball.x - BALL_RADIUS - (brick.x + BRICK_WIDTH));
                                let fromTop = Math.abs(ball.y + BALL_RADIUS - brick.y);
                                let fromBottom = Math.abs(ball.y - BALL_RADIUS - (brick.y + BRICK_HEIGHT));
                                
                                // Find the minimum distance to determine which side was hit
                                let minDistance = Math.min(fromLeft, fromRight, fromTop, fromBottom);
                                
                                if (minDistance === fromLeft || minDistance === fromRight) {
                                    ball.dx = -ball.dx;  // Reverse horizontal direction
                                } else {
                                    ball.dy = -ball.dy;  // Reverse vertical direction
                                }
                                
                                brick.status = 0;
                                score += 10 * (BRICK_ROWS - r); // More points for higher rows
                                
                                // Play sound
                                createSound(250 + r * 70, 80);
                            }
                        }
                    }
                }
            }
        }

        // Count active bricks
        function countActiveBricks() {
            let count = 0;
            for (let r = 0; r < BRICK_ROWS; r++) {
                for (let c = 0; c < BRICK_COLUMNS; c++) {
                    if (bricks[r][c].status === 1) {
                        count++;
                    }
                }
            }
            return count;
        }

        // Check paddle collision
        function checkPaddleCollision(ball) {
            if (
                ball.y + BALL_RADIUS > PADDLE_Y &&
                ball.y - BALL_RADIUS < PADDLE_Y + PADDLE_HEIGHT &&
                ball.x + BALL_RADIUS > paddleX &&
                ball.x - BALL_RADIUS < paddleX + PADDLE_WIDTH
            ) {
                // Calculate bounce angle based on where the ball hits the paddle
                let hitPosition = (ball.x - paddleX) / PADDLE_WIDTH; // 0 to 1
                let angle = (hitPosition - 0.5) * Math.PI * 2/3; // -60° to 60° in radians
                
                // Calculate new speed vector
                let currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                ball.dx = currentSpeed * Math.sin(angle);
                ball.dy = -Math.abs(currentSpeed * Math.cos(angle)); // Always bounce upward
                
                // Play sound
                createSound(400, 100);
            }
        }

        // Check wall collisions
        function checkWallCollisions(ball) {
            // Left and right walls (with proper boundaries)
            if (ball.x + BALL_RADIUS > CANVAS_WIDTH - 20 || ball.x - BALL_RADIUS < 16) {
                ball.dx = -ball.dx;
                createSound(350, 80);
            }
            
            // Top wall
            if (ball.y - BALL_RADIUS < 40) {
                ball.dy = -ball.dy;
                createSound(250, 80);
            }
        }

        // Update paddle position
        function updatePaddle() {
            if (rightPressed && paddleX < CANVAS_WIDTH - PADDLE_WIDTH - 20) {
                paddleX += 10;
            } else if (leftPressed && paddleX > 16) {
                paddleX -= 8;
            }
        }

        // Update ball positions
        function updateBalls() {
            for (let i = 0; i < balls.length; i++) {
                let ball = balls[i];
                if (!ball.active) continue;
                
                ball.x += ball.dx;
                ball.y += ball.dy;
                
                checkWallCollisions(ball);
                checkPaddleCollision(ball);
                
                // Ball falls below paddle
                if (ball.y > CANVAS_HEIGHT) {
                    ball.active = false;
                    
                    // Check if all balls are lost
                    let activeBalls = balls.filter(b => b.active).length;
                    if (activeBalls === 0) {
                        lives--;
                        if (lives <= 0) {
                            gameRunning = false;
                            gameOver = true;
                        } else {
                            // Create new ball after delay
                            setTimeout(() => {
                                let newBall = {
                                    x: CANVAS_WIDTH / 2,
                                    y: PADDLE_Y - BALL_RADIUS,
                                    dx: initialBallSpeed * (Math.random() > 0.5 ? 1 : -1),
                                    dy: -initialBallSpeed,
                                    active: true
                                };
                                balls.push(newBall);
                            }, 500);
                        }
                    }
                }
            }
        }

        // Shrink paddle based on bricks cleared
        function updatePaddleSize() {
            let bricksCleared = totalBricks - countActiveBricks();
            let percentageCleared = bricksCleared / totalBricks;
            
            if (percentageCleared >= shrinkThreshold2 && !paddleShrunkTwice) {
                PADDLE_WIDTH = originalPaddleWidth * 0.5;
                paddleShrunkTwice = true;
                createSound(600, 280);
            } else if (percentageCleared >= shrinkThreshold1 && !paddleShrunkOnce) {
                PADDLE_WIDTH = originalPaddleWidth * 3/4; // 75% size
                paddleShrunkOnce = true;
                createSound(560, 280);
            }
        }

        // Check win condition
        function checkWin() {
            return countActiveBricks() === 0;
        }

        // Draw game over screen
        function drawGameOver() {
            ctx.fillStyle = "rgba(10, 10, 10, 255)";
            ctx.fillRect(0, 30, CANVAS_WIDTH, CANVAS_HEIGHT-60);
            
            ctx.font = "48px 'Courier New', monospace";
            ctx.fillStyle = "#FF0000";
            ctx.textAlign = "center";
            ctx.fillText("GAME OVER", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 3);
            
            ctx.font = "36px 'Courier New', monospace";
            ctx.fillStyle = "#FFFFFF";
            ctx.fillText("SCORE: " + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            
            ctx.font = "24px 'Courier New', monospace";
            ctx.fillText("Press R to Replay", CANVAS_WIDTH / 2, CANVAS_HEIGHT * 0.75);
        }

        // Draw win screen
        function drawWin() {
            ctx.fillStyle = "rgba(10, 30, 10, 9)";
            ctx.fillRect(0, 30, CANVAS_WIDTH, CANVAS_HEIGHT-60);
            
            ctx.font = "48px 'Courier New', monospace";
            ctx.fillStyle = "#00FF00";
            ctx.textAlign = "center";
            ctx.fillText("YOU WIN!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 3);
            
            ctx.font = "36px 'Courier New', monospace";
            ctx.fillStyle = "#FFFFFF";
            ctx.fillText("SCORE: " + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 1.8);
            
            ctx.font = "24px 'Courier New', monospace";
            ctx.fillText("Press R to Replay", CANVAS_WIDTH / 2, CANVAS_HEIGHT * 0.75);
        }

        // Reset game
        function resetGame() {
            score = 0;
            lives = 3;
            paddleX = (CANVAS_WIDTH - PADDLE_WIDTH) / 2;
            PADDLE_WIDTH = originalPaddleWidth; // Reset paddle size
            paddleShrunkOnce = false;
            paddleShrunkTwice = false;
            
            gameRunning = true;
            gameOver = false;
            gameWon = false;
            
            initBricks();
            initBalls();
        }

        // Main draw function
        function draw() {
            ctx.clearRect(0, 24, CANVAS_WIDTH, CANVAS_HEIGHT-24);
            
            if (gameRunning) {
                drawBricks();
                drawPaddle();
                
                for (let ball of balls) {
                    drawBall(ball);
                }
                
                drawBoundaries();
                drawScore();
                
                collisionDetection();
                updateBalls();
                updatePaddle();
                updatePaddleSize();
                
                if (checkWin()) {
                    gameRunning = false;
                    gameWon = true;
                }
            } else {
                if (gameOver) {
                    drawGameOver();
                } else if (gameWon) {
                    drawWin();
                }
            }
            
            requestAnimationFrame(draw);
        }

        // Event listeners
        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);
        document.addEventListener("mousemove", mouseMoveHandler, false);

        function keyDownHandler(e) {
            if (e.key === "Right" || e.key === "ArrowRight") {
                rightPressed = true;
            } else if (e.key === "Left" || e.key === "ArrowLeft") {
                leftPressed = true;
            } else if ((e.key === "r" || e.key === "R") && (!gameRunning || gameOver || gameWon)) {
                resetGame();
            }
        }

        function keyUpHandler(e) {
            if (e.key === "Right" || e.key === "ArrowRight") {
                rightPressed = false;
            } else if (e.key === "Left" || e.key === "ArrowLeft") {
                leftPressed = false;
            }
        }

        function mouseMoveHandler(e) {
            let relativeX = e.clientX - canvas.getBoundingClientRect().left;
            if (relativeX > 0 && relativeX < CANVAS_WIDTH) {
                paddleX = relativeX - PADDLE_WIDTH / 2;
                
                // Keep paddle within bounds
                if (paddleX < 16) {
                    paddleX = 8;
                } else if (paddleX + PADDLE_WIDTH > CANVAS_WIDTH - 20) {
                    paddleX = CANVAS_WIDTH - PADDLE_WIDTH - 8;
                }
            }
        }

        // Initialize game
        initBricks();
        initBalls();
        draw();
    </script>
</body>
</html>