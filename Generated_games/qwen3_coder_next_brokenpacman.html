<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man 1980 Remake</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: #111;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive; /* Arcade Font */
            overflow: hidden;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 255, 0.5);
            border: 4px solid #1919A6; /* Classic Blue */
            border-radius: 4px;
        }

        canvas {
            display: block;
            background-color: black;
        }

        #ui-layer {
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            color: white;
            text-transform: uppercase;
            font-size: 18px;
            max-width: 440px; /* Matches canvas width */
        }

        .score-box {
            color: #FFD700;
        }
        
        .lives-box {
            color: #FFD700;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        h1 {
            color: #FFD700;
            text-shadow: 4px 4px #b30000;
            font-size: 48px;
            margin-bottom: 20px;
            line-height: 1.5;
            text-align: center;
        }

        p {
            color: white;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.6;
            font-size: 14px;
            max-width: 80%;
        }

        button {
            background-color: #FFD700;
            border: none;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            cursor: pointer;
            color: black;
            box-shadow: 4px 4px 0px #b30000;
            transition: transform 0.1s;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px #b30000;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="score-box">SCORE: <span id="scoreEl">0</span></div>
        <div class="lives-box">LIVES: <span id="livesEl">3</span></div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="440" height="520"></canvas>
        
        <div id="overlay">
            <h1>PAC-MAN</h1>
            <p>Use Arrow Keys to Move.<br>Eat all dots to win.<br>Avoid the ghosts!</p>
            <button id="startBtn">INSERT COIN (START)</button>
        </div>
    </div>

<script>
/**
 * PAC-MAN 1980 REMAKE
 * 
 * Core Logic:
 * - Grid based movement system.
 * - Tile Map: 0=Empty, 1=Wall, 2=Dot, 3=PowerPellet, 4=GhostHouse, 5=Door
 * - Canvas Rendering for all graphics (No external images).
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('scoreEl');
const livesEl = document.getElementById('livesEl');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const titleText = overlay.querySelector('h1');
const descText = overlay.querySelector('p');

// --- CONSTANTS & CONFIG ---
const TILE_SIZE = 20;
const PACMAN_SPEED = 2; // Pixels per frame (Must be divisor of TILE_SIZE)
const GHOST_SPEED = 2;
const GHOST_SCARED_SPEED = 1;

// Map Layout (22 columns x 26 rows)
// 1: Wall, 0: Empty, 2: Dot, 3: Power Pellet, 4: Ghost House, 5: Door
const LEVEL_MAP = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,1,2,1],
    [1,3,1,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,1,3,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,1,2,1],
    [1,2,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,2,1],
    [1,1,1,1,1,2,1,1,1,0,1,1,0,1,1,1,2,1,1,1,1,1],
    [0,0,0,0,1,2,1,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0],
    [1,1,1,1,1,2,1,0,1,1,5,5,1,1,0,1,2,1,1,1,1,1],
    [0,2,2,2,2,2,0,0,1,4,4,4,4,1,0,0,2,2,2,2,2,0], // Tunnel row
    [1,1,1,1,1,2,1,0,1,1,1,1,1,1,0,1,2,1,1,1,1,1],
    [0,0,0,0,1,2,1,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0],
    [1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,1,1,2,1,1,2,1,1,1,2,1,1,1,2,1],
    [1,3,2,1,1,2,2,2,2,2,0,0,2,2,2,2,2,1,1,2,3,1],
    [1,1,2,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,2,1,1],
    [1,2,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// Directions
const UP = { x: 0, y: -1 };
const DOWN = { x: 0, y: 1 };
const LEFT = { x: -1, y: 0 };
const RIGHT = { x: 1, y: 0 };
const STOP = { x: 0, y: 0 };

// --- GAME STATE ---
let score = 0;
let lives = 3;
let level = 1;
let gameRunning = false;
let animationId;
let dotsRemaining = 0;
let powerModeTime = 0;
let fruitActive = false;
let fruitTimer = 0;
let fruitScorePending = 0;

// Entities
let pacman;
let ghosts = [];
let fruits = [];

// --- CLASSES ---

class Entity {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.dir = STOP;
        this.nextDir = STOP;
        this.radius = TILE_SIZE / 2 - 2;
        this.speed = PACMAN_SPEED;
    }

    getGridPos() {
        return {
            c: Math.floor((this.x + TILE_SIZE / 2) / TILE_SIZE),
            r: Math.floor((this.y + TILE_SIZE / 2) / TILE_SIZE)
        };
    }

    // Check if entity is perfectly centered on a tile
    isCentered() {
        return this.x % TILE_SIZE === TILE_SIZE / 2 && this.y % TILE_SIZE === TILE_SIZE / 2;
    }

    canMove(direction) {
        const gp = this.getGridPos();
        const nextR = gp.r + direction.y;
        const nextC = gp.c + direction.x;

        // Tunnel handling for checking walls
        if (nextC < 0 || nextC >= LEVEL_MAP[0].length) return true;

        if (nextR >= 0 && nextR < LEVEL_MAP.length) {
            const tile = LEVEL_MAP[nextR][nextC];
            return tile !== 1 && tile !== 5; // 1 is wall, 5 is door (only ghosts can enter usually)
        }
        return false;
    }

    move() {
        // Tunnel Wrapping
        if (this.x < -TILE_SIZE / 2) this.x = canvas.width + TILE_SIZE / 2;
        if (this.x > canvas.width + TILE_SIZE / 2) this.x = -TILE_SIZE / 2;

        // Only change direction when centered on tile to prevent getting stuck
        if (this.isCentered()) {
            // Try to turn to nextDir
            if (this.nextDir !== STOP && this.canMove(this.nextDir)) {
                this.dir = this.nextDir;
                this.nextDir = STOP;
            }

            // Stop if hitting a wall
            if (!this.canMove(this.dir)) {
                this.dir = STOP;
            }
        }

        this.x += this.dir.x * this.speed;
        this.y += this.dir.y * this.speed;
    }
}

class Pacman extends Entity {
    constructor(x, y) {
        super(x, y, 'yellow');
        this.mouthOpen = 0;
        this.mouthSpeed = 0.2;
        this.rotation = 0;
    }

    update() {
        this.move();
        
        // Animation Logic
        if (this.dir !== STOP) {
            this.mouthOpen += this.mouthSpeed;
            if (this.mouthOpen > 0.25 || this.mouthOpen < 0) this.mouthSpeed = -this.mouthSpeed;
            
            // Calculate rotation for drawing
            if (this.dir === RIGHT) this.rotation = 0;
            if (this.dir === DOWN) this.rotation = Math.PI / 2;
            if (this.dir === LEFT) this.rotation = Math.PI;
            if (this.dir === UP) this.rotation = -Math.PI / 2;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2);
        ctx.rotate(this.rotation);
        
        ctx.fillStyle = '#FFFF00';
        ctx.beginPath();
        // Draw Pacman with mouth animation
        const mouthAngle = 0.2 * Math.PI * (this.mouthOpen > 0 ? this.mouthOpen : -this.mouthOpen);
        ctx.arc(0, 0, this.radius, mouthAngle, 2 * Math.PI - mouthAngle);
        ctx.lineTo(0, 0);
        ctx.fill();
        
        // Simple Eye
        if (this.dir !== DOWN) {
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.radius/2, -this.radius/3, this.radius/4, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.restore();
    }
}

class Ghost extends Entity {
    constructor(x, y, color, type) {
        super(x, y, color);
        this.type = type; // 'blinky', 'pinky', 'inky', 'clyde'
        this.originalColor = color;
        this.scared = false;
        this.eaten = false;
        this.speed = GHOST_SPEED;
        
        // Start moving randomly
        this.dir = [LEFT, RIGHT][Math.floor(Math.random() * 2)];
    }

    update() {
        // Adjust speed based on state
        if (this.eaten) this.speed = 4; // Return to base fast
        else if (this.scared) this.speed = GHOST_SCARED_SPEED;
        else this.speed = GHOST_SPEED;

        // AI Logic at intersections
        if (this.isCentered()) {
            const possibleMoves = [];
            
            // Check all 4 directions
            [UP, DOWN, LEFT, RIGHT].forEach(d => {
                // Don't reverse direction immediately unless stuck or eaten
                if (!this.eaten && d.x === -this.dir.x && d.y === -this.dir.y) return;
                
                if (this.canMove(d)) {
                    possibleMoves.push(d);
                }
            });

            // If dead end (only way back), add reverse
            if (possibleMoves.length === 0) {
                possibleMoves.push({ x: -this.dir.x, y: -this.dir.y });
            }

            // Choose best move based on AI Type
            let target = { x: pacman.getGridPos().c, y: pacman.getGridPos().r };

            if (this.eaten) {
                // Target is the ghost house (approx center of map)
                target = { x: 10, y: 10 }; 
                if (this.x === 10 * TILE_SIZE && this.y === 10 * TILE_SIZE) {
                    this.eaten = false;
                    this.scared = false;
                    this.speed = GHOST_SPEED;
                }
            } else if (this.scared) {
                // Random movement when scared
                target = null; 
            } else {
                // Aggressive AI
                if (this.type === 'blinky') { // Red: Direct Chase
                    target = { x: pacman.getGridPos().c, y: pacman.getGridPos().r };
                } else if (this.type === 'pinky') { // Pink: Ambush (4 tiles ahead)
                    target = { 
                        x: pacman.getGridPos().c + (pacman.dir.x * 4), 
                        y: pacman.getGridPos().r + (pacman.dir.y * 4) 
                    };
                } else if (this.type === 'inky') { // Cyan: Flank (Randomized Chase)
                    target = { 
                        x: pacman.getGridPos().c + (Math.random() > 0.5 ? 6 : -6), 
                        y: pacman.getGridPos().r 
                    };
                } else if (this.type === 'clyde') { // Orange: Erratic (Chase if far, Scatter if close)
                    const dist = Math.abs(this.x - pacman.x) + Math.abs(this.y - pacman.y);
                    if (dist > 200) {
                        target = { x: pacman.getGridPos().c, y: pacman.getGridPos().r };
                    } else {
                        target = { x: 0, y: LEVEL_MAP.length - 1 }; // Bottom left corner
                    }
                }
            }

            if (target) {
                // Sort moves by distance to target
                possibleMoves.sort((a, b) => {
                    const posA = { c: this.getGridPos().c + a.x, r: this.getGridPos().r + a.y };
                    const posB = { c: this.getGridPos().c + b.x, r: this.getGridPos().r + b.y };
                    
                    const distA = Math.abs(posA.c - target.x) + Math.abs(posA.r - target.y);
                    const distB = Math.abs(posB.c - target.x) + Math.abs(posB.r - target.y);
                    
                    return distA - distB;
                });
                
                // Pick best move, but add a little randomness for Pinky/Clyde so it's not perfect
                if (Math.random() < 0.1 && this.type !== 'blinky') {
                    this.dir = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                } else {
                    this.dir = possibleMoves[0];
                }
            } else {
                // Scared mode: Random choice
                this.dir = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            }
        }

        this.x += this.dir.x * this.speed;
        this.y += this.dir.y * this.speed;

        // Tunnel Wrapping
        if (this.x < -TILE_SIZE / 2) this.x = canvas.width + TILE_SIZE / 2;
        if (this.x > canvas.width + TILE_SIZE / 2) this.x = -TILE_SIZE / 2;
    }

    draw() {
        const cx = this.x + TILE_SIZE / 2;
        const cy = this.y + TILE_SIZE / 2;

        // Color Logic
        let drawColor = this.originalColor;
        if (this.scared) {
            // Flash white near end of scared time
            if (powerModeTime < 120 && Math.floor(Date.now() / 200) % 2 === 0) {
                drawColor = 'white';
            } else {
                drawColor = '#0000FF'; // Classic Scared Blue
            }
        }
        if (this.eaten) {
            drawColor = 'transparent'; // Only eyes visible
        }

        // Draw Body (Dome + Feet)
        ctx.fillStyle = drawColor;
        ctx.beginPath();
        ctx.arc(cx, cy - 2, this.radius, Math.PI, 0);
        
        // Wavy feet
        for (let i = 1; i <= 3; i++) {
            ctx.lineTo(cx + this.radius - (2 * this.radius / 3) * i, cy + this.radius);
            if (i < 3) {
                ctx.lineTo(cx + this.radius - (2 * this.radius / 3) * i - (this.radius / 3), cy + this.radius - (i % 2 === 0 ? 0 : 3));
            }
        }
        ctx.fill();

        // Draw Eyes
        if (!this.eaten) {
            ctx.fillStyle = 'white';
            const eyeOffsetX = this.dir.x * 2;
            const eyeOffsetY = this.dir.y * 2;

            // Left Eye
            ctx.beginPath();
            ctx.arc(cx - 4 + eyeOffsetX, cy - 4 + eyeOffsetY, 4, 0, Math.PI * 2);
            ctx.fill();

            // Right Eye
            ctx.beginPath();
            ctx.arc(cx + 4 + eyeOffsetX, cy - 4 + eyeOffsetY, 4, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = 'blue';
            ctx.beginPath();
            ctx.arc(cx - 4 + eyeOffsetX * 1.5, cy - 4 + eyeOffsetY * 1.5, 2, 0, Math.PI * 2);
            ctx.arc(cx + 4 + eyeOffsetX * 1.5, cy - 4 + eyeOffsetY * 1.5, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

class Fruit {
    constructor() {
        this.x = 10 * TILE_SIZE;
        this.y = 16 * TILE_SIZE; // Near ghost house
        this.active = false;
        this.timer = 0;
        this.type = 'cherry';
    }

    spawn() {
        this.active = true;
        this.timer = 600; // Frames (approx 10 seconds)
        this.x = 10 * TILE_SIZE;
        this.y = 16 * TILE_SIZE;
    }

    update() {
        if (this.active) {
            this.timer--;
            if (this.timer <= 0) this.active = false;
        }
    }

    draw() {
        if (!this.active) return;

        const cx = this.x + TILE_SIZE/2;
        const cy = this.y + TILE_SIZE/2;

        // Draw Fruit based on type
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(cx, cy, 8, 0, Math.PI * 2);
        ctx.fill();

        // Stem
        ctx.strokeStyle = '#00FF00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx, cy - 8);
        ctx.quadraticCurveTo(cx + 5, cy - 12, cx + 8, cy - 10);
        ctx.stroke();

        // Leaf
        ctx.fillStyle = '#00FF00';
        ctx.beginPath();
        ctx.ellipse(cx + 6, cy - 12, 4, 2, Math.PI / 4, 0, Math.PI * 2);
        ctx.fill();
    }
}

// --- INITIALIZATION ---

function initGame() {
    score = 0;
    lives = 3;
    level = 1;
    updateUI();
    resetLevel();
    gameRunning = true;
    overlay.classList.add('hidden');
    gameLoop();
}

function resetLevel() {
    // Parse Map
    dotsRemaining = 0;
    ghosts = [];
    
    // Reset Map Dots (Deep copy logic needed if we wanted to keep map state, 
    // but for this simple version we just scan the static array)
    let ghostCount = 0;
    
    // We need to find spawn points from the map
    const pacmanStart = { x: 10 * TILE_SIZE, y: 15 * TILE_SIZE }; // Approximate center bottom
    
    // Scan map for dots
    for(let r=0; r<LEVEL_MAP.length; r++){
        for(let c=0; c<LEVEL_MAP[0].length; c++){
            if(LEVEL_MAP[r][c] === 2 || LEVEL_MAP[r][c] === 3) {
                dotsRemaining++;
            }
        }
    }

    pacman = new Pacman(pacmanStart.x, pacmanStart.y);
    
    // Spawn Ghosts
    ghosts.push(new Ghost(10 * TILE_SIZE, 8 * TILE_SIZE, 'red', 'blinky')); // Blinky (Outside house)
    ghosts.push(new Ghost(9 * TILE_SIZE, 10 * TILE_SIZE, 'pink', 'pinky')); // Pinky (Inside house)
    ghosts.push(new Ghost(10 * TILE_SIZE, 10 * TILE_SIZE, 'cyan', 'inky')); // Inky (Inside house)
    ghosts.push(new Ghost(11 * TILE_SIZE, 10 * TILE_SIZE, 'orange', 'clyde')); // Clyde (Inside house)

    fruitActive = false;
    fruits = [new Fruit()];
}

function resetPositions() {
    const pacmanStart = { x: 10 * TILE_SIZE, y: 15 * TILE_SIZE };
    pacman.x = pacmanStart.x;
    pacman.y = pacmanStart.y;
    pacman.dir = STOP;
    pacman.nextDir = STOP;

    ghosts[0].x = 10 * TILE_SIZE; ghosts[0].y = 8 * TILE_SIZE; // Blinky
    ghosts[1].x = 9 * TILE_SIZE; ghosts[1].y = 10 * TILE_SIZE; // Pinky
    ghosts[2].x = 10 * TILE_SIZE; ghosts[2].y = 10 * TILE_SIZE; // Inky
    ghosts[3].x = 11 * TILE_SIZE; ghosts[3].y = 10 * TILE_SIZE; // Clyde

    ghosts.forEach(g => {
        g.scared = false;
        g.eaten = false;
        g.dir = [LEFT, RIGHT][Math.floor(Math.random() * 2)];
    });
}

// --- INPUT HANDLING ---

window.addEventListener('keydown', (e) => {
    if (!gameRunning) return;

    switch(e.key) {
        case 'ArrowUp': pacman.nextDir = UP; break;
        case 'ArrowDown': pacman.nextDir = DOWN; break;
        case 'ArrowLeft': pacman.nextDir = LEFT; break;
        case 'ArrowRight': pacman.nextDir = RIGHT; break;
    }
});

startBtn.addEventListener('click', () => {
    initGame();
});

// --- GAME LOGIC ---

function update() {
    if (!gameRunning) return;

    // Fruit Logic
    if (level === 1 && score > 700 && !fruitActive && Math.random() < 0.005) {
        fruits[0].spawn();
    }
    
    fruits.forEach(f => f.update());

    pacman.update();

    // Dot Eating
    const gp = pacman.getGridPos();
    if (gp.r >= 0 && gp.r < LEVEL_MAP.length && gp.c >= 0 && gp.c < LEVEL_MAP[0].length) {
        const tile = LEVEL_MAP[gp.r][gp.c];

        if (tile === 2) { // Normal Dot
            LEVEL_MAP[gp.r][gp.c] = 0;
            score += 10;
            dotsRemaining--;
            playSound('chomp');
        } else if (tile === 3) { // Power Pellet
            LEVEL_MAP[gp.r][gp.c] = 0;
            score += 50;
            dotsRemaining--;
            activatePowerMode();
            playSound('power');
        }
    }

    // Fruit Collision
    fruits.forEach(f => {
        if (f.active) {
            const dx = pacman.x - f.x;
            const dy = pacman.y - f.y;
            if (Math.sqrt(dx*dx + dy*dy) < TILE_SIZE) {
                score += 100; // Classic value
                f.active = false;
                playSound('fruit');
            }
        }
    });

    // Ghost Logic
    ghosts.forEach(ghost => {
        ghost.update();

        // Collision with Pacman
        const dx = pacman.x - ghost.x;
        const dy = pacman.y - ghost.y;
        const distance = Math.sqrt(dx*dx + dy*dy);

        if (distance < TILE_SIZE) {
            if (ghost.scared && !ghost.eaten) {
                // Eat Ghost
                ghost.eaten = true;
                score += 200;
                playSound('eat_ghost');
            } else if (!ghost.eaten) {
                // Pacman Dies
                handleDeath();
            }
        }
    });

    // Level Complete
    if (dotsRemaining === 0) {
        level++;
        score += 1000; // Level clear bonus
        resetLevel();
        alert(`LEVEL ${level}!`); // Simple pause
    }

    updateUI();
}

function activatePowerMode() {
    powerModeTime = 600; // Frames (approx 10 seconds at 60fps)
    ghosts.forEach(g => g.scared = true);
}

function handleDeath() {
    lives--;
    playSound('die');
    updateUI();

    if (lives <= 0) {
        gameOver();
    } else {
        resetPositions();
        // Small pause
        gameRunning = false;
        setTimeout(() => {
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }, 1500);
    }
}

function gameOver() {
    gameRunning = false;
    titleText.innerText = "GAME OVER";
    descText.innerHTML = `Final Score: ${score}<br>Press Button to Restart`;
    startBtn.innerText = "TRY AGAIN";
    overlay.classList.remove('hidden');
}

function updateUI() {
    scoreEl.innerText = score;
    livesEl.innerText = lives;
    
    // Draw Lives in Canvas UI area (optional, but nice)
    ctx.fillStyle = 'yellow';
    for(let i=0; i<lives - 1; i++) { // -1 because current life is pacman
        ctx.beginPath();
        ctx.arc(20 + (i * 25), canvas.height - 10, 8, 0.2 * Math.PI, 1.8 * Math.PI);
        ctx.lineTo(20 + (i * 25), canvas.height - 10);
        ctx.fill();
    }
}

// --- RENDERING ---

function drawMap() {
    for (let r = 0; r < LEVEL_MAP.length; r++) {
        for (let c = 0; c < LEVEL_MAP[0].length; c++) {
            const tile = LEVEL_MAP[r][c];
            const x = c * TILE_SIZE;
            const y = r * TILE_SIZE;

            if (tile === 1) {
                // Draw Wall
                ctx.fillStyle = '#1919A6'; // Classic Blue
                
                // Simple block walls. For "great" detail, we'd draw specific wall segments.
                // To keep code concise but looking good, we draw a slightly smaller box inside
                // to simulate double-line walls like the original.
                ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                
                // Inner detail (white line)
                ctx.fillStyle = 'black';
                ctx.fillRect(x + 6, y + 6, TILE_SIZE - 12, TILE_SIZE - 12);

            } else if (tile === 2) {
                // Dot
                ctx.fillStyle = '#ffb8ae';
                ctx.beginPath();
                ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 3, 0, Math.PI * 2);
                ctx.fill();

            } else if (tile === 3) {
                // Power Pellet
                // Blink effect
                if (Math.floor(Date.now() / 200) % 2 === 0) {
                    ctx.fillStyle = '#ffb8ae';
                    ctx.beginPath();
                    ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 7, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (tile === 5) {
                // Ghost Door
                ctx.strokeStyle = 'pink';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y + TILE_SIZE/2);
                ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE/2);
                ctx.stroke();
            }
        }
    }
}

function draw() {
    // Clear Screen
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawMap();

    fruits.forEach(f => f.draw());
    
    ghosts.forEach(g => g.draw());
    
    pacman.draw();

    // Draw "Scared" Text if active
    if (powerModeTime > 0 && powerModeTime < 200) {
        ctx.fillStyle = 'white';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText("SCARED!", canvas.width/2, 50);
    }
}

function gameLoop() {
    if (!gameRunning) return;

    // Power Mode Timer
    if (powerModeTime > 0) {
        powerModeTime--;
        if (powerModeTime === 0) {
            ghosts.forEach(g => g.scared = false);
        }
    }

    update();
    draw();

    animationId = requestAnimationFrame(gameLoop);
}

// --- AUDIO SIMULATION (Synthesized) ---
// Since we cannot use external files, we use Web Audio API for simple beeps
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === 'chomp') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(400, now + 0.1);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'power') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.3);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    } else if (type === 'eat_ghost') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
    } else if (type === 'die') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(500, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 1);
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 1);
        osc.start(now);
        osc.stop(now + 1);
    } else if (type === 'fruit') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.setValueAtTime(900, now + 0.1);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    }
}

// Initial Draw
drawMap();

</script>
</body>
</html>