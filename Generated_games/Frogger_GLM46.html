<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frogger - 1981 Konami Classic</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        .game-container {
            background: #000;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
        }
        
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 2px solid #00ff00;
        }
        
        .controls {
            margin-top: 15px;
            text-align: center;
            color: #00ff00;
        }
        
        .info-panel {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 10px;
            background: #111;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-size: 18px;
        }
        
        .lives {
            display: flex;
            gap: 5px;
        }
        
        .life-icon {
            width: 20px;
            height: 20px;
            background: #0f0;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="info-panel">
            <div>SCORE: <span id="score">0</span></div>
            <div>HIGH: <span id="highScore">0</span></div>
            <div>TIME: <span id="timer">60</span></div>
            <div class="lives" id="lives"></div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            Use ARROW KEYS to move | SPACE to start | 1-3 for difficulty
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const GRID_SIZE = 40;
        const ROWS = 13;
        const COLS = 15;
        canvas.width = COLS * GRID_SIZE;
        canvas.height = ROWS * GRID_SIZE;
        
        // Game state
        let gameState = {
            score: 0,
            highScore: localStorage.getItem('froggerHighScore') || 0,
            lives: 3,
            level: 1,
            timer: 60,
            gameRunning: false,
            gameOver: false,
            homesOccupied: [false, false, false, false, false],
            difficulty: 1
        };
        
        // Frog object
        class Frog {
            constructor() {
                this.reset();
                this.jumpAnimation = 0;
                this.facing = 'up';
                this.legPhase = 0;
            }
            
            reset() {
                this.x = Math.floor(COLS / 2);
                this.y = ROWS - 1;
                this.attachedTo = null;
                this.jumpAnimation = 0;
            }
            
            move(dx, dy) {
                const newX = this.x + dx;
                const newY = this.y + dy;
                
                if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS) {
                    this.x = newX;
                    this.y = newY;
                    this.jumpAnimation = 10;
                    
                    // Update facing direction
                    if (dx > 0) this.facing = 'right';
                    else if (dx < 0) this.facing = 'left';
                    else if (dy > 0) this.facing = 'down';
                    else if (dy < 0) this.facing = 'up';
                    
                    // Animate legs
                    this.legPhase = (this.legPhase + 1) % 4;
                }
            }
            
            update() {
                if (this.jumpAnimation > 0) {
                    this.jumpAnimation--;
                }
                
                // Move with attached platform
                if (this.attachedTo) {
                    this.x += this.attachedTo.speed * this.attachedTo.direction;
                    
                    // Check if frog went off screen
                    if (this.x < -1 || this.x > COLS) {
                        this.die();
                    }
                }
            }
            
            die() {
                gameState.lives--;
                updateUI();
                
                if (gameState.lives <= 0) {
                    gameState.gameOver = true;
                    gameState.gameRunning = false;
                } else {
                    this.reset();
                }
            }
            
            draw() {
                const pixelX = this.x * GRID_SIZE + GRID_SIZE / 2;
                const pixelY = this.y * GRID_SIZE + GRID_SIZE / 2;
                
                // Jump animation offset
                const jumpOffset = Math.sin(this.jumpAnimation * 0.3) * 5;
                
                ctx.save();
                ctx.translate(pixelX, pixelY - jumpOffset);
                
                // Rotate based on facing direction
                let rotation = 0;
                if (this.facing === 'right') rotation = Math.PI / 2;
                else if (this.facing === 'down') rotation = Math.PI;
                else if (this.facing === 'left') rotation = -Math.PI / 2;
                ctx.rotate(rotation);
                
                // Draw frog body
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.ellipse(0, 0, 15, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw darker green spots
                ctx.fillStyle = '#008800';
                for (let i = 0; i < 5; i++) {
                    const spotX = (Math.random() - 0.5) * 20;
                    const spotY = (Math.random() - 0.5) * 15;
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw eyes
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(-6, -8, 4, 0, Math.PI * 2);
                ctx.arc(6, -8, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(-6, -8, 2, 0, Math.PI * 2);
                ctx.arc(6, -8, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw legs with animation
                const legOffset = Math.sin(this.legPhase * Math.PI / 2) * 3;
                
                // Front legs
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-8, -5);
                ctx.lineTo(-12 + legOffset, 0);
                ctx.moveTo(8, -5);
                ctx.lineTo(12 - legOffset, 0);
                ctx.stroke();
                
                // Back legs
                ctx.beginPath();
                ctx.moveTo(-10, 5);
                ctx.lineTo(-15 - legOffset, 10);
                ctx.moveTo(10, 5);
                ctx.lineTo(15 + legOffset, 10);
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        // Vehicle class
        class Vehicle {
            constructor(lane, type, speed, direction) {
                this.lane = lane;
                this.type = type; // 'car', 'truck', 'bus'
                this.speed = speed * gameState.difficulty;
                this.direction = direction;
                this.x = direction > 0 ? -2 : COLS + 2;
                this.y = ROWS - 6 + lane;
                this.width = type === 'truck' ? 3 : type === 'bus' ? 4 : 2;
                this.height = 1;
                this.color = this.getColor();
            }
            
            getColor() {
                const colors = ['#ff0000', '#ffff00', '#ff8800', '#00ffff', '#ff00ff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update() {
                this.x += this.speed * this.direction;
                
                // Wrap around
                if (this.direction > 0 && this.x > COLS + 2) {
                    this.x = -2;
                } else if (this.direction < 0 && this.x < -2) {
                    this.x = COLS + 2;
                }
            }
            
            draw() {
                const pixelX = this.x * GRID_SIZE;
                const pixelY = this.y * GRID_SIZE;
                
                // Draw vehicle body
                ctx.fillStyle = this.color;
                ctx.fillRect(pixelX, pixelY + 5, this.width * GRID_SIZE - 10, GRID_SIZE - 15);
                
                // Draw wheels
                ctx.fillStyle = '#333';
                for (let i = 0; i < this.width; i++) {
                    ctx.beginPath();
                    ctx.arc(pixelX + 10 + i * GRID_SIZE, pixelY + GRID_SIZE - 8, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw headlights
                if (this.direction > 0) {
                    ctx.fillStyle = '#ffff88';
                    ctx.fillRect(pixelX + this.width * GRID_SIZE - 15, pixelY + 10, 5, 8);
                } else {
                    ctx.fillStyle = '#ffff88';
                    ctx.fillRect(pixelX + 10, pixelY + 10, 5, 8);
                }
            }
            
            checkCollision(frog) {
                if (Math.floor(this.y) === frog.y) {
                    const frogLeft = frog.x;
                    const frogRight = frog.x + 1;
                    const vehLeft = this.x;
                    const vehRight = this.x + this.width;
                    
                    if (frogLeft < vehRight && frogRight > vehLeft) {
                        return true;
                    }
                }
                return false;
            }
        }
        
        // Log class
        class Log {
            constructor(lane, speed, direction) {
                this.lane = lane;
                this.speed = speed * gameState.difficulty;
                this.direction = direction;
                this.x = direction > 0 ? -3 : COLS + 3;
                this.y = 1 + lane;
                this.width = 3 + Math.floor(Math.random() * 2);
                this.height = 1;
            }
            
            update() {
                this.x += this.speed * this.direction;
                
                // Wrap around
                if (this.direction > 0 && this.x > COLS + 3) {
                    this.x = -3;
                } else if (this.direction < 0 && this.x < -3) {
                    this.x = COLS + 3;
                }
            }
            
            draw() {
                const pixelX = this.x * GRID_SIZE;
                const pixelY = this.y * GRID_SIZE;
                
                // Draw log body
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(pixelX, pixelY + 8, this.width * GRID_SIZE - 5, GRID_SIZE - 16);
                
                // Draw wood texture
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                for (let i = 0; i < this.width; i++) {
                    ctx.beginPath();
                    ctx.moveTo(pixelX + i * GRID_SIZE + 10, pixelY + 8);
                    ctx.lineTo(pixelX + i * GRID_SIZE + 10, pixelY + GRID_SIZE - 8);
                    ctx.stroke();
                }
            }
            
            checkCollision(frog) {
                if (Math.floor(this.y) === frog.y) {
                    const frogLeft = frog.x;
                    const frogRight = frog.x + 1;
                    const logLeft = this.x;
                    const logRight = this.x + this.width;
                    
                    if (frogLeft >= logLeft && frogRight <= logRight) {
                        return true;
                    }
                }
                return false;
            }
        }
        
        // Turtle class
        class Turtle {
            constructor(lane, speed, direction) {
                this.lane = lane;
                this.speed = speed * gameState.difficulty;
                this.direction = direction;
                this.x = direction > 0 ? -3 : COLS + 3;
                this.y = 1 + lane;
                this.width = 2;
                this.height = 1;
                this.diveTimer = 0;
                this.isDiving = false;
                this.divePhase = 0;
            }
            
            update() {
                this.x += this.speed * this.direction;
                
                // Dive animation
                this.diveTimer++;
                if (this.diveTimer > 120) {
                    this.isDiving = !this.isDiving;
                    this.diveTimer = 0;
                    this.divePhase = 0;
                }
                
                if (this.isDiving) {
                    this.divePhase = Math.min(this.divePhase + 0.1, 1);
                } else {
                    this.divePhase = Math.max(this.divePhase - 0.1, 0);
                }
                
                // Wrap around
                if (this.direction > 0 && this.x > COLS + 3) {
                    this.x = -3;
                } else if (this.direction < 0 && this.x < -3) {
                    this.x = COLS + 3;
                }
            }
            
            draw() {
                const pixelX = this.x * GRID_SIZE;
                const pixelY = this.y * GRID_SIZE;
                
                // Draw turtle shell
                ctx.fillStyle = '#228B22';
                ctx.globalAlpha = 1 - this.divePhase * 0.7;
                ctx.beginPath();
                ctx.ellipse(pixelX + GRID_SIZE, pixelY + GRID_SIZE / 2, 
                           GRID_SIZE - 10, GRID_SIZE / 2 - 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw shell pattern
                ctx.strokeStyle = '#006400';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(pixelX + GRID_SIZE - 10 + i * 10, pixelY + GRID_SIZE / 2, 
                           5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Draw head
                if (this.direction > 0) {
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(pixelX + this.width * GRID_SIZE - 5, pixelY + GRID_SIZE / 2, 
                           6, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(pixelX + 5, pixelY + GRID_SIZE / 2, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.globalAlpha = 1;
            }
            
            checkCollision(frog) {
                if (this.isDiving || this.divePhase > 0.5) return false;
                
                if (Math.floor(this.y) === frog.y) {
                    const frogLeft = frog.x;
                    const frogRight = frog.x + 1;
                    const turtleLeft = this.x;
                    const turtleRight = this.x + this.width;
                    
                    if (frogLeft >= turtleLeft && frogRight <= turtleRight) {
                        return true;
                    }
                }
                return false;
            }
        }
        
        // Alligator class
        class Alligator {
            constructor(lane, speed, direction) {
                this.lane = lane;
                this.speed = speed * gameState.difficulty;
                this.direction = direction;
                this.x = direction > 0 ? -4 : COLS + 4;
                this.y = 1 + lane;
                this.width = 3;
                this.height = 1;
                this.jawTimer = 0;
                this.isMouthOpen = false;
            }
            
            update() {
                this.x += this.speed * this.direction;
                
                // Jaw animation
                this.jawTimer++;
                if (this.jawTimer > 60) {
                    this.isMouthOpen = !this.isMouthOpen;
                    this.jawTimer = 0;
                }
                
                // Wrap around
                if (this.direction > 0 && this.x > COLS + 4) {
                    this.x = -4;
                } else if (this.direction < 0 && this.x < -4) {
                    this.x = COLS + 4;
                }
            }
            
            draw() {
                const pixelX = this.x * GRID_SIZE;
                const pixelY = this.y * GRID_SIZE;
                
                // Draw alligator body
                ctx.fillStyle = '#2E7D32';
                ctx.fillRect(pixelX, pixelY + 10, this.width * GRID_SIZE - 5, GRID_SIZE - 20);
                
                // Draw scales
                ctx.strokeStyle = '#1B5E20';
                ctx.lineWidth = 1;
                for (let i = 0; i < this.width * 2; i++) {
                    ctx.beginPath();
                    ctx.moveTo(pixelX + i * 10, pixelY + 10);
                    ctx.lineTo(pixelX + i * 10 + 5, pixelY + GRID_SIZE - 10);
                    ctx.stroke();
                }
                
                // Draw head
                if (this.direction > 0) {
                    ctx.fillStyle = '#2E7D32';
                    ctx.beginPath();
                    ctx.ellipse(pixelX + this.width * GRID_SIZE - 10, pixelY + GRID_SIZE / 2,
                               15, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw jaw
                    if (this.isMouthOpen) {
                        ctx.fillStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.moveTo(pixelX + this.width * GRID_SIZE - 5, pixelY + GRID_SIZE / 2);
                        ctx.lineTo(pixelX + this.width * GRID_SIZE + 5, pixelY + GRID_SIZE / 2 - 3);
                        ctx.lineTo(pixelX + this.width * GRID_SIZE + 5, pixelY + GRID_SIZE / 2 + 3);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else {
                    ctx.fillStyle = '#2E7D32';
                    ctx.beginPath();
                    ctx.ellipse(pixelX + 10, pixelY + GRID_SIZE / 2,
                               15, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw jaw
                    if (this.isMouthOpen) {
                        ctx.fillStyle = '#FF0000';
                        ctx.beginPath();
                        ctx.moveTo(pixelX + 5, pixelY + GRID_SIZE / 2);
                        ctx.lineTo(pixelX - 5, pixelY + GRID_SIZE / 2 - 3);
                        ctx.lineTo(pixelX - 5, pixelY + GRID_SIZE / 2 + 3);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                
                // Draw eyes
                ctx.fillStyle = '#FF0000';
                if (this.direction > 0) {
                    ctx.beginPath();
                    ctx.arc(pixelX + this.width * GRID_SIZE - 8, pixelY + GRID_SIZE / 2 - 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(pixelX + 12, pixelY + GRID_SIZE / 2 - 3, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            checkCollision(frog) {
                if (Math.floor(this.y) === frog.y) {
                    const frogLeft = frog.x;
                    const frogRight = frog.x + 1;
                    const gatorLeft = this.x;
                    const gatorRight = this.x + this.width;
                    
                    // Check if frog is on the body part (not head)
                    const safeZone = this.direction > 0 ? 
                        [gatorLeft, gatorRight - 0.5] : 
                        [gatorLeft + 0.5, gatorRight];
                    
                    if (frogLeft >= safeZone[0] && frogRight <= safeZone[1]) {
                        return true;
                    }
                }
                return false;
            }
        }
        
        // Game objects
        let frog = new Frog();
        let vehicles = [];
        let logs = [];
        let turtles = [];
        let alligators = [];
        
        // Initialize game objects
        function initGameObjects() {
            vehicles = [];
            logs = [];
            turtles = [];
            alligators = [];
            
            // Create vehicles for road section (rows 7-11)
            const vehicleConfigs = [
                { lane: 0, type: 'car', speed: 0.02, direction: 1 },
                { lane: 1, type: 'truck', speed: 0.015, direction: -1 },
                { lane: 2, type: 'bus', speed: 0.01, direction: 1 },
                { lane: 3, type: 'car', speed: 0.025, direction: -1 },
                { lane: 4, type: 'truck', speed: 0.02, direction: 1 }
            ];
            
            vehicleConfigs.forEach(config => {
                for (let i = 0; i < 3; i++) {
                    const vehicle = new Vehicle(
                        config.lane,
                        config.type,
                        config.speed,
                        config.direction
                    );
                    vehicle.x += i * 5;
                    vehicles.push(vehicle);
                }
            });
            
            // Create logs for river section (rows 1-5)
            const logConfigs = [
                { lane: 0, speed: 0.01, direction: 1 },
                { lane: 2, speed: 0.015, direction: -1 },
                { lane: 4, speed: 0.02, direction: 1 }
            ];
            
            logConfigs.forEach(config => {
                for (let i = 0; i < 3; i++) {
                    const log = new Log(config.lane, config.speed, config.direction);
                    log.x += i * 6;
                    logs.push(log);
                }
            });
            
            // Create turtles
            const turtleConfigs = [
                { lane: 1, speed: 0.012, direction: -1 },
                { lane: 3, speed: 0.018, direction: 1 }
            ];
            
            turtleConfigs.forEach(config => {
                for (let i = 0; i < 2; i++) {
                    const turtle = new Turtle(config.lane, config.speed, config.direction);
                    turtle.x += i * 4;
                    turtles.push(turtle);
                }
            });
            
            // Create alligators
            for (let i = 0; i < 2; i++) {
                const gator = new Alligator(2, 0.008, -1);
                gator.x += i * 8;
                alligators.push(gator);
            }
        }
        
        // Draw background
        function drawBackground() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw home slots (row 0)
            for (let i = 0; i < 5; i++) {
                const x = i * 3 + 1;
                
                if (gameState.homesOccupied[i]) {
                    // Draw frog in home
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath();
                    ctx.arc(x * GRID_SIZE, GRID_SIZE / 2, 15, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Draw empty home slot
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x * GRID_SIZE - 15, 5, 30, 30);
                    
                    // Draw lily pad
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.ellipse(x * GRID_SIZE, GRID_SIZE / 2, 20, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw river (rows 1-5)
            const gradient = ctx.createLinearGradient(0, GRID_SIZE, 0, 6 * GRID_SIZE);
            gradient.addColorStop(0, '#006994');
            gradient.addColorStop(1, '#0099cc');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, GRID_SIZE, canvas.width, 5 * GRID_SIZE);
            
            // Draw water waves
            ctx.strokeStyle = '#00aaff';
            ctx.lineWidth = 2;
            for (let y = 1; y <= 5; y++) {
                for (let x = 0; x < COLS; x++) {
                    const waveOffset = Math.sin(Date.now() * 0.001 + x) * 3;
                    ctx.beginPath();
                    ctx.moveTo(x * GRID_SIZE, y * GRID_SIZE + waveOffset);
                    ctx.lineTo((x + 1) * GRID_SIZE, y * GRID_SIZE + waveOffset);
                    ctx.stroke();
                }
            }
            
            // Draw safe middle zone (row 6)
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 6 * GRID_SIZE, canvas.width, GRID_SIZE);
            
            // Draw grass texture
            for (let x = 0; x < COLS; x++) {
                for (let i = 0; i < 5; i++) {
                    const grassX = x * GRID_SIZE + Math.random() * GRID_SIZE;
                    const grassY = 6 * GRID_SIZE + Math.random() * GRID_SIZE;
                    
                    ctx.strokeStyle = '#1B5E20';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(grassX, grassY);
                    ctx.lineTo(grassX - 2, grassY - 8);
                    ctx.moveTo(grassX, grassY);
                    ctx.lineTo(grassX + 2, grassY - 8);
                    ctx.stroke();
                }
            }
            
            // Draw road (rows 7-11)
            const roadGradient = ctx.createLinearGradient(0, 7 * GRID_SIZE, 0, 12 * GRID_SIZE);
            roadGradient.addColorStop(0, '#4B0082');
            roadGradient.addColorStop(1, '#663399');
            ctx.fillStyle = roadGradient;
            ctx.fillRect(0, 7 * GRID_SIZE, canvas.width, 5 * GRID_SIZE);
            
            // Draw road lines
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 10]);
            for (let y = 8; y <= 11; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * GRID_SIZE);
                ctx.lineTo(canvas.width, y * GRID_SIZE);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Draw starting zone (row 12)
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 12 * GRID_SIZE, canvas.width, GRID_SIZE);
            
            // Draw grass texture for starting zone
            for (let x = 0; x < COLS; x++) {
                for (let i = 0; i < 5; i++) {
                    const grassX = x * GRID_SIZE + Math.random() * GRID_SIZE;
                    const grassY = 12 * GRID_SIZE + Math.random() * GRID_SIZE;
                    
                    ctx.strokeStyle = '#1B5E20';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(grassX, grassY);
                    ctx.lineTo(grassX - 2, grassY - 8);
                    ctx.moveTo(grassX, grassY);
                    ctx.lineTo(grassX + 2, grassY - 8);
                    ctx.stroke();
                }
            }
        }
        
        // Update game
        function update() {
            if (!gameState.gameRunning || gameState.gameOver) return;
            
            // Update timer
            gameState.timer -= 0.016; // ~60fps
            if (gameState.timer <= 0) {
                frog.die();
                gameState.timer = 60;
            }
            
            // Update game objects
            vehicles.forEach(vehicle => vehicle.update());
            logs.forEach(log => log.update());
            turtles.forEach(turtle => turtle.update());
            alligators.forEach(gator => gator.update());
            frog.update();
            
            // Check collisions with vehicles
            vehicles.forEach(vehicle => {
                if (vehicle.checkCollision(frog)) {
                    frog.die();
                }
            });
            
            // Check if frog is in water area
            if (frog.y >= 1 && frog.y <= 5) {
                let onPlatform = false;
                
                // Check logs
                logs.forEach(log => {
                    if (log.checkCollision(frog)) {
                        onPlatform = true;
                        frog.attachedTo = log;
                    }
                });
                
                // Check turtles
                turtles.forEach(turtle => {
                    if (turtle.checkCollision(frog)) {
                        onPlatform = true;
                        frog.attachedTo = turtle;
                    }
                });
                
                // Check alligators
                alligators.forEach(gator => {
                    if (gator.checkCollision(frog)) {
                        onPlatform = true;
                        frog.attachedTo = gator;
                    }
                });
                
                // If not on platform, frog drowns
                if (!onPlatform) {
                    frog.die();
                }
            } else {
                frog.attachedTo = null;
            }
            
            // Check if frog reached home
            if (frog.y === 0) {
                const homeIndex = Math.floor(frog.x / 3);
                if (homeIndex >= 0 && homeIndex < 5 && !gameState.homesOccupied[homeIndex]) {
                    gameState.homesOccupied[homeIndex] = true;
                    gameState.score += 100 + Math.floor(gameState.timer * 10);
                    
                    // Check if all homes are occupied
                    if (gameState.homesOccupied.every(occupied => occupied)) {
                        nextLevel();
                    } else {
                        frog.reset();
                        gameState.timer = 60;
                    }
                } else {
                    frog.die();
                }
            }
            
            updateUI();
        }
        
        // Draw game
        function draw() {
            drawBackground();
            
            // Draw game objects
            logs.forEach(log => log.draw());
            turtles.forEach(turtle => turtle.draw());
            alligators.forEach(gator => gator.draw());
            vehicles.forEach(vehicle => vehicle.draw());
            frog.draw();
            
            // Draw timer bar
            const timerWidth = (gameState.timer / 60) * canvas.width;
            ctx.fillStyle = gameState.timer > 20 ? '#00ff00' : '#ff0000';
            ctx.fillRect(0, canvas.height - 5, timerWidth, 5);
            
            // Draw game over screen
            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 48px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Courier New';
                ctx.fillText(`Final Score: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 10);
                ctx.fillText('Press SPACE to restart', canvas.width / 2, canvas.height / 2 + 50);
            }
            
            // Draw start screen
            if (!gameState.gameRunning && !gameState.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 48px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('FROGGER', canvas.width / 2, canvas.height / 2 - 100);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Courier New';
                ctx.fillText('Press SPACE to start', canvas.width / 2, canvas.height / 2 - 30);
                ctx.fillText('Press 1-3 for difficulty', canvas.width / 2, canvas.height / 2 + 10);
                
                ctx.fillStyle = '#ffff00';
                ctx.font = '18px Courier New';
                ctx.fillText(`Current Difficulty: ${gameState.difficulty}`, canvas.width / 2, canvas.height / 2 + 50);
            }
        }
        
        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Next level
        function nextLevel() {
            gameState.level++;
            gameState.score += 500;
            gameState.homesOccupied = [false, false, false, false, false];
            frog.reset();
            gameState.timer = 60;
            
            // Increase difficulty slightly
            if (gameState.difficulty < 3) {
                gameState.difficulty += 0.1;
            }
            
            initGameObjects();
        }
        
        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('highScore').textContent = gameState.highScore;
            document.getElementById('timer').textContent = Math.ceil(gameState.timer);
            
            const livesContainer = document.getElementById('lives');
            livesContainer.innerHTML = '';
            for (let i = 0; i < gameState.lives; i++) {
                const life = document.createElement('div');
                life.className = 'life-icon';
                livesContainer.appendChild(life);
            }
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            if (!gameState.gameRunning && !gameState.gameOver) {
                if (e.key === ' ') {
                    gameState.gameRunning = true;
                    gameState.score = 0;
                    gameState.lives = 3;
                    gameState.timer = 60;
                    gameState.homesOccupied = [false, false, false, false, false];
                    frog.reset();
                    initGameObjects();
                } else if (e.key >= '1' && e.key <= '3') {
                    gameState.difficulty = parseInt(e.key);
                    updateUI();
                }
            } else if (gameState.gameRunning) {
                switch(e.key) {
                    case 'ArrowUp':
                        frog.move(0, -1);
                        break;
                    case 'ArrowDown':
                        frog.move(0, 1);
                        break;
                    case 'ArrowLeft':
                        frog.move(-1, 0);
                        break;
                    case 'ArrowRight':
                        frog.move(1, 0);
                        break;
                }
            } else if (gameState.gameOver) {
                if (e.key === ' ') {
                    gameState.gameOver = false;
                    gameState.gameRunning = true;
                    gameState.score = 0;
                    gameState.lives = 3;
                    gameState.timer = 60;
                    gameState.homesOccupied = [false, false, false, false, false];
                    frog.reset();
                    initGameObjects();
                }
            }
        });
        
        // Initialize game
        initGameObjects();
        updateUI();
        gameLoop();
    </script>
</body>
</html>