<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frogger - Enhanced Edition</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #2c5530, #4a7c59);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        .game-container {
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        canvas {
            border: 4px solid #333;
            border-radius: 10px;
            background: #1a472a;
            image-rendering: pixelated;
        }
        
        .controls {
            color: white;
            margin-top: 15px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="controls">
            Use Arrow Keys or WASD to move | Space to Start/Pause
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = 'start'; // start, playing, paused, gameOver
        let score = 0;
        let lives = 3;
        let level = 1;

        // Frog properties
        const frog = {
            x: 400,
            y: 550,
            width: 30,
            height: 30,
            speed: 40,
            direction: 'up'
        };

        // Game zones (y positions)
        const zones = {
            start: { y: 520, height: 80 },
            road1: { y: 440, height: 80 },
            safe1: { y: 360, height: 40 },
            water1: { y: 280, height: 80 },
            safe2: { y: 200, height: 40 },
            water2: { y: 120, height: 80 },
            goal: { y: 40, height: 40 }
        };

        // Vehicles
        const vehicles = [];
        const vehicleTypes = [
            { width: 60, height: 30, color: '#ff4444', speed: 3 },
            { width: 50, height: 25, color: '#44ff44', speed: -2.5 },
            { width: 70, height: 35, color: '#4444ff', speed: 2 },
            { width: 45, height: 20, color: '#ffff44', speed: -3.5 }
        ];

        // Water objects (logs and turtles)
        const waterObjects = [];
        const waterTypes = [
            { type: 'log', width: 120, height: 25, color: '#8B4513', speed: 1.5 },
            { type: 'log', width: 100, height: 25, color: '#A0522D', speed: -1.2 },
            { type: 'turtle', width: 80, height: 20, color: '#228B22', speed: 2 }
        ];

        // Sound effects using Web Audio API
        class SoundEffects {
            constructor() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            playJumpSound() {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }

            playCrashSound() {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(0.5, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.3);
            }

            playSplashSound() {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.4, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + 0.2);
            }

            playSuccessSound() {
                const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                notes.forEach((freq, index) => {
                    setTimeout(() => {
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                        
                        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                        
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + 0.15);
                    }, index * 100);
                });
            }
        }

        const soundEffects = new SoundEffects();

        // Initialize vehicles
        function initVehicles() {
            vehicles.length = 0;
            
            for (let lane = 0; lane < 2; lane++) {
                const yPos = zones.road1.y + 20 + (lane * 40);
                const vehicleCount = 4;
                
                for (let i = 0; i < vehicleCount; i++) {
                    const type = vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)];
                    vehicles.push({
                        x: (i * 200) + Math.random() * 100,
                        y: yPos,
                        width: type.width,
                        height: type.height,
                        color: type.color,
                        speed: type.speed * (1 + level * 0.2)
                    });
                }
            }
        }

        // Initialize water objects
        function initWaterObjects() {
            waterObjects.length = 0;
            
            for (let lane = 0; lane < 2; lane++) {
                const yPos = zones.water1.y + 20 + (lane * 40);
                const objectCount = 3;
                
                for (let i = 0; i < objectCount; i++) {
                    const type = waterTypes[Math.floor(Math.random() * waterTypes.length)];
                    waterObjects.push({
                        x: (i * 250) + Math.random() * 150,
                        y: yPos,
                        width: type.width,
                        height: type.height,
                        color: type.color,
                        speed: type.speed * (1 + level * 0.2),
                        type: type.type
                    });
                }
            }
        }

        // Draw enhanced frog sprite
        function drawFrog(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Frog body
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.ellipse(0, 0, 15, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Frog head
            ctx.fillStyle = '#66BB6A';
            ctx.beginPath();
            ctx.ellipse(0, -8, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-5, -12, 3, 0, Math.PI * 2);
            ctx.arc(5, -12, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(-5, -12, 1.5, 0, Math.PI * 2);
            ctx.arc(5, -12, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Legs
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-10, 8); ctx.lineTo(-15, 12);
            ctx.moveTo(10, 8); ctx.lineTo(15, 12);
            ctx.moveTo(-8, -2); ctx.lineTo(-12, -6);
            ctx.moveTo(8, -2); ctx.lineTo(12, -6);
            ctx.stroke();
            
            ctx.restore();
        }

        // Draw enhanced vehicle sprite
        function drawVehicle(vehicle) {
            ctx.save();
            ctx.translate(vehicle.x + vehicle.width/2, vehicle.y + vehicle.height/2);
            
            // Car body
            ctx.fillStyle = vehicle.color;
            ctx.fillRect(-vehicle.width/2, -vehicle.height/2, vehicle.width, vehicle.height);
            
            // Windows
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(-vehicle.width/3, -vehicle.height/3, vehicle.width/1.5, vehicle.height/4);
            
            // Wheels
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(-vehicle.width/3, vehicle.height/2, 4, 0, Math.PI * 2);
            ctx.arc(vehicle.width/3, vehicle.height/2, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Headlights
            ctx.fillStyle = '#FFFF99';
            ctx.beginPath();
            ctx.arc(-vehicle.width/2 + 5, -vehicle.height/4, 3, 0, Math.PI * 2);
            ctx.arc(vehicle.width/2 - 5, -vehicle.height/4, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        // Draw enhanced water object
        function drawWaterObject(obj) {
            ctx.save();
            ctx.translate(obj.x + obj.width/2, obj.y + obj.height/2);
            
            if (obj.type === 'log') {
                // Log texture
                ctx.fillStyle = obj.color;
                ctx.fillRect(-obj.width/2, -obj.height/2, obj.width, obj.height);
                
                // Wood grain lines
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 1;
                for (let i = -obj.width/2 + 10; i < obj.width/2; i += 15) {
                    ctx.beginPath();
                    ctx.moveTo(i, -obj.height/2);
                    ctx.lineTo(i, obj.height/2);
                    ctx.stroke();
                }
            } else if (obj.type === 'turtle') {
                // Turtle shell
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.ellipse(0, 0, obj.width/2, obj.height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Shell pattern
                ctx.strokeStyle = '#006400';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-obj.width/4, 0); ctx.lineTo(obj.width/4, 0);
                ctx.moveTo(0, -obj.height/3); ctx.lineTo(0, obj.height/3);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Draw game background
        function drawBackground() {
            // Start zone (grass)
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(0, zones.start.y, canvas.width, zones.start.height);
            
            // Road
            ctx.fillStyle = '#333';
            ctx.fillRect(0, zones.road1.y, canvas.width, zones.road1.height * 2 + zones.safe1.height);
            
            // Road markings
            ctx.strokeStyle = '#FFFF00';
            ctx.lineWidth = 3;
            ctx.setLineDash([20, 10]);
            for (let lane = 0; lane < 2; lane++) {
                const y = zones.road1.y + 40 + (lane * 80);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Safe zones
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(0, zones.safe1.y, canvas.width, zones.safe1.height);
            ctx.fillRect(0, zones.safe2.y, canvas.width, zones.safe2.height);
            
            // Water
            const waterGradient = ctx.createLinearGradient(0, zones.water1.y, 0, zones.water1.y + zones.water1.height * 2);
            waterGradient.addColorStop(0, '#1E90FF');
            waterGradient.addColorStop(1, '#0066CC');
            ctx.fillStyle = waterGradient;
            ctx.fillRect(0, zones.water1.y, canvas.width, zones.water1.height * 2 + zones.safe2.height);
            
            // Water waves
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            for (let y = zones.water1.y; y < zones.water1.y + zones.water1.height * 2; y += 20) {
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 30) {
                    const waveY = y + Math.sin(x * 0.02 + Date.now() * 0.003) * 3;
                    if (x === 0) ctx.moveTo(x, waveY);
                    else ctx.lineTo(x, waveY);
                }
                ctx.stroke();
            }
            
            // Goal zone
            const goalGradient = ctx.createLinearGradient(0, zones.goal.y, 0, zones.goal.y + zones.goal.height);
            goalGradient.addColorStop(0, '#4CAF50');
            goalGradient.addColorStop(1, '#66BB6A');
            ctx.fillStyle = goalGradient;
            ctx.fillRect(0, zones.goal.y, canvas.width, zones.goal.height);
            
            // Goal lily pads
            for (let i = 0; i < 5; i++) {
                const x = 80 + i * 160;
                ctx.fillStyle = '#228B22';
                ctx.beginPath();
                ctx.arc(x, zones.goal.y + 20, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Lily pad notch
                ctx.fillStyle = '#1a472a';
                ctx.beginPath();
                ctx.moveTo(x, zones.goal.y + 20);
                ctx.arc(x, zones.goal.y + 20, 15, -0.5, 0.5);
                ctx.fill();
            }
        }

        // Draw UI
        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 20, 35);
            
            ctx.textAlign = 'center';
            ctx.fillText(`Level: ${level}`, canvas.width/2, 35);
            
            ctx.textAlign = 'right';
            ctx.fillText(`Lives: ${lives}`, canvas.width - 20, 35);
        }

        // Draw game state overlays
        function drawOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            
            if (gameState === 'start') {
                ctx.font = 'bold 48px Courier New';
                ctx.fillText('FROGGER', canvas.width/2, canvas.height/2 - 50);
                
                ctx.font = '24px Courier New';
                ctx.fillText('Enhanced Edition', canvas.width/2, canvas.height/2 - 10);
                
                ctx.font = '20px Courier New';
                ctx.fillText('Press SPACE to Start', canvas.width/2, canvas.height/2 + 40);
                ctx.fillText('Use Arrow Keys or WASD to Move', canvas.width/2, canvas.height/2 + 70);
            } else if (gameState === 'paused') {
                ctx.font = 'bold 36px Courier New';
                ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
                
                ctx.font = '20px Courier New';
                ctx.fillText('Press SPACE to Resume', canvas.width/2, canvas.height/2 + 40);
            } else if (gameState === 'gameOver') {
                ctx.font = 'bold 36px Courier New';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 20);
                
                ctx.font = '24px Courier New';
                ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + 20);
                
                ctx.font = '20px Courier New';
                ctx.fillText('Press SPACE to Restart', canvas.width/2, canvas.height/2 + 60);
            }
        }

        // Collision detection
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

       function updateGame() {
            if (gameState !== 'playing') return;

            // Update vehicles
            vehicles.forEach(vehicle => {
                vehicle.x += vehicle.speed;
        
                if (vehicle.x > canvas.width && vehicle.speed > 0) {
                    vehicle.x = -vehicle.width;
                } else if (vehicle.x < -vehicle.width && vehicle.speed < 0) {
                    vehicle.x = canvas.width;
                }
            });

            // Update water objects
            waterObjects.forEach(obj => {
                obj.x += obj.speed;
        
                if (obj.x > canvas.width && obj.speed > 0) {
                    obj.x = -obj.width;
                } else if (obj.x < -obj.width && obj.speed < 0) {
                    obj.x = canvas.width;
                }
            });

            // Check collisions
            const frogRect = { x: frog.x, y: frog.y, width: frog.width, height: frog.height };

            // Vehicle collisions
            vehicles.forEach(vehicle => {
                if (checkCollision(frogRect, vehicle)) {
                    lives--;
                    soundEffects.playCrashSound();
            
                    if (lives <= 0) {
                        gameState = 'gameOver';
                    } else {
                        resetFrogPosition();
                    }
                }
            });

            // Water collision - FIXED: More precise detection
            const frogCenterY = frog.y + frog.height / 2;
            const inWaterZone1 = frogCenterY >= zones.water1.y && frogCenterY < (zones.water1.y + zones.water1.height);
            const inWaterZone2 = frogCenterY >= zones.water2.y && frogCenterY < (zones.water2.y + zones.water2.height);
            const inWaterZone = inWaterZone1 || inWaterZone2;
    
            if (inWaterZone) {
                let onPlatform = false;
        
                waterObjects.forEach(obj => {
                    if (checkCollision(frogRect, obj)) {
          
              onPlatform = true;
                        // Move frog with the platform
                        frog.x += obj.speed;
                
                        // Check if frog falls off
                        if (frog.x < 0 || frog.x > canvas.width - frog.width) {
                            lives--;
                            soundEffects.playSplashSound();
                    
                            if (lives <= 0) {
                                gameState = 'gameOver';
                            } else {
                                resetFrogPosition();
                            }
                        }
                    }
                });
        
                // If not on any platform while in water, drown
                if (!onPlatform && inWaterZone) {
                    lives--;
                    soundEffects.playSplashSound();
            
                    if (lives <= 0) {
                        gameState = 'gameOver';
                    } else {
                        resetFrogPosition();
                    }
                }
            }

            // Check goal
            if (frog.y <= zones.goal.y + zones.goal.height) {
                score += 100 * level;
                soundEffects.playSuccessSound();
        
                if (score % 500 === 0) {
                    level++;
                    initVehicles();
                    initWaterObjects();
                }
        
                resetFrogPosition();
            }
        }

            // Check collisions
            const frogRect = { x: frog.x, y: frog.y, width: frog.width, height: frog.height };

            // Vehicle collisions
            vehicles.forEach(vehicle => {
                if (checkCollision(frogRect, vehicle)) {
                    lives--;
                    soundEffects.playCrashSound();
                    
                    if (lives <= 0) {
                        gameState = 'gameOver';
                    } else {
                        resetFrogPosition();
                    }
                }
            });

            // Water collision
            const inWaterZone = frog.y >= zones.water1.y && frog.y < zones.water2.y + zones.water2.height;
            
            if (inWaterZone) {
                let onPlatform = false;
                
                waterObjects.forEach(obj => {
                    if (checkCollision(frogRect, obj)) {
                        onPlatform = true;
                        // Move frog with the platform
                        frog.x += obj.speed;
                        
                        // Check if frog falls off
                        if (frog.x < 0 || frog.x > canvas.width - frog.width) {
                            lives--;
                            soundEffects.playSplashSound();
                            
                            if (lives <= 0) {
                                gameState = 'gameOver';
                            } else {
                                resetFrogPosition();
                            }
                        }
                    }
                });
                
                if (!onPlatform && inWaterZone) {
                    lives--;
                    soundEffects.playSplashSound();
                    
                    if (lives <= 0) {
                        gameState = 'gameOver';
                    } else {
                        resetFrogPosition();
                    }
                }
            }

            // Check goal
            if (frog.y <= zones.goal.y + zones.goal.height) {
                score += 100 * level;
                soundEffects.playSuccessSound();
                
                if (score % 500 === 0) {
                    level++;
                    initVehicles();
                    initWaterObjects();
                }
                
                resetFrogPosition();
            }
        

        // Reset frog position
        function resetFrogPosition() {
            frog.x = canvas.width / 2 - frog.width / 2;
            frog.y = zones.start.y + zones.start.height / 2 - frog.height / 2;
        }

        // Move frog
        function moveFrog(direction) {
            if (gameState !== 'playing') return;

            const oldX = frog.x;
            const oldY = frog.y;

            switch (direction) {
                case 'up':
                    frog.y -= frog.speed;
                    break;
                case 'down':
                    frog.y += frog.speed;
                    break;
                case 'left':
                    frog.x -= frog.speed;
                    break;
                case 'right':
                    frog.x += frog.speed;
                    break;
            }

            // Keep frog in bounds
            frog.x = Math.max(0, Math.min(canvas.width - frog.width, frog.x));
            frog.y = Math.max(0, Math.min(canvas.height - frog.height, frog.y));

            // Play jump sound if position changed
            if (oldX !== frog.x || oldY !== frog.y) {
                soundEffects.playJumpSound();
            }
        }

        // Main game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            
            if (gameState === 'playing') {
                updateGame();
                
                // Draw vehicles
                vehicles.forEach(drawVehicle);
                
                // Draw water objects
                waterObjects.forEach(drawWaterObject);
                
                // Draw frog
                drawFrog(frog.x, frog.y);
                
                drawUI();
            } else {
                // Draw static game elements
                vehicles.forEach(drawVehicle);
                waterObjects.forEach(drawWaterObject);
                drawFrog(frog.x, frog.y);
                drawUI();
                drawOverlay();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                
                if (gameState === 'start' || gameState === 'gameOver') {
                    score = 0;
                    lives = 3;
                    level = 1;
                    resetFrogPosition();
                    initVehicles();
                    initWaterObjects();
                    gameState = 'playing';
                } else if (gameState === 'playing') {
                    gameState = 'paused';
                } else if (gameState === 'paused') {
                    gameState = 'playing';
                }
            }

            if (gameState === 'playing') {
                switch (e.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        e.preventDefault();
                        moveFrog('up');
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        e.preventDefault();
                        moveFrog('down');
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        e.preventDefault();
                        moveFrog('left');
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        e.preventDefault();
                        moveFrog('right');
                        break;
                }
            }
        });

        // Initialize game
        function init() {
            resetFrogPosition();
            initVehicles();
            initWaterObjects();
            gameLoop();
        }

        init();
    </script>
</body>
</html>