<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frogger - Classic 1981</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        .game-container {
            text-align: center;
        }
        
        canvas {
            border: 4px solid #333;
            background: #000;
            box-shadow: 0 0 20px rgba(0,255,0,0.3);
        }
        
        .controls {
            color: #fff;
            margin-top: 10px;
            font-size: 14px;
        }
        
        .difficulty-selector {
            margin-bottom: 10px;
        }
        
        select, button {
            background: #333;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 5px 10px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
        }
        
        button:hover, select:hover {
            background: #0f0;
            color: #000;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 style="color: #0f0; text-shadow: 2px 2px 4px rgba(0,255,0,0.5);">FROGGER - CLASSIC 1981</h1>
        
        <div class="difficulty-selector">
            <label style="color: #fff;">Difficulty: </label>
            <select id="difficulty">
                <option value="easy">Easy</option>
                <option value="normal" selected>Normal</option>
                <option value="hard">Hard</option>
                <option value="insane">Insane</option>
            </select>
            <button onclick="startGame()">START GAME</button>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="controls">
            <p>üéÆ Use ARROW KEYS to move | SPACE to pause | R to restart</p>
            <p>üèÜ Reach all 5 home slots before time runs out!</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game constants
        const GRID_SIZE = 40;
        const COLS = 20;
        const ROWS = 15;
        
        // Colors for retro style
        const COLORS = {
            grass: '#228B22',
            road: '#8A2BE2',
            river: '#1E90FF',
            frog: '#32CD32',
            car: ['#FF0000', '#FFFF00', '#00FF00', '#FF8800', '#FF00FF'],
            log: '#8B4513',
            turtle: '#228B22',
            alligator: '#006400'
        };

        // Game state
        let gameState = {
            score: 0,
            lives: 3,
            level: 1,
            timeLeft: 60,
            maxTime: 60,
            homesFilled: [false, false, false, false, false],
            paused: false,
            gameOver: false,
            difficulty: 'normal'
        };

        // Difficulty settings
        const DIFFICULTIES = {
            easy: { speedMultiplier: 0.7, timeBonus: 20 },
            normal: { speedMultiplier: 1.0, timeBonus: 15 },
            hard: { speedMultiplier: 1.3, timeBonus: 10 },
            insane: { speedMultiplier: 1.8, timeBonus: 5 }
        };

        // Frog class with smooth animation
        class Frog {
            constructor() {
                this.x = Math.floor(COLS / 2) * GRID_SIZE + GRID_SIZE / 2;
                this.y = (ROWS - 1) * GRID_SIZE + GRID_SIZE / 2;
                this.width = GRID_SIZE * 0.8;
                this.height = GRID_SIZE * 0.8;
                this.targetX = this.x;
                this.targetY = this.y;
                this.isMoving = false;
                this.animationFrame = 0;
                this.animationSpeed = 0.2;
            }

            update() {
                // Smooth movement animation
                if (this.isMoving) {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    
                    if (Math.abs(dx) < 1 && Math.abs(dy) < 1) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.isMoving = false;
                    } else {
                        this.x += dx * 0.3;
                        this.y += dy * 0.3;
                    }
                }

                // Animation frame update
                if (this.isMoving) {
                    this.animationFrame += this.animationSpeed;
                } else {
                    this.animationFrame *= 0.9; // Slow down when not moving
                }
            }

            move(dx, dy) {
                if (!this.isMoving && !gameState.paused && !gameState.gameOver) {
                    const newX = Math.max(GRID_SIZE/2, Math.min(canvas.width - GRID_SIZE/2, this.x + dx * GRID_SIZE));
                    const newY = Math.max(GRID_SIZE/2, Math.min(canvas.height - GRID_SIZE/2, this.y + dy * GRID_SIZE));
                    
                    // Check grid boundaries
                    if (Math.floor(newX / GRID_SIZE) !== Math.floor(this.x / GRID_SIZE) || 
                        Math.floor(newY / GRID_SIZE) !== Math.floor(this.y / GRID_SIZE)) {
                        
                        this.targetX = newX;
                        this.targetY = newY;
                        this.isMoving = true;
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Frog body with 4-leg animation
                const legOffset = Math.sin(this.animationFrame * 10) * 3;
                
                // Draw legs
                ctx.fillStyle = COLORS.frog;
                ctx.beginPath();
                // Front left leg
                ctx.ellipse(-15, -15 + legOffset, 8, 12, 0, 0, Math.PI * 2);
                // Front right leg
                ctx.ellipse(15, -15 - legOffset, 8, 12, 0, 0, Math.PI * 2);
                // Back left leg
                ctx.ellipse(-15, 15 + legOffset, 10, 14, 0, 0, Math.PI * 2);
                // Back right leg
                ctx.ellipse(15, 15 - legOffset, 10, 14, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw body
                ctx.beginPath();
                ctx.ellipse(0, 0, this.width/2, this.height/2, 0, 0, Math.PI * 2);
                ctx.fillStyle = COLORS.frog;
                ctx.fill();
                
                // Draw eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(-10, -20, 6, 8, 0, 0, Math.PI * 2);
                ctx.ellipse(10, -20, 6, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(-10, -18, 3, 4, 0, 0, Math.PI * 2);
                ctx.ellipse(10, -18, 3, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 5, 8, 0.1 * Math.PI, 0.9 * Math.PI);
                ctx.stroke();
                
                ctx.restore();
            }

            getGridPosition() {
                return {
                    col: Math.floor(this.x / GRID_SIZE),
                    row: Math.floor(this.y / GRID_SIZE)
                };
            }
        }

        // Vehicle class
        class Vehicle {
            constructor(x, y, width, height, speed, direction) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed * DIFFICULTIES[gameState.difficulty].speedMultiplier;
                this.direction = direction; // 1 for right, -1 for left
                this.color = COLORS.car[Math.floor(Math.random() * COLORS.car.length)];
            }

            update() {
                this.x += this.speed * this.direction;
                
                if (this.direction > 0 && this.x > canvas.width + this.width) {
                    this.x = -this.width;
                } else if (this.direction < 0 && this.x < -this.width) {
                    this.x = canvas.width + this.width;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Car body
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                
                // Car details
                ctx.fillStyle = '#333';
                ctx.fillRect(-this.width/3, -this.height/3, this.width*2/3, this.height*2/3);
                
                // Wheels
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-this.width/3, this.height/2, 6, 0, Math.PI * 2);
                ctx.arc(this.width/3, this.height/2, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Headlights
                if (this.direction > 0) {
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(this.width/2 - 5, -8, 4, 6);
                    ctx.fillRect(this.width/2 - 5, 2, 4, 6);
                } else {
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(-this.width/2 + 1, -8, 4, 6);
                    ctx.fillRect(-this.width/2 + 1, 2, 4, 6);
                }
                
                ctx.restore();
            }

            collidesWith(frog) {
                return Math.abs(this.x - frog.x) < (this.width + frog.width) / 2 &&
                       Math.abs(this.y - frog.y) < (this.height + frog.height) / 2;
            }
        }

        // Log class
        class Log {
            constructor(x, y, width, height, speed, direction) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed * DIFFICULTIES[gameState.difficulty].speedMultiplier;
                this.direction = direction;
            }

            update() {
                this.x += this.speed * this.direction;
                
                if (this.direction > 0 && this.x > canvas.width + this.width) {
                    this.x = -this.width;
                } else if (this.direction < 0 && this.x < -this.width) {
                    this.x = canvas.width + this.width;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Log body
                ctx.fillStyle = COLORS.log;
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                
                // Wood texture
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                for (let i = -this.width/2 + 10; i < this.width/2; i += 20) {
                    ctx.beginPath();
                    ctx.moveTo(i, -this.height/2);
                    ctx.lineTo(i, this.height/2);
                    ctx.stroke();
                }
                
                // End caps
                ctx.fillStyle = '#654321';
                ctx.fillRect(-this.width/2, -this.height/2, 8, this.height);
                ctx.fillRect(this.width/2 - 8, -this.height/2, 8, this.height);
                
                ctx.restore();
            }

            collidesWith(frog) {
                return Math.abs(this.x - frog.x) < (this.width + frog.width) / 2 &&
                       Math.abs(this.y - frog.y) < (this.height + frog.height) / 2;
            }
        }

        // Turtle class with diving animation
        class Turtle {
            constructor(x, y, width, height, speed, direction, dives = false) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed * DIFFICULTIES[gameState.difficulty].speedMultiplier;
                this.direction = direction;
                this.dives = dives;
                this.animationFrame = 0;
                this.isVisible = true;
            }

            update() {
                this.x += this.speed * this.direction;
                
                if (this.direction > 0 && this.x > canvas.width + this.width) {
                    this.x = -this.width;
                } else if (this.direction < 0 && this.x < -this.width) {
                    this.x = canvas.width + this.width;
                }

                // Diving animation
                if (this.dives) {
                    this.animationFrame += 0.05;
                    if (Math.sin(this.animationFrame * 3) > 0.7) {
                        this.isVisible = false;
                    } else {
                        this.isVisible = true;
                    }
                }
            }

            draw() {
                if (!this.isVisible && this.dives) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Turtle shell
                ctx.fillStyle = COLORS.turtle;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.width/2, this.height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Shell pattern
                ctx.strokeStyle = '#006400';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.width/3, this.height/3, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // Head
                ctx.fillStyle = COLORS.turtle;
                ctx.beginPath();
                ctx.ellipse(this.direction > 0 ? this.width/3 : -this.width/3, 0, 8, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Legs
                ctx.fillStyle = COLORS.turtle;
                ctx.beginPath();
                ctx.ellipse(-10, -12, 4, 6, 0, 0, Math.PI * 2);
                ctx.ellipse(10, -12, 4, 6, 0, 0, Math.PI * 2);
                ctx.ellipse(-10, 12, 4, 6, 0, 0, Math.PI * 2);
                ctx.ellipse(10, 12, 4, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }

            collidesWith(frog) {
                if (!this.isVisible && this.dives) return false;
                
                return Math.abs(this.x - frog.x) < (this.width + frog.width) / 2 &&
                       Math.abs(this.y - frog.y) < (this.height + frog.height) / 2;
            }
        }

        // Alligator class with snapping jaws
        class Alligator {
            constructor(x, y, width, height, speed, direction) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed * DIFFICULTIES[gameState.difficulty].speedMultiplier;
                this.direction = direction;
                this.animationFrame = 0;
                this.mouthOpen = false;
            }

            update() {
                this.x += this.speed * this.direction;
                
                if (this.direction > 0 && this.x > canvas.width + this.width) {
                    this.x = -this.width;
                } else if (this.direction < 0 && this.x < -this.width) {
                    this.x = canvas.width + this.width;
                }

                // Snapping animation
                this.animationFrame += 0.1;
                this.mouthOpen = Math.sin(this.animationFrame * 2) > 0.3;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Alligator body
                ctx.fillStyle = COLORS.alligator;
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                
                // Head
                const headX = this.direction > 0 ? this.width/3 : -this.width/3;
                ctx.beginPath();
                if (this.mouthOpen) {
                    // Open mouth
                    ctx.ellipse(headX, 0, 12, 10, 0, 0, Math.PI);
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(headX - 8, -2, 16, 4); // Red mouth interior
                } else {
                    // Closed mouth
                    ctx.ellipse(headX, 0, 12, 10, 0, 0, Math.PI * 2);
                }
                ctx.fillStyle = COLORS.alligator;
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = '#FFFF00';
                ctx.beginPath();
                ctx.arc(headX - 6, -8, 3, 0, Math.PI * 2);
                ctx.arc(headX + 6, -8, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Teeth
                if (this.mouthOpen) {
                    ctx.fillStyle = '#FFF';
                    for (let i = -6; i <= 6; i += 4) {
                        ctx.beginPath();
                        ctx.moveTo(headX + i, 0);
                        ctx.lineTo(headX + i + 2, 8);
                        ctx.lineTo(headX + i + 4, 0);
                        ctx.fill();
                    }
                }
                
                // Legs
                ctx.fillStyle = COLORS.alligator;
                ctx.beginPath();
                ctx.ellipse(-this.width/3, -this.height/2, 6, 8, 0, 0, Math.PI * 2);
                ctx.ellipse(this.width/3, -this.height/2, 6, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }

            collidesWith(frog) {
                return Math.abs(this.x - frog.x) < (this.width + frog.width) / 2 &&
                       Math.abs(this.y - frog.y) < (this.height + frog.height) / 2;
            }
        }

        // Game objects
        let frog = new Frog();
        let vehicles = [];
        let logs = [];
        let turtles = [];
        let alligators = [];

        function initializeLevel() {
            vehicles = [];
            logs = [];
            turtles = [];
            alligators = [];

            console.log('Initializing level with obstacles...');

            // Create road lanes (rows 8-12)
            const roadRows = [8, 9, 10, 11, 12];
            for (let i = 0; i < roadRows.length; i++) {
                const row = roadRows[i];
                const y = row * GRID_SIZE + GRID_SIZE / 2;
                const speed = 1 + i * 0.5;
                const direction = i % 2 === 0 ? 1 : -1;
                
                for (let j = 0; j < 4; j++) {
                    const x = (j * canvas.width / 4) + Math.random() * 100;
                    const width = GRID_SIZE * (1.5 + Math.random());
                    vehicles.push(new Vehicle(x, y, width, GRID_SIZE * 0.8, speed, direction));
                }
            }

            // Create river lanes (rows 2-6)
            const riverRows = [2, 3, 4, 5, 6];
            for (let i = 0; i < riverRows.length; i++) {
                const row = riverRows[i];
                const y = row * GRID_SIZE + GRID_SIZE / 2;
                const speed = 1 + i * 0.3;
                const direction = i % 2 === 0 ? 1 : -1;
                
                for (let j = 0; j < 3; j++) {
                    const x = (j * canvas.width / 3) + Math.random() * 150;
                    
                    if (i === 4 && Math.random() > 0.7) {
                        // Alligator lane
                        alligators.push(new Alligator(x, y, GRID_SIZE * 2, GRID_SIZE * 0.8, speed, direction));
                    } else if (Math.random() > 0.6) {
                        // Turtle lane with diving
                        turtles.push(new Turtle(x, y, GRID_SIZE * 1.5, GRID_SIZE * 0.7, speed, direction, true));
                    } else {
                        // Regular turtle or log
                        if (Math.random() > 0.5) {
                            turtles.push(new Turtle(x, y, GRID_SIZE * 1.2, GRID_SIZE * 0.6, speed, direction, false));
                        } else {
                            logs.push(new Log(x, y, GRID_SIZE * (2 + Math.random()), GRID_SIZE * 0.8, speed, direction));
                        }
                    }
                }
            }

            console.log(`Created: ${vehicles.length} vehicles, ${logs.length} logs, ${turtles.length} turtles, ${alligators.length} alligators`);
        }

        function drawBackground() {
            // Grass areas
            ctx.fillStyle = COLORS.grass;
            ctx.fillRect(0, 0, canvas.width, GRID_SIZE * 2); // Top grass
            ctx.fillRect(0, (ROWS - 2) * GRID_SIZE, canvas.width, GRID_SIZE * 2); // Bottom grass
            
            // Road area
            ctx.fillStyle = COLORS.road;
            ctx.fillRect(0, GRID_SIZE * 8, canvas.width, GRID_SIZE * 5);
            
            // River area
            ctx.fillStyle = COLORS.river;
            ctx.fillRect(0, GRID_SIZE * 2, canvas.width, GRID_SIZE * 5);
            
            // Draw road markings
            ctx.strokeStyle = '#FFFF00';
            ctx.lineWidth = 3;
            for (let row = 9; row <= 11; row++) {
                const y = row * GRID_SIZE + GRID_SIZE / 2;
                ctx.setLineDash([20, 10]);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw home slots
            for (let i = 0; i < 5; i++) {
                const x = i * GRID_SIZE * 4 + GRID_SIZE * 2;
                const y = GRID_SIZE / 2;
                
                if (!gameState.homesFilled[i]) {
                    // Empty home slot
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    ctx.strokeRect(x - GRID_SIZE/2, y - GRID_SIZE/2, GRID_SIZE, GRID_SIZE);
                    
                    // Lily pad
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.ellipse(x, y, GRID_SIZE * 0.4, GRID_SIZE * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Filled home slot
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(x, y, GRID_SIZE * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Star
                    ctx.fillStyle = '#FFFF00';
                    drawStar(x, y, 5, GRID_SIZE * 0.3, GRID_SIZE * 0.15);
                }
            }
        }

        function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }

        function drawUI() {
            // Score
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`SCORE: ${gameState.score}`, 10, 25);
            
            // Lives
            ctx.fillText(`LIVES: ${gameState.lives}`, 10, 50);
            
            // Level
            ctx.fillText(`LEVEL: ${gameState.level}`, 10, 75);
            
            // Timer bar
            const timerBarWidth = 200;
            const timerBarHeight = 20;
            const timerX = canvas.width - timerBarWidth - 10;
            const timerY = 10;
            
            ctx.fillStyle = '#333';
            ctx.fillRect(timerX, timerY, timerBarWidth, timerBarHeight);
            
            const timeRatio = gameState.timeLeft / gameState.maxTime;
            ctx.fillStyle = timeRatio > 0.3 ? '#00FF00' : '#FF0000';
            ctx.fillRect(timerX, timerY, timerBarWidth * timeRatio, timerBarHeight);
            
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.strokeRect(timerX, timerY, timerBarWidth, timerBarHeight);
            
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.ceil(gameState.timeLeft)}`, timerX + timerBarWidth/2, timerY + 15);
        }

        function checkCollisions() {
            const frogGrid = frog.getGridPosition();
            
            // Check vehicle collisions (road area)
            if (frogGrid.row >= 8 && frogGrid.row <= 12) {
                for (let vehicle of vehicles) {
                    if (vehicle.collidesWith(frog)) {
                        killFrog('hit by vehicle');
                        return;
                    }
                }
            }
            
            // Check water collisions and platform support
            if (frogGrid.row >= 2 && frogGrid.row <= 6) {
                let onPlatform = false;
                
                // Check logs
                for (let log of logs) {
                    if (log.collidesWith(frog)) {
                        onPlatform = true;
                        break;
                    }
                }
                
                // Check turtles
                for (let turtle of turtles) {
                    if (turtle.collidesWith(frog)) {
                        onPlatform = true;
                        break;
                    }
                }
                
                // Check alligators
                for (let alligator of alligators) {
                    if (alligator.collidesWith(frog)) {
                        killFrog('eaten by alligator');
                        return;
                    }
                }
                
                if (!onPlatform) {
                    killFrog('drowned');
                    return;
                }
            }
            
            // Check home slots
            if (frogGrid.row === 0) {
                const homeIndex = Math.floor(frogGrid.col / 4);
                if (homeIndex >= 0 && homeIndex < 5 && !gameState.homesFilled[homeIndex]) {
                    gameState.homesFilled[homeIndex] = true;
                    gameState.score += 50 + Math.floor(gameState.timeLeft * DIFFICULTIES[gameState.difficulty].timeBonus);
                    
                    // Reset frog
                    resetFrog();
                    
                    // Check if all homes filled
                    if (gameState.homesFilled.every(home => home)) {
                        nextLevel();
                    }
                } else {
                    killFrog('invalid home');
                }
            }
        }

        function killFrog(reason) {
            console.log(`Frog died: ${reason}`);
            gameState.lives--;
            
            if (gameState.lives <= 0) {
                gameState.gameOver = true;
            } else {
                resetFrog();
            }
        }

        function resetFrog() {
            frog.x = Math.floor(COLS / 2) * GRID_SIZE + GRID_SIZE / 2;
            frog.y = (ROWS - 1) * GRID_SIZE + GRID_SIZE / 2;
            frog.targetX = frog.x;
            frog.targetY = frog.y;
            frog.isMoving = false;
        }

        function nextLevel() {
            gameState.level++;
            gameState.score += 1000;
            gameState.homesFilled = [false, false, false, false, false];
            gameState.maxTime = Math.max(30, 60 - (gameState.level - 1) * 5);
            gameState.timeLeft = gameState.maxTime;
            
            resetFrog();
            initializeLevel();
        }

        function updateGame() {
            if (!gameState.paused && !gameState.gameOver) {
                // Update timer
                gameState.timeLeft -= 1/60; // Assuming 60 FPS
                if (gameState.timeLeft <= 0) {
                    killFrog('time ran out');
                }
                
                // Update frog
                frog.update();
                
                // Update vehicles
                for (let vehicle of vehicles) {
                    vehicle.update();
                }
                
                // Update logs
                for (let log of logs) {
                    log.update();
                }
                
                // Update turtles
                for (let turtle of turtles) {
                    turtle.update();
                }
                
                // Update alligators
                for (let alligator of alligators) {
                    alligator.update();
                }
                
                // Check collisions
                checkCollisions();
            }
        }

        function drawGame() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw background and game elements
            drawBackground();
            
            // Draw platforms (logs, turtles, alligators)
            for (let log of logs) {
                log.draw();
            }
            for (let turtle of turtles) {
                turtle.draw();
            }
            for (let alligator of alligators) {
                alligator.draw();
            }
            
            // Draw vehicles
            for (let vehicle of vehicles) {
                vehicle.draw();
            }
            
            // Draw frog
            frog.draw();
            
            // Draw UI
            drawUI();
            
            // Draw game over screen
            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#FF0000';
                ctx.font = 'bold 48px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 50);
                
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 24px Courier New';
                ctx.fillText(`Final Score: ${gameState.score}`, canvas.width/2, canvas.height/2 + 20);
                ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 60);
            }
            
            // Draw pause screen
            if (gameState.paused && !gameState.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 36px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
            }
        }

        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver && e.key.toLowerCase() === 'r') {
                startGame();
                return;
            }
            
            switch(e.key) {
                case 'ArrowUp':
                    frog.move(0, -1);
                    break;
                case 'ArrowDown':
                    frog.move(0, 1);
                    break;
                case 'ArrowLeft':
                    frog.move(-1, 0);
                    break;
                case 'ArrowRight':
                    frog.move(1, 0);
                    break;
                case ' ':
                    gameState.paused = !gameState.paused;
                    break;
                case 'r':
                case 'R':
                    if (gameState.gameOver) {
                        startGame();
                    }
                    break;
            }
        });

        function startGame() {
            const difficultySelect = document.getElementById('difficulty');
            gameState.difficulty = difficultySelect.value;
            
            // Reset game state
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.timeLeft = 60;
            gameState.maxTime = 60;
            gameState.homesFilled = [false, false, false, false, false];
            gameState.paused = false;
            gameState.gameOver = false;
            
            // Initialize game
            frog = new Frog();
            initializeLevel();
        }

        // Initialize the game automatically when page loads
        initializeLevel();

        // Start the game loop
        gameLoop();

        console.log('Frogger game loaded! Use arrow keys to move the frog.');
    </script>
</body>
</html>