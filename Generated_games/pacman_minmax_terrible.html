<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Classic</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        canvas {
            border: 3px solid #0000FF;
            background-color: #000;
            box-shadow: 0 0 30px rgba(0, 0, 255, 0.5);
        }
        
        .controls {
            color: #FFFF00;
            margin-top: 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="672" height="744"></canvas>
        <div class="controls">
            Use Arrow Keys or WASD to move | Space to Start/Pause
        </div>
    </div>

    <script>
        // Game Constants
        const GRID_SIZE = 24;
        const MAZE_WIDTH = 28;
        const MAZE_HEIGHT = 31;
        const CANVAS_WIDTH = MAZE_WIDTH * GRID_SIZE;
        const CANVAS_HEIGHT = MAZE_HEIGHT * GRID_SIZE;

        // Colors
        const COLORS = {
            BACKGROUND: '#000000',
            WALL: '#0000FF',
            DOT: '#FFFFFF',
            POWER_PELLET: '#FFFFFF',
            PACMAN: '#FFFF00',
            GHOST_RED: '#FF0000',
            GHOST_PINK: '#FFB8FF',
            GHOST_CYAN: '#00FFFF',
            GHOST_ORANGE: '#FFB852',
            GHOST_VULNERABLE: '#0000FF',
            GHOST_EYES: '#FFFFFF',
            FRUIT: '#FF0000'
        };

        // Game State
        let gameState = 'ready'; // ready, playing, paused, gameOver
        let score = 0;
        let lives = 3;
        let level = 1;
        let dotsEaten = 0;
        let totalDots = 240;

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Maze Layout (28x31 grid) - Fixed version with proper bounds checking
        // 0: empty, 1: wall, 2: dot, 3: power pellet, 4: ghost house door, 5: tunnel
        let MAZE_LAYOUT = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,3,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,2,1,2,2,2,2,2,1,1,1,1,2,2,2,2,2,1,2,2,2,2,2,1],
            [1,1,1,1,1,2,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,2,1,1,1,1,1],
            [0,0,0,0,1,2,1,0,0,0,0,0,0,5,5,0,0,0,0,0,0,1,2,1,0,0,0,0],
            [1,1,1,1,1,2,1,0,1,1,1,1,0,5,5,0,1,1,1,1,0,1,2,1,1,1,1,1],
            [0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0],
            [1,1,1,1,1,2,1,0,1,0,4,4,4,4,4,4,4,4,4,0,1,0,2,1,1,1,1,1],
            [0,0,0,0,0,2,0,0,1,0,4,0,0,0,0,0,0,0,4,0,1,0,2,0,0,0,0,0],
            [1,1,1,1,1,2,1,0,1,0,4,0,0,0,0,0,0,0,4,0,1,0,2,1,1,1,1,1],
            [5,5,5,5,5,2,5,5,5,0,4,0,0,0,0,0,0,0,4,0,5,5,5,5,5,5,5,5],
            [1,1,1,1,1,2,1,0,1,0,4,0,0,0,0,0,0,0,4,0,1,0,2,1,1,1,1,1],
            [0,0,0,0,0,2,0,0,1,0,4,4,4,4,4,4,4,4,4,0,1,0,2,0,0,0,0,0],
            [1,1,1,1,1,2,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,2,1,1,1,1,1],
            [0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,2,0,0,0,0,0],
            [1,1,1,1,1,2,1,0,1,1,1,1,0,5,5,0,1,1,1,1,0,1,2,1,1,1,1,1],
            [0,0,0,0,1,2,1,0,0,0,0,0,0,5,5,0,0,0,0,0,0,1,2,1,0,0,0,0],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,1,2,1],
            [1,3,2,2,1,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,1,2,1,2,3,1],
            [1,1,1,2,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,2,1,2,2,2,2,2,1,1,1,1,2,2,2,2,2,1,2,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Validate maze layout
        function validateMazeLayout() {
            console.log(`Validating maze: ${MAZE_LAYOUT.length} rows`);
            
            for (let y = 0; y < MAZE_LAYOUT.length; y++) {
                if (!Array.isArray(MAZE_LAYOUT[y])) {
                    console.error(`Row ${y} is not an array`);
                    MAZE_LAYOUT[y] = new Array(MAZE_WIDTH).fill(1); // Fill with walls as fallback
                    continue;
                }
                
                if (MAZE_LAYOUT[y].length !== MAZE_WIDTH) {
                    console.warn(`Row ${y} has ${MAZE_LAYOUT[y].length} elements, expected ${MAZE_WIDTH}`);
                    
                    // Pad or trim row to correct length
                    while (MAZE_LAYOUT[y].length < MAZE_WIDTH) {
                        MAZE_LAYOUT[y].push(1); // Add walls
                    }
                    if (MAZE_LAYOUT[y].length > MAZE_WIDTH) {
                        MAZE_LAYOUT[y] = MAZE_LAYOUT[y].slice(0, MAZE_WIDTH);
                    }
                }
            }
            
            console.log('Maze validation complete');
        }

        // Validate maze on load
        validateMazeLayout();

        // Helper function to find valid starting positions
        function findValidStartingPosition(preferredX, preferredY) {
            // Check preferred position first
            if (isValidTile(preferredX, preferredY)) {
                return { x: preferredX, y: preferredY };
            }
            
            // Search in expanding circles around preferred position
            for (let radius = 1; radius < 10; radius++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const x = preferredX + dx;
                        const y = preferredY + dy;
                        
                        if (isValidTile(x, y)) {
                            return { x: x, y: y };
                        }
                    }
                }
            }
            
            // Fallback to a known good position
            return { x: 1, y: 1 };
        }

        function isValidTile(x, y) {
            if (x < 0 || x >= MAZE_WIDTH || y < 0 || y >= MAZE_HEIGHT) {
                return false;
            }
            
            if (!MAZE_LAYOUT[y] || x >= MAZE_LAYOUT[y].length) {
                return false;
            }
            
            const tile = MAZE_LAYOUT[y][x];
            // Valid tiles: empty (0), dot (2), power pellet (3), tunnel (5)
            return tile === 0 || tile === 2 || tile === 3 || tile === 5;
        }

        // Entity Classes
        class Pacman {
            constructor() {
                // Find a valid starting position near the bottom center
                const startPos = findValidStartingPosition(14, 23);
                this.x = startPos.x * GRID_SIZE + GRID_SIZE / 2;
                this.y = startPos.y * GRID_SIZE + GRID_SIZE / 2;
                
                console.log(`Pac-Man starting at grid position: (${startPos.x}, ${startPos.y})`);
                
                this.direction = { x: 0, y: 0 };
                this.nextDirection = { x: 0, y: 0 };
                this.speed = 2;
                this.mouthOpen = true;
                this.mouthAngle = 0;
                this.animationFrame = 0;
            }

            update() {
                if (gameState !== 'playing') return;

                // Check for direction change at intersections
                const gridX = Math.floor(this.x / GRID_SIZE);
                const gridY = Math.floor(this.y / GRID_SIZE);

                if (this.canMove(gridX + this.nextDirection.x, gridY + this.nextDirection.y)) {
                    this.direction = { ...this.nextDirection };
                }

                // Move
                const newX = this.x + this.direction.x * this.speed;
                const newY = this.y + this.direction.y * this.speed;

                if (this.canMove(gridX + this.direction.x, gridY + this.direction.y)) {
                    this.x = newX;
                    this.y = newY;
                }

                // Tunnel wrapping
                if (this.x < -GRID_SIZE / 2) {
                    this.x = CANVAS_WIDTH - GRID_SIZE / 2;
                } else if (this.x > CANVAS_WIDTH + GRID_SIZE / 2) {
                    this.x = GRID_SIZE / 2;
                }

                // Eat dots
                this.eatDots();

                // Animate mouth
                this.animationFrame++;
                if (this.animationFrame % 10 === 0) {
                    this.mouthOpen = !this.mouthOpen;
                    this.mouthAngle = this.mouthOpen ? Math.PI / 6 : Math.PI / 12;
                }
            }

            canMove(gridX, gridY) {
                if (gridX < 0 || gridX >= MAZE_WIDTH || gridY < 0 || gridY >= MAZE_HEIGHT) {
                    return false;
                }
                
                // Additional safety check
                if (!MAZE_LAYOUT[gridY] || gridX >= MAZE_LAYOUT[gridY].length) {
                    return false;
                }
                
                const tile = MAZE_LAYOUT[gridY][gridX];
                return tile !== 1 && tile !== 4; // Not a wall or door
            }

            eatDots() {
                const gridX = Math.floor(this.x / GRID_SIZE);
                const gridY = Math.floor(this.y / GRID_SIZE);

                if (gridX >= 0 && gridX < MAZE_WIDTH && gridY >= 0 && gridY < MAZE_HEIGHT) {
                    // Safety check
                    if (!MAZE_LAYOUT[gridY] || gridX >= MAZE_LAYOUT[gridY].length) {
                        return;
                    }
                    
                    const tile = MAZE_LAYOUT[gridY][gridX];
                    
                    if (tile === 2) { // Regular dot
                        MAZE_LAYOUT[gridY][gridX] = 0;
                        score += 10;
                        dotsEaten++;
                    } else if (tile === 3) { // Power pellet
                        MAZE_LAYOUT[gridY][gridX] = 0;
                        score += 50;
                        dotsEaten++;
                        makeGhostsVulnerable();
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Determine rotation based on direction
                let rotation = 0;
                if (this.direction.x === 1) rotation = 0;
                else if (this.direction.x === -1) rotation = Math.PI;
                else if (this.direction.y === -1) rotation = -Math.PI / 2;
                else if (this.direction.y === 1) rotation = Math.PI / 2;

                ctx.rotate(rotation);

                // Draw Pac-Man
                ctx.fillStyle = COLORS.PACMAN;
                ctx.beginPath();
                
                if (this.mouthOpen) {
                    ctx.moveTo(0, 0);
                    ctx.arc(0, 0, GRID_SIZE * 0.4, this.mouthAngle, Math.PI * 2 - this.mouthAngle);
                } else {
                    ctx.arc(0, 0, GRID_SIZE * 0.4, 0, Math.PI * 2);
                }
                
                ctx.closePath();
                ctx.fill();

                // Add eye
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(GRID_SIZE * 0.15, -GRID_SIZE * 0.15, GRID_SIZE * 0.05, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Ghost {
            constructor(color, name) {
                this.color = color;
                this.name = name;
                this.direction = { x: 0, y: -1 };
                this.speed = 1.5;
                this.state = 'chase'; // chase, scatter, vulnerable, eaten
                this.targetX = 0;
                this.targetY = 0;
                this.scatterTarget = { x: 0, y: 0 };
                this.vulnerableTimer = 0;
                this.eaten = false;

                // Find valid starting positions for each ghost
                let startPos;
                switch (name) {
                    case 'blinky': // Red - top-right area
                        startPos = findValidStartingPosition(20, 1);
                        break;
                    case 'pinky': // Pink - top-left area  
                        startPos = findValidStartingPosition(7, 1);
                        break;
                    case 'inky': // Cyan - bottom-right area
                        startPos = findValidStartingPosition(20, 29);
                        break;
                    case 'clyde': // Orange - bottom-left area
                        startPos = findValidStartingPosition(7, 29);
                        break;
                    default:
                        startPos = findValidStartingPosition(14, 15);
                }

                this.x = startPos.x * GRID_SIZE + GRID_SIZE / 2;
                this.y = startPos.y * GRID_SIZE + GRID_SIZE / 2;
                
                console.log(`${name} starting at grid position: (${startPos.x}, ${startPos.y})`);
            }

            update() {
                if (gameState !== 'playing') return;

                // Handle state changes
                if (this.state === 'vulnerable') {
                    this.vulnerableTimer--;
                    if (this.vulnerableTimer <= 0) {
                        this.state = 'chase';
                    }
                }

                // Set target based on AI type and state
                this.setTarget();

                // Move towards target
                const gridX = Math.floor(this.x / GRID_SIZE);
                const gridY = Math.floor(this.y / GRID_SIZE);

                if (this.canMove(gridX + this.direction.x, gridY + this.direction.y)) {
                    this.move();
                } else {
                    this.chooseDirection();
                }

                // Tunnel wrapping
                if (this.x < -GRID_SIZE / 2) {
                    this.x = CANVAS_WIDTH - GRID_SIZE / 2;
                } else if (this.x > CANVAS_WIDTH + GRID_SIZE / 2) {
                    this.x = GRID_SIZE / 2;
                }
            }

            setTarget() {
                const pacmanGridX = Math.floor(pacman.x / GRID_SIZE);
                const pacmanGridY = Math.floor(pacman.y / GRID_SIZE);

                switch (this.name) {
                    case 'blinky': // Red - Direct chase
                        this.targetX = pacmanGridX;
                        this.targetY = pacmanGridY;
                        break;
                    
                    case 'pinky': // Pink - Ambush (target 4 tiles ahead)
                        this.targetX = pacmanGridX + pacman.direction.x * 4;
                        this.targetY = pacmanGridY + pacman.direction.y * 4;
                        break;
                    
                    case 'inky': // Cyan - Flank
                        const blinky = ghosts[0];
                        const vectorX = pacmanGridX - Math.floor(blinky.x / GRID_SIZE);
                        const vectorY = pacmanGridY - Math.floor(blinky.y / GRID_SIZE);
                        this.targetX = pacmanGridX + vectorX;
                        this.targetY = pacmanGridY + vectorY;
                        break;
                    
                    case 'clyde': // Orange - Erratic
                        const distanceToPacman = Math.sqrt(
                            Math.pow(this.x - pacman.x, 2) + Math.pow(this.y - pacman.y, 2)
                        );
                        
                        if (distanceToPacman > GRID_SIZE * 8) {
                            this.targetX = pacmanGridX;
                            this.targetY = pacmanGridY;
                        } else {
                            this.targetX = this.scatterTarget.x;
                            this.targetY = this.scatterTarget.y;
                        }
                        break;
                }

                // Clamp target to maze bounds
                this.targetX = Math.max(0, Math.min(MAZE_WIDTH - 1, this.targetX));
                this.targetY = Math.max(0, Math.min(MAZE_HEIGHT - 1, this.targetY));
            }

            move() {
                const speed = this.state === 'vulnerable' ? 1 : 
                             this.state === 'eaten' ? 3 : this.speed;
                
                this.x += this.direction.x * speed;
                this.y += this.direction.y * speed;

                // Snap to grid when at intersection
                if (Math.abs(this.x % GRID_SIZE - GRID_SIZE / 2) < 1 &&
                    Math.abs(this.y % GRID_SIZE - GRID_SIZE / 2) < 1) {
                    this.chooseDirection();
                }
            }

            chooseDirection() {
                const gridX = Math.floor(this.x / GRID_SIZE);
                const gridY = Math.floor(this.y / GRID_SIZE);

                // Get possible directions
                const directions = [];
                if (this.canMove(gridX, gridY - 1)) directions.push({ x: 0, y: -1 });
                if (this.canMove(gridX + 1, gridY)) directions.push({ x: 1, y: 0 });
                if (this.canMove(gridX, gridY + 1)) directions.push({ x: 0, y: 1 });
                if (this.canMove(gridX - 1, gridY)) directions.push({ x: -1, y: 0 });

                // Remove reverse direction
                const filteredDirections = directions.filter(dir => 
                    !(dir.x === -this.direction.x && dir.y === -this.direction.y)
                );

                let chosenDirection;
                
                if (filteredDirections.length > 0) {
                    if (this.state === 'vulnerable') {
                        // Random movement when vulnerable
                        chosenDirection = filteredDirections[Math.floor(Math.random() * filteredDirections.length)];
                    } else {
                        // Choose direction closest to target
                        chosenDirection = this.getBestDirection(filteredDirections, gridX, gridY);
                    }
                } else if (directions.length > 0) {
                    // If no forward options, allow reverse
                    chosenDirection = directions[Math.floor(Math.random() * directions.length)];
                }

                if (chosenDirection) {
                    this.direction = chosenDirection;
                }
            }

            getBestDirection(directions, gridX, gridY) {
                let bestDir = directions[0];
                let minDistance = Infinity;

                for (const dir of directions) {
                    const newX = gridX + dir.x;
                    const newY = gridY + dir.y;
                    const distance = Math.sqrt(
                        Math.pow(newX - this.targetX, 2) + Math.pow(newY - this.targetY, 2)
                    );

                    if (distance < minDistance) {
                        minDistance = distance;
                        bestDir = dir;
                    }
                }

                return bestDir;
            }

            canMove(gridX, gridY) {
                if (gridX < 0 || gridX >= MAZE_WIDTH || gridY < 0 || gridY >= MAZE_HEIGHT) {
                    return false;
                }
                
                // Additional safety check
                if (!MAZE_LAYOUT[gridY] || gridX >= MAZE_LAYOUT[gridY].length) {
                    return false;
                }
                
                const tile = MAZE_LAYOUT[gridY][gridX];
                
                // Ghosts can't go through doors unless eaten
                if (tile === 4 && !this.eaten) {
                    return false;
                }
                
                return tile !== 1; // Not a wall
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                let ghostColor = this.color;
                if (this.state === 'vulnerable') {
                    const flash = Math.floor(Date.now() / 200) % 2;
                    ghostColor = flash ? COLORS.GHOST_VULNERABLE : '#0000FF';
                } else if (this.state === 'eaten') {
                    // Draw only eyes
                    this.drawEyes();
                    ctx.restore();
                    return;
                }

                // Draw ghost body
                ctx.fillStyle = ghostColor;
                ctx.beginPath();
                
                const radius = GRID_SIZE * 0.4;
                const waveSize = GRID_SIZE * 0.1;
                
                // Head (semicircle)
                ctx.arc(0, -radius * 0.2, radius, Math.PI, 0);
                
                // Body with wavy bottom
                for (let i = 0; i <= 8; i++) {
                    const x = (i / 4 - 1) * radius;
                    const y = radius * 0.6 + (i % 2 === 0 ? waveSize : -waveSize);
                    ctx.lineTo(x, y);
                }
                
                ctx.closePath();
                ctx.fill();

                // Draw eyes
                this.drawEyes();

                ctx.restore();
            }

            drawEyes() {
                const eyeOffsetX = GRID_SIZE * 0.15;
                const eyeOffsetY = -GRID_SIZE * 0.1;
                const pupilOffsetX = this.direction.x * GRID_SIZE * 0.05;
                const pupilOffsetY = this.direction.y * GRID_SIZE * 0.05;

                // Left eye
                ctx.fillStyle = COLORS.GHOST_EYES;
                ctx.beginPath();
                ctx.arc(-eyeOffsetX, eyeOffsetY, GRID_SIZE * 0.08, 0, Math.PI * 2);
                ctx.fill();

                // Right eye
                ctx.beginPath();
                ctx.arc(eyeOffsetX, eyeOffsetY, GRID_SIZE * 0.08, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-eyeOffsetX + pupilOffsetX, eyeOffsetY + pupilOffsetY, GRID_SIZE * 0.04, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(eyeOffsetX + pupilOffsetX, eyeOffsetY + pupilOffsetY, GRID_SIZE * 0.04, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Game Objects
        let pacman = new Pacman();
        let ghosts = [
            new Ghost(COLORS.GHOST_RED, 'blinky'),
            new Ghost(COLORS.GHOST_PINK, 'pinky'),
            new Ghost(COLORS.GHOST_CYAN, 'inky'),
            new Ghost(COLORS.GHOST_ORANGE, 'clyde')
        ];

        // Set scatter targets for ghosts
        ghosts[0].scatterTarget = { x: 25, y: 1 };   // Blinky (top-right)
        ghosts[1].scatterTarget = { x: 2, y: 1 };    // Pinky (top-left)
        ghosts[2].scatterTarget = { x: 25, y: 29 };  // Inky (bottom-right)
        ghosts[3].scatterTarget = { x: 2, y: 29 };   // Clyde (bottom-left)

        // Fruit system
        let fruit = null;
        let fruitTimer = 0;

        function spawnFruit() {
            const fruitPositions = [
                { x: 14, y: 17 }, // Center of maze
                { x: 6, y: 11 },
                { x: 21, y: 11 }
            ];
            
            const position = fruitPositions[Math.floor(Math.random() * fruitPositions.length)];
            fruit = {
                x: position.x * GRID_SIZE + GRID_SIZE / 2,
                y: position.y * GRID_SIZE + GRID_SIZE / 2,
                points: [100, 300, 500, 700, 1000][Math.floor(Math.random() * 5)],
                type: Math.floor(Math.random() * 4)
            };
        }

        // Power pellet system
        function makeGhostsVulnerable() {
            ghosts.forEach(ghost => {
                if (ghost.state !== 'eaten') {
                    ghost.state = 'vulnerable';
                    ghost.vulnerableTimer = 300; // ~5 seconds at 60fps
                }
            });
        }

        // Collision detection
        function checkCollisions() {
            ghosts.forEach((ghost, index) => {
                const distance = Math.sqrt(
                    Math.pow(pacman.x - ghost.x, 2) + Math.pow(pacman.y - ghost.y, 2)
                );

                if (distance < GRID_SIZE * 0.6) {
                    if (ghost.state === 'vulnerable') {
                        // Eat ghost
                        ghost.state = 'eaten';
                        score += 200 * Math.pow(2, index);
                        
                        // Send to center and respawn
                        setTimeout(() => {
                            const startPos = findValidStartingPosition(14, 15);
                            ghost.x = startPos.x * GRID_SIZE + GRID_SIZE / 2;
                            ghost.y = startPos.y * GRID_SIZE + GRID_SIZE / 2;
                            ghost.state = 'chase';
                            ghost.eaten = false;
                        }, 2000);
                    } else if (ghost.state !== 'eaten') {
                        // Pac-Man dies
                        loseLife();
                    }
                }
            });

            // Check fruit collision
            if (fruit) {
                const distance = Math.sqrt(
                    Math.pow(pacman.x - fruit.x, 2) + Math.pow(pacman.y - fruit.y, 2)
                );

                if (distance < GRID_SIZE * 0.6) {
                    score += fruit.points;
                    fruit = null;
                }
            }
        }

        function loseLife() {
            lives--;
            
            if (lives <= 0) {
                gameState = 'gameOver';
            } else {
                // Reset positions
                const pacmanStartPos = findValidStartingPosition(14, 23);
                pacman.x = pacmanStartPos.x * GRID_SIZE + GRID_SIZE / 2;
                pacman.y = pacmanStartPos.y * GRID_SIZE + GRID_SIZE / 2;
                pacman.direction = { x: 0, y: 0 };
                
                ghosts.forEach((ghost, index) => {
                    let startPos;
                    switch (index) {
                        case 0: startPos = findValidStartingPosition(20, 1); break; // Blinky
                        case 1: startPos = findValidStartingPosition(7, 1); break;  // Pinky
                        case 2: startPos = findValidStartingPosition(20, 29); break; // Inky
                        case 3: startPos = findValidStartingPosition(7, 29); break;  // Clyde
                    }
                    
                    ghost.x = startPos.x * GRID_SIZE + GRID_SIZE / 2;
                    ghost.y = startPos.y * GRID_SIZE + GRID_SIZE / 2;
                    ghost.state = 'chase';
                    ghost.eaten = false;
                });
            }
        }

        // Level progression
        function checkLevelComplete() {
            if (dotsEaten >= totalDots) {
                level++;
                
                // Reset dots and increase difficulty
                resetMaze();
                ghosts.forEach(ghost => {
                    ghost.speed += 0.1;
                });
                
                // Bonus life every 10000 points
                if (score % 10000 === 0) {
                    lives++;
                }
            }
        }

        function resetMaze() {
            // Restore original maze layout with dots and power pellets
            for (let y = 0; y < MAZE_HEIGHT && y < MAZE_LAYOUT.length; y++) {
                if (!MAZE_LAYOUT[y]) continue;
                
                for (let x = 0; x < MAZE_WIDTH && x < MAZE_LAYOUT[y].length; x++) {
                    if (MAZE_LAYOUT[y][x] === 0) {
                        const originalTile = getOriginalMazeTile(x, y);
                        MAZE_LAYOUT[y][x] = originalTile;
                    }
                }
            }
            
            dotsEaten = 0;
        }

        function getOriginalMazeTile(x, y) {
            // This would restore the original layout - simplified for demo
            return Math.random() < 0.1 ? 3 : (Math.random() < 0.2 ? 2 : 0);
        }

        // Drawing functions with proper bounds checking
        function drawMaze() {
            ctx.fillStyle = COLORS.BACKGROUND;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            for (let y = 0; y < MAZE_HEIGHT && y < MAZE_LAYOUT.length; y++) {
                if (!MAZE_LAYOUT[y]) continue;
                
                for (let x = 0; x < MAZE_WIDTH && x < MAZE_LAYOUT[y].length; x++) {
                    const tile = MAZE_LAYOUT[y][x];
                    const pixelX = x * GRID_SIZE;
                    const pixelY = y * GRID_SIZE;

                    if (tile === 1) { // Wall
                        ctx.fillStyle = COLORS.WALL;
                        
                        // Draw wall with rounded corners effect
                        ctx.beginPath();
                        ctx.rect(pixelX + 2, pixelY + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                        ctx.fill();
                        
                        // Add inner glow
                        ctx.strokeStyle = '#4444FF';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(pixelX + 3, pixelY + 3, GRID_SIZE - 6, GRID_SIZE - 6);
                    } else if (tile === 2) { // Dot
                        ctx.fillStyle = COLORS.DOT;
                        ctx.beginPath();
                        ctx.arc(
                            pixelX + GRID_SIZE / 2,
                            pixelY + GRID_SIZE / 2,
                            3, 0, Math.PI * 2
                        );
                        ctx.fill();
                    } else if (tile === 3) { // Power pellet
                        const pulse = Math.sin(Date.now() * 0.01) * 0.5 + 1;
                        
                        ctx.fillStyle = COLORS.POWER_PELLET;
                        ctx.beginPath();
                        ctx.arc(
                            pixelX + GRID_SIZE / 2,
                            pixelY + GRID_SIZE / 2,
                            6 * pulse, 0, Math.PI * 2
                        );
                        ctx.fill();
                    } else if (tile === 4) { // Ghost house door
                        ctx.strokeStyle = '#FFFF00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(pixelX + 2, pixelY + GRID_SIZE / 2);
                        ctx.lineTo(pixelX + GRID_SIZE - 2, pixelY + GRID_SIZE / 2);
                        ctx.stroke();
                    } else if (tile === 5) { // Tunnel
                        ctx.fillStyle = '#000033';
                        ctx.fillRect(pixelX, pixelY, GRID_SIZE, GRID_SIZE);
                    }
                }
            }

            // Draw ghost house
            drawGhostHouse();
        }

        function drawGhostHouse() {
            const houseX = 11 * GRID_SIZE;
            const houseY = 14 * GRID_SIZE;
            const houseWidth = 6 * GRID_SIZE;
            const houseHeight = 4 * GRID_SIZE;

            ctx.strokeStyle = COLORS.WALL;
            ctx.lineWidth = 2;
            ctx.strokeRect(houseX, houseY, houseWidth, houseHeight);

            // Add door
            ctx.fillStyle = '#FFFF00';
            ctx.fillRect(
                houseX + houseWidth / 2 - GRID_SIZE / 4,
                houseY,
                GRID_SIZE / 2,
                3
            );
        }

        function drawFruit() {
            if (!fruit) return;

            const fruitColors = ['#FF0000', '#00FF00', '#FFFF00', '#FF8800'];
            
            ctx.fillStyle = fruitColors[fruit.type];
            ctx.beginPath();
            ctx.arc(fruit.x, fruit.y, GRID_SIZE * 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Add shine effect
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(fruit.x - 5, fruit.y - 5, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawUI() {
            // Score
            ctx.fillStyle = COLORS.PACMAN;
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`SCORE: ${score}`, 10, 25);

            // Lives
            ctx.fillText(`LIVES: ${lives}`, 10, 50);
            
            for (let i = 0; i < lives; i++) {
                const x = 150 + i * 30;
                const y = 40;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.fillStyle = COLORS.PACMAN;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.arc(0, 0, 8, Math.PI / 6, Math.PI * 2 - Math.PI / 6);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Level
            ctx.textAlign = 'right';
            ctx.fillText(`LEVEL: ${level}`, CANVAS_WIDTH - 10, 25);

            // Game state messages
            if (gameState === 'ready') {
                drawCenteredMessage('PRESS SPACE TO START', COLORS.PACMAN);
            } else if (gameState === 'paused') {
                drawCenteredMessage('PAUSED', '#FFFF00');
            } else if (gameState === 'gameOver') {
                drawCenteredMessage('GAME OVER', '#FF0000');
            }
        }

        function drawCenteredMessage(text, color) {
            ctx.fillStyle = color;
            ctx.font = 'bold 32px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(text, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            
            if (gameState === 'gameOver') {
                ctx.font = '16px Courier New';
                ctx.fillText('Press SPACE to restart', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 40);
            }
        }

        // Input handling
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === ' ') {
                e.preventDefault();
                handleSpaceKey();
            } else if (gameState === 'playing') {
                handleDirectionKeys(e.key);
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        function handleSpaceKey() {
            switch (gameState) {
                case 'ready':
                    gameState = 'playing';
                    break;
                case 'playing':
                    gameState = 'paused';
                    break;
                case 'paused':
                    gameState = 'playing';
                    break;
                case 'gameOver':
                    restartGame();
                    break;
            }
        }

        function handleDirectionKeys(key) {
            switch (key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    pacman.nextDirection = { x: 0, y: -1 };
                    break;
                case 'arrowdown':
                case 's':
                    pacman.nextDirection = { x: 0, y: 1 };
                    break;
                case 'arrowleft':
                case 'a':
                    pacman.nextDirection = { x: -1, y: 0 };
                    break;
                case 'arrowright':
                case 'd':
                    pacman.nextDirection = { x: 1, y: 0 };
                    break;
            }
        }

        function restartGame() {
            score = 0;
            lives = 3;
            level = 1;
            dotsEaten = 0;
            
            // Reset maze
            resetMaze();
            
            // Reset entities with valid starting positions
            pacman = new Pacman();
            ghosts = [
                new Ghost(COLORS.GHOST_RED, 'blinky'),
                new Ghost(COLORS.GHOST_PINK, 'pinky'),
                new Ghost(COLORS.GHOST_CYAN, 'inky'),
                new Ghost(COLORS.GHOST_ORANGE, 'clyde')
            ];
            
            ghosts[0].scatterTarget = { x: 25, y: 1 };
            ghosts[1].scatterTarget = { x: 2, y: 1 };
            ghosts[2].scatterTarget = { x: 25, y: 29 };
            ghosts[3].scatterTarget = { x: 2, y: 29 };
            
            fruit = null;
            gameState = 'ready';
        }

        // Game loop
        function update() {
            if (gameState === 'playing') {
                pacman.update();
                
                ghosts.forEach(ghost => ghost.update());
                
                checkCollisions();
                checkLevelComplete();

                // Fruit spawning timer
                fruitTimer++;
                if (fruitTimer > 600 && !fruit) { // Spawn every ~10 seconds
                    spawnFruit();
                    fruitTimer = 0;
                } else if (fruit && fruitTimer > 300) { // Remove after ~5 seconds
                    fruit = null;
                    fruitTimer = 0;
                }
            }

            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            drawMaze();
            
            if (fruit) drawFruit();
            
            pacman.draw();
            ghosts.forEach(ghost => ghost.draw());
            
            drawUI();
        }

        // Start the game
        update();
    </script>
</body>
</html>