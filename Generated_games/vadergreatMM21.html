<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Space Invaders - 1978 Taito Faithful</title>
    <style>
        body {
            background-color: #111;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace; /* Fallback for retro look */
        }
        
        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            border: 4px solid #333;
        }

        canvas {
            display: block;
            background-color: #000;
        }

        /* CRT Scanline effect overlay */
        .scanlines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="600" height="700"></canvas>
    <div class="scanlines"></div>
</div>

<script>
/**
 * SPACE INVADERS - FAITHFUL RECREATION
 * 
 * Features:
 * - Procedural Pixel Art Sprites (Squid, Crab, Octopus)
 * - Web Audio API Sound Synthesis (No external files)
 * - Particle System for Explosions
 * - Destructible Bunkers (Pixel-level erosion)
 */

// --- CONFIGURATION ---
const CANVAS_WIDTH = 600;
const CANVAS_HEIGHT = 700;
const PLAYER_SPEED = 5;
const BULLET_SPEED = 7;
const ALIEN_DROP_HEIGHT = 20; // How much they drop
const BUNKER_COUNT = 4;

// Colors
const C_BLACK = "#000000";
const C_GREEN_BRIGHT = "#00FF00"; // Classic terminal green
const C_GREEN_DIM = "#008800";
const C_WHITE = "#FFFFFF";
const C_RED = "#FF0000";

// --- SPRITE DATA (Binary Maps) ---
// 1 = draw pixel, 0 = empty
const SPRITES = {
    squid: [
        [0,0,0,0,1,1,1,1,0,0,0,0],
        [0,0,0,1,1,1,1,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,0,1,1,1,0,1,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,1,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,1,0,1],
        [0,0,0,1,1,0,1,1,0,0,0,0]
    ],
    squid2: [
        [0,0,0,0,1,1,1,1,0,0,0,0],
        [0,0,0,1,1,1,1,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,0,1,1,1,0,1,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,1,1,1,1,1,1,1,1,0,1],
        [0,0,1,0,0,0,0,0,0,1,0,0], // Animation difference
        [0,1,1,0,0,0,0,0,1,1,0,0]  // Animation difference
    ],
    crab: [
        [0,0,1,0,0,0,0,0,0,1,0,0],
        [0,0,0,1,0,0,0,0,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,0,1,1,1,0,1,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,1,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,1,0,1],
        [0,0,0,1,1,0,0,1,1,0,0,0]
    ],
    crab2: [
        [0,0,1,0,0,0,0,0,0,1,0,0],
        [0,0,0,1,0,0,0,0,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,0,1,1,1,0,1,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,1,1,1,1,1,1,1,1,0,1],
        [0,0,1,0,0,0,0,0,0,1,0,0], // Animation difference
        [0,0,1,0,0,0,0,0,0,1,0,0]  // Animation difference
    ],
    octopus: [
        [0,0,0,0,1,1,1,1,0,0,0,0],
        [0,0,0,1,1,1,1,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,0,1,1,1,0,1,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,1,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,0,1,0,1],
        [0,0,0,1,1,0,0,1,1,0,0,0]
    ],
    octopus2: [
        [0,0,0,0,1,1,1,1,0,0,0,0],
        [0,0,0,1,1,1,1,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,0,1,1,1,0,1,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,1,1,1,1,1,1,1,1,0,1],
        [0,0,1,0,0,0,0,0,0,1,0,0], // Animation difference
        [0,0,1,0,0,0,0,0,0,1,0,0]  // Animation difference
    ],
    player: [
        [0,0,0,0,0,0,1,0,0,0,0,0],
        [0,0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,0,0,1,1,1,0,0,0,0],
        [0,1,1,1,1,1,1,1,1,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1,1]
    ],
    ufo: [
        [0,0,0,0,0,1,1,1,1,0,0,0,0],
        [0,0,0,0,1,1,1,1,1,1,0,0,0],
        [0,0,0,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,1,1,1,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1,1,1]
    ]
};

// --- AUDIO SYSTEM (Web Audio API) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const Sound = {
    playShoot: () => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    },
    playExplosion: () => {
        const bufferSize = audioCtx.sampleRate * 0.2; // 200ms
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
        noise.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    },
    playInvaderDie: () => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    },
    playUFO: () => {
        // Continuous tone managed by game loop or separate object, 
        // simplified here to a blip for hit
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(500, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(1000, audioCtx.currentTime + 0.1); // Slide up
        gain.gain.value = 0.1;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.2);
    }
};

// --- GAME CLASSES ---

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.life = 1.0;
        this.color = color;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.02;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 3, 3);
        ctx.globalAlpha = 1.0;
    }
}

class Bunker {
    constructor(xOffset) {
        this.blocks = [];
        const rows = 15;
        const cols = 20;
        const size = 4; // Pixel size
        
        // Create an arch shape
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                // Arch logic: remove middle bottom
                if (r > 5 && r < 10 && c > 6 && c < 14) continue;
                
                this.blocks.push({
                    x: xOffset + c * size,
                    y: CANVAS_HEIGHT - 150 + r * size,
                    w: size,
                    h: size,
                    active: true
                });
            }
        }
    }

    draw(ctx) {
        ctx.fillStyle = C_GREEN_BRIGHT;
        this.blocks.forEach(b => {
            if(b.active) ctx.fillRect(b.x, b.y, b.w, b.h);
        });
    }

    checkCollision(projectile) {
        let hit = false;
        this.blocks.forEach(b => {
            if (!b.active) return;
            
            // Simple AABB
            if (projectile.x < b.x + b.w &&
                projectile.x + projectile.width > b.x &&
                projectile.y < b.y + b.h &&
                projectile.y + projectile.height > b.y) {
                
                b.active = false; // Destroy block
                hit = true;
                
                // Erode neighbors slightly (simple radius check)
                this.blocks.forEach(neighbor => {
                    if(!neighbor.active) return;
                    const dx = Math.abs(b.x - neighbor.x);
                    const dy = Math.abs(b.y - neighbor.y);
                    if(dx < 8 && dy < 8) { 
                        // Chance to destroy neighbor
                        if(Math.random() > 0.5) neighbor.active = false; 
                    }
                });
            }
        });
        return hit;
    }
}

class Alien {
    constructor(type, x, y) {
        this.type = type; // 'squid', 'crab', 'octopus'
        this.x = x;
        this.y = y;
        this.width = 11 * 3; // Scale up
        this.height = 8 * 3;
        this.frame = 0;
    }

    draw(ctx) {
        let map;
        if (this.type === 'squid') map = (Math.floor(Date.now() / 500) % 2 === 0) ? SPRITES.squid : SPRITES.squid2;
        else if (this.type === 'crab') map = (Math.floor(Date.now() / 500) % 2 === 0) ? SPRITES.crab : SPRITES.crab2;
        else map = (Math.floor(Date.now() / 500) % 2 === 0) ? SPRITES.octopus : SPRITES.octopus2;

        const pixelSize = 3;
        
        // Color based on type
        if(this.type === 'squid') ctx.fillStyle = C_WHITE; // Top rows white
        else if (this.type === 'crab') ctx.fillStyle = C_WHITE; 
        else ctx.fillStyle = C_WHITE; // Classic arcade was actually varied colors, but Taito B&W/Monochrome logic often used white or varying shades. Let's use White for high contrast.

        for(let r=0; r<map.length; r++) {
            for(let c=0; c<map[r].length; c++) {
                if(map[r][c] === 1) {
                    ctx.fillRect(this.x + c * pixelSize, this.y + r * pixelSize, pixelSize, pixelSize);
                }
            }
        }
    }
}

class UFO {
    constructor() {
        this.width = 13 * 3;
        this.height = 5 * 3;
        this.x = -this.width;
        this.y = 50;
        this.speed = 2;
        this.active = false;
        this.points = [50, 100, 150, 200, 300]; // Mystery points
    }

    spawn() {
        if(!this.active) {
            this.active = true;
            this.x = -this.width;
            this.direction = Math.random() > 0.5 ? 1 : -1; // Can come from left or right? Usually left to right.
            this.direction = 1; 
        }
    }

    update() {
        if(this.active) {
            this.x += this.speed * this.direction;
            if((this.direction === 1 && this.x > CANVAS_WIDTH) || (this.direction === -1 && this.x < -this.width)) {
                this.active = false;
            }
        }
    }

    draw(ctx) {
        if(!this.active) return;
        
        const map = SPRITES.ufo;
        const pixelSize = 3;
        ctx.fillStyle = C_RED; // UFO is red

        for(let r=0; r<map.length; r++) {
            for(let c=0; c<map[r].length; c++) {
                if(map[r][c] === 1) {
                    ctx.fillRect(this.x + c * pixelSize, this.y + r * pixelSize, pixelSize, pixelSize);
                }
            }
        }
    }
}

// --- MAIN GAME LOGIC ---

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game State
let gameState = 'START'; // START, PLAYING, GAMEOVER
let score = 0;
let highScore = localStorage.getItem('invaders_highscore') || 0;
let lives = 3;
let level = 1;

// Entities
let player = {
    x: CANVAS_WIDTH / 2 - 12,
    y: CANVAS_HEIGHT - 60,
    width: 12 * 3, // scaled sprite size
    height: 7 * 3,
    dx: 0,
    bullet: null // {x, y, active}
};

let aliens = [];
let bunkers = [];
let ufo = new UFO();
let particles = [];

// Alien Movement Config
let alienDirection = 1; // 1 right, -1 left
let alienSpeedBase = 1;
let alienMoveTimer = 0;
let alienMoveInterval = 60; // Frames between moves (decreases as they die)

// Inputs
const keys = {};

window.addEventListener('keydown', e => {
    keys[e.code] = true;
    
    if(gameState === 'START' || gameState === 'GAMEOVER') {
        if(e.code === 'Space' || e.code === 'Enter') resetGame();
    } else if (gameState === 'PLAYING') {
        if(e.code === 'Space' && !player.bullet) {
            player.bullet = { x: player.x + 11, y: player.y, width: 3, height: 10, active: true };
            Sound.playShoot();
        }
    }
});

window.addEventListener('keyup', e => keys[e.code] = false);

function initAliens() {
    aliens = [];
    const startX = 50;
    const startY = 100;
    const padding = 15;

    // Row 0 & 1: Squid
    for(let c=0; c<11; c++) {
        aliens.push(new Alien('squid', startX + c * (30 + padding), startY));
        aliens.push(new Alien('squid', startX + c * (30 + padding), startY + 40));
    }
    // Row 2 & 3: Crab
    for(let c=0; c<11; c++) {
        aliens.push(new Alien('crab', startX + c * (35 + padding), startY + 80));
        aliens.push(new Alien('crab', startX + c * (35 + padding), startY + 120));
    }
    // Row 4: Octopus
    for(let c=0; c<11; c++) {
        aliens.push(new Alien('octopus', startX + c * (30 + padding), startY + 160));
    }
}

function resetGame() {
    score = 0;
    lives = 3;
    level = 1;
    gameState = 'PLAYING';
    
    // Init Audio Context on user interaction
    if(audioCtx.state === 'suspended') audioCtx.resume();

    initAliens();
    bunkers = [];
    for(let i=0; i<BUNKER_COUNT; i++) {
        let spacing = CANVAS_WIDTH / BUNKER_COUNT;
        bunkers.push(new Bunker(i * spacing + (spacing/2 - 60)));
    }
    
    player.bullet = null;
    alienDirection = 1;
}

function spawnExplosion(x, y, color) {
    for(let i=0; i<15; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function update() {
    if(gameState !== 'PLAYING') return;

    // --- Player Movement ---
    if(keys['ArrowLeft'] || keys['KeyA']) player.x -= PLAYER_SPEED;
    if(keys['ArrowRight'] || keys['KeyD']) player.x += PLAYER_SPEED;
    
    // Clamp
    if(player.x < 0) player.x = 0;
    if(player.x + player.width > CANVAS_WIDTH) player.x = CANVAS_WIDTH - player.width;

    // --- Player Bullet ---
    if(player.bullet && player.bullet.active) {
        player.bullet.y -= BULLET_SPEED;
        if(player.bullet.y < 0) player.bullet.active = false;
        
        // Check UFO Hit
        if(ufo.active) {
            if (player.bullet.x < ufo.x + ufo.width &&
                player.bullet.x + player.bullet.width > ufo.x &&
                player.bullet.y < ufo.y + ufo.height &&
                player.bullet.y + player.bullet.height > ufo.y) {
                
                // UFO Hit
                let pts = ufo.points[Math.floor(Math.random() * ufo.points.length)];
                score += pts;
                spawnExplosion(ufo.x + ufo.width/2, ufo.y + ufo.height/2, C_RED);
                Sound.playUFO();
                ufo.active = false;
                player.bullet.active = false;
            }
        }

        // Check Alien Hit
        if(player.bullet.active) {
            for(let i=0; i<aliens.length; i++) {
                let a = aliens[i];
                if (player.bullet.x < a.x + a.width &&
                    player.bullet.x + player.bullet.width > a.x &&
                    player.bullet.y < a.y + a.height &&
                    player.bullet.y + player.bullet.height > a.y) {
                    
                    // Kill Alien
                    aliens.splice(i, 1);
                    player.bullet.active = false;
                    score += (a.type === 'squid' ? 30 : (a.type === 'crab' ? 20 : 10));
                    spawnExplosion(a.x + a.width/2, a.y + a.height/2, C_WHITE);
                    Sound.playInvaderDie();
                    
                    // Increase speed based on count
                    let ratio = aliens.length / 55;
                    alienMoveInterval = Math.max(5, Math.floor(60 * ratio));
                    break; 
                }
            }
        }

        // Check Bunker Hit (Player Bullet)
        if(player.bullet.active) {
            for(let b of bunkers) {
                if(b.checkCollision(player.bullet)) {
                    player.bullet.active = false;
                    spawnExplosion(player.bullet.x, player.bullet.y, C_GREEN_DIM);
                    break;
                }
            }
        }
    }

    // --- Alien Movement ---
    alienMoveTimer++;
    if(alienMoveTimer > alienMoveInterval) {
        alienMoveTimer = 0;
        
        let hitEdge = false;
        // Check edges
        for(let a of aliens) {
            if((alienDirection === 1 && a.x + a.width >= CANVAS_WIDTH - 10) ||
               (alienDirection === -1 && a.x <= 10)) {
                hitEdge = true;
                break;
            }
        }

        if(hitEdge) {
            alienDirection *= -1;
            aliens.forEach(a => a.y += ALIEN_DROP_HEIGHT);
            
            // Game Over Check: Aliens reached bottom
            for(let a of aliens) {
                if(a.y + a.height >= player.y) {
                    gameState = 'GAMEOVER';
                    lives = 0;
                }
            }
        } else {
            aliens.forEach(a => a.x += (alienDirection * (30 * alienMoveInterval/60))); // Move logic
             // Actually, standard implementation moves by fixed pixels per step.
             // Let's simplify: move by speed variable
             let currentSpeed = 2 + ((55 - aliens.length) / 10);
             aliens.forEach(a => a.x += (alienDirection * currentSpeed));
        }
    }

    // --- Alien Bombs ---
    if(Math.random() < 0.02 + (0.001 * (55 - aliens.length)) && aliens.length > 0) {
        let shooter = aliens[Math.floor(Math.random() * aliens.length)];
        // Simple bomb logic: straight down or slight zigzag
        bombs.push({
            x: shooter.x + shooter.width/2,
            y: shooter.y + shooter.height,
            width: 4,
            height: 10,
            vy: 3
        });
    }

    // --- Update Bombs ---
    for(let i=bombs.length-1; i>=0; i--) {
        let b = bombs[i];
        b.y += b.vy;
        
        // Hit Player?
        if (b.x < player.x + player.width &&
            b.x + b.width > player.x &&
            b.y < player.y + player.height &&
            b.y + b.height > player.y) {
            
            lives--;
            spawnExplosion(player.x + player.width/2, player.y + player.height/2, C_GREEN_BRIGHT);
            Sound.playExplosion();
            bombs.splice(i, 1);
            if(lives <= 0) gameState = 'GAMEOVER';
            continue;
        }

        // Hit Bunker?
        let hitBunker = false;
        for(let bunk of bunkers) {
            if(bunk.checkCollision(b)) {
                hitBunker = true;
                break;
            }
        }
        if(hitBunker) {
            bombs.splice(i, 1);
            continue;
        }

        // Off screen
        if(b.y > CANVAS_HEIGHT) bombs.splice(i, 1);
    }

    // --- UFO Logic ---
    if(!ufo.active && Math.random() < 0.001) {
        ufo.spawn();
    }
    ufo.update();

    // --- Particles ---
    for(let i=particles.length-1; i>=0; i--) {
        particles[i].update();
        if(particles[i].life <= 0) particles.splice(i, 1);
    }

    // --- Level Clear ---
    if(aliens.length === 0) {
        level++;
        initAliens(); // Reset aliens
        alienMoveInterval = 60;
        player.bullet = null;
        bombs = [];
        // Restore bunkers? Usually yes in arcade.
        bunkers = [];
        for(let i=0; i<BUNKER_COUNT; i++) {
            let spacing = CANVAS_WIDTH / BUNKER_COUNT;
            bunkers.push(new Bunker(i * spacing + (spacing/2 - 60)));
        }
    }
}

let bombs = [];

function draw() {
    // Clear Screen
    ctx.fillStyle = C_BLACK;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    if(gameState === 'START') {
        ctx.fillStyle = C_GREEN_BRIGHT;
        ctx.font = "40px Courier New";
        ctx.textAlign = "center";
        ctx.fillText("SPACE INVADERS", CANVAS_WIDTH/2, 200);
        
        ctx.font = "20px Courier New";
        ctx.fillText("PRESS ENTER TO START", CANVAS_WIDTH/2, 400);
        ctx.fillText("ARROWS to Move | SPACE to Fire", CANVAS_WIDTH/2, 440);
    } else {
        // Draw UI
        ctx.fillStyle = C_WHITE;
        ctx.font = "20px Courier New";
        ctx.textAlign = "left";
        ctx.fillText(`SCORE: ${score}`, 20, 30);
        ctx.textAlign = "right";
        ctx.fillText(`HI-SCORE: ${highScore}`, CANVAS_WIDTH - 20, 30);
        
        // Lives
        for(let i=0; i<lives; i++) {
            drawSprite(ctx, SPRITES.player, 50 + i * 40, CANVAS_HEIGHT - 30, C_GREEN_BRIGHT, 2);
        }

        // Draw Bunkers
        bunkers.forEach(b => b.draw(ctx));

        // Draw Player
        if(gameState !== 'GAMEOVER') {
            drawSprite(ctx, SPRITES.player, player.x, player.y, C_GREEN_BRIGHT, 3);
            
            // Draw Bullet
            if(player.bullet && player.bullet.active) {
                ctx.fillStyle = C_WHITE;
                ctx.fillRect(player.bullet.x, player.bullet.y, player.bullet.width, player.bullet.height);
            }
        }

        // Draw Aliens
        aliens.forEach(a => a.draw(ctx));

        // Draw Bombs
        ctx.fillStyle = C_GREEN_BRIGHT; 
        bombs.forEach(b => {
            let xOffset = Math.sin(b.y * 0.1) * 5;
            ctx.fillRect(b.x + xOffset, b.y, b.width, b.height);
        });

        // Draw UFO
        ufo.draw(ctx);

        // Draw Particles
        particles.forEach(p => p.draw(ctx));

        if(gameState === 'GAMEOVER') {
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.fillStyle = C_RED;
            ctx.font = "50px Courier New";
            ctx.textAlign = "center";
            ctx.fillText("GAME OVER", CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
            
            if(score > highScore) {
                highScore = score;
                localStorage.setItem('invaders_highscore', highScore);
            }
        }
    }

    requestAnimationFrame(loop); // Ensure loop continues running
}

// Helper to draw binary sprite maps
function drawSprite(ctx, map, x, y, color, scale=1) {
    ctx.fillStyle = color;
    for(let r=0; r<map.length; r++) {
        for(let c=0; c<map[r].length; c++) {
            if(map[r][c] === 1) {
                ctx.fillRect(x + c * scale, y + r * scale, scale, scale);
            }
        }
    }
}

function loop() {
    update();
    draw();
}

// Start Loop
requestAnimationFrame(loop);

</script>
</body>
</html>