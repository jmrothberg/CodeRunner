<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Q*bert - Arcade Tribute</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .hud {
            font-size: 28px;
            text-shadow: 0 0 10px #00bfff, 2px 2px 0 #000;
            font-weight: bold;
            display: flex;
            gap: 40px;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 30, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }
        h1 {
            font-size: 80px;
            color: #ffcc00;
            text-shadow: 4px 4px #ff6600, -2px -2px #00ccff;
            margin-bottom: 20px;
            letter-spacing: 5px;
            transform: skew(-10deg);
        }
        p { font-size: 24px; color: #ddd; text-shadow: 1px 1px #000; margin: 5px;}
        .blink { animation: blinker 1s linear infinite; color: #00ff00; margin-top: 30px;}
        @keyframes blinker { 50% { opacity: 0; } }
        button {
            margin-top: 40px;
            padding: 15px 50px;
            font-size: 28px;
            background: linear-gradient(to bottom, #ff6600, #cc3300);
            border: none;
            color: white;
            cursor: pointer;
            font-family: inherit;
            box-shadow: 0 6px #801f00;
            transform: skew(-10deg);
            transition: transform 0.1s;
        }
        button:hover { filter: brightness 1.2; }
        button:active { transform: skew(-10deg) translateY(4px); box-shadow: 0 2px #801f00; }
        
        .controls-hint {
            margin-top: 20px;
            font-size: 16px;
            color: #aaa;
            background: rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 20px;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud">
        <span>SCORE: <span id="score">0</span></span>
        <span style="margin-left:auto">LEVEL: <span id="level">1</span></span>
        <span>LIVES: <span id="lives">3</span></span>
    </div>
</div>

<div id="start-screen">
    <h1>Q*BERT</h1>
    <p>Jump on the cubes to change their colors.</p>
    <p>Avoid Coily, Slick, Sam, Ugg & Wrongway!</p>
    <div class="controls-hint">Use ARROW KEYS (Combine Up/Down + Left/Right)</div>
    <p class="blink">CLICK TO START</p>
</div>

<div id="game-over-screen" style="display: none;">
    <h1>GAME OVER</h1>
    <p>Final Score: <span id="final-score">0</span></p>
    <button onclick="location.reload()">PLAY AGAIN</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * Q*BERT CLONE - Faithful Recreation
 */

// --- CONFIGURATION ---
const COLORS = {
    bgTop: '#1a1a2e',
    bgBottom: '#000000',
    tileTop1: '#00bfff', 
    tileSideR: '#008ecc',
    tileSideL: '#006699',
    tileTop2: '#ffcc00', 
    tileSideR2: '#cc9900',
    tileSideL2: '#996600',
    qbertBody: '#ff6600',
    qbertNose: '#ffaa33',
    coily: '#9933ff',
    slickSam: '#00ff00',
    uggWrongway: '#cc66ff'
};

// --- AUDIO SYSTEM ---
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playJump: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(300, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    },
    playLand: function() {
        this.playTone(800, 'square', 0.05, 0.05);
    },
    playDie: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
    },
    playChange: function() {
        this.playTone(600, 'sine', 0.1, 0.05);
        setTimeout(() => this.playTone(900, 'sine', 0.1, 0.05), 50);
    },
    playBonus: function() {
        [400, 500, 600, 800, 1000].forEach((f, i) => {
            setTimeout(() => this.playTone(f, 'square', 0.1, 0.05), i * 80);
        });
    }
};

// --- ENGINE ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let WIDTH, HEIGHT;
const TILE_WIDTH = 60; 
const TILE_HEIGHT = 30; 
const PYRAMID_ROWS = 7;

// Input State
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

function resize() {
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
}
window.addEventListener('resize', resize);
resize();

window.addEventListener('keydown', e => { if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });

function g2s(row, col) {
    const originX = WIDTH / 2;
    const originY = 150; 
    const x = (col - row) * (TILE_WIDTH / 2) + originX;
    const y = (row + col) * (TILE_HEIGHT / 2) + originY;
    return { x, y };
}

// --- CLASSES ---

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 1) * 6;
        this.life = 1.0;
        this.color = color;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.vy += 0.2; // Gravity
        this.life -= 0.03;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Tile {
    constructor(row, col) {
        this.row = row; this.col = col;
        const pos = g2s(row, col);
        this.x = pos.x; this.y = pos.y;
        this.changed = false;
        
        // Pre-calculate gradients for performance
        this.topGrad = ctx.createLinearGradient(this.x, this.y - TILE_HEIGHT/2 + 5, this.x, this.y + TILE_HEIGHT/2);
        this.sideRGrad = ctx.createLinearGradient(this.x, this.y, this.x + TILE_WIDTH/2, this.y);
        this.sideLGrad = ctx.createLinearGradient(this.x, this.y, this.x - TILE_WIDTH/2, this.y);
    }

    updateColors() {
        const c1 = this.changed ? COLORS.tileTop2 : COLORS.tileTop1;
        const c2 = this.changed ? COLORS.tileSideR2 : COLORS.tileSideR;
        const c3 = this.changed ? COLORS.tileSideL2 : COLORS.tileSideL;

        this.topGrad.addColorStop(0, c1);
        this.topGrad.addColorStop(1, '#ffffff'); // Highlight
        
        this.sideRGrad.addColorStop(0, c2);
        this.sideRGrad.addColorStop(1, '#000000'); // Shadow edge

        this.sideLGrad.addColorStop(0, c3);
        this.sideLGrad.addColorStop(1, '#000000');
    }

    draw(ctx) {
        this.updateColors();
        
        const w = TILE_WIDTH / 2 - 2; 
        const h = TILE_HEIGHT / 2 - 2;
        const z = 25; // Cube height

        // Top Face
        ctx.fillStyle = this.topGrad;
        ctx.beginPath(); ctx.moveTo(this.x, this.y - h); ctx.lineTo(this.x + w, this.y);
        ctx.lineTo(this.x, this.y + h); ctx.lineTo(this.x - w, this.y); ctx.closePath();
        ctx.fill();

        // Right Face
        ctx.fillStyle = this.sideRGrad;
        ctx.beginPath(); ctx.moveTo(this.x + w, this.y); ctx.lineTo(this.x + w, this.y + z);
        ctx.lineTo(this.x, this.y + h + z); ctx.lineTo(this.x, this.y + h); ctx.closePath();
        ctx.fill();

        // Left Face
        ctx.fillStyle = this.sideLGrad;
        ctx.beginPath(); ctx.moveTo(this.x - w, this.y); ctx.lineTo(this.x - w, this.y + z);
        ctx.lineTo(this.x, this.y + h + z); ctx.lineTo(this.x, this.y + h); ctx.closePath();
        ctx.fill();

        // Outline
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath(); ctx.moveTo(this.x, this.y - h); ctx.lineTo(this.x + w, this.y);
        ctx.lineTo(this.x + w, this.y + z); ctx.lineTo(this.x, this.y + h + z);
        ctx.lineTo(this.x - w, this.y + z); ctx.lineTo(this.x - w, this.y); ctx.closePath();
        ctx.stroke();
    }
}

class Pyramid {
    constructor() {
        this.tiles = [];
        for (let r = 0; r < PYRAMID_ROWS; r++) {
            for (let c = 0; c <= r; c++) this.tiles.push(new Tile(r, c));
        }
    }
    getTile(row, col) { return this.tiles.find(t => t.row === row && t.col === col); }
    checkComplete() {
        if (this.tiles.every(t => t.changed)) Game.levelComplete();
    }
    draw(ctx) { this.tiles.forEach(t => t.draw(ctx)); }
}

class Qbert {
    constructor() { this.reset(); }

    reset() {
        this.row = 0; this.col = 0;
        const pos = g2s(0, 0);
        this.x = pos.x; this.y = pos.y - 25;
        this.targetX = this.x; this.targetY = this.y;
        this.isJumping = false; this.jumpProgress = 0;
        this.facingRight = true; this.dead = false;
        this.scale = 1;
    }

    jump(dRow, dCol) {
        if (this.isJumping || this.dead) return;

        const nextRow = this.row + dRow;
        const nextCol = this.col + dCol;
        
        // Bounds Check
        let valid = false;
        if (nextRow >= 0 && nextRow < PYRAMID_ROWS) {
            if (dRow === -1 && dCol === 0 && this.col > 0) valid = true; 
            if (dRow === 0 && dCol === 1 && this.col < this.row) valid = true; 
            if (dRow === 0 && dCol === -1 && this.col > 0) valid = true; 
            if (dRow === 1 && dCol === 0) valid = true; 
        }

        if (valid) {
            this.row = nextRow; this.col = nextCol;
            const targetPos = g2s(this.row, this.col);
            this.targetX = targetPos.x;
            this.targetY = targetPos.y - 25;
            
            // Store start pos for arc
            this.startX = this.x;
            this.startY = this.y;

            this.isJumping = true;
            this.jumpProgress = 0;
            AudioSys.playJump();
        } else {
            this.die(true);
        }
    }

    update() {
        if (this.dead) {
            this.y += 6; 
            this.scale *= 0.95;
            if (this.y > HEIGHT + 50) Game.loseLife();
            return;
        }

        // Input Handling
        let dRow = 0, dCol = 0;
        if (keys.ArrowUp) dRow = -1;
        else if (keys.ArrowDown) dRow = 1;
        
        if (keys.ArrowLeft) dCol = -1;
        else if (keys.ArrowRight) dCol = 1;

        // Map arrows to grid moves
        // Up+Left -> (-1, 0)
        // Up+Right -> (0, 1)
        // Down+Left -> (0, -1)
        // Down+Right -> (1, 0)
        
        if (!this.isJumping && (dRow !== 0 || dCol !== 0)) {
            let moveR = 0, moveC = 0;
            if (dRow === -1 && dCol === 0) { moveR = -1; moveC = 0; this.facingRight = false; }
            else if (dRow === 0 && dCol === 1) { moveR = 0; moveC = 1; this.facingRight = true; }
            else if (dRow === 0 && dCol === -1) { moveR = 0; moveC = -1; this.facingRight = false; }
            else if (dRow === 1 && dCol === 0) { moveR = 1; moveC = 0; this.facingRight = true; }
            
            if(moveR !== 0 || moveC !== 0) this.jump(moveR, moveC);
        }

        // Jump Animation
        if (this.isJumping) {
            this.jumpProgress += 0.08;
            const t = this.jumpProgress;
            
            // Linear X interp
            this.x = this.startX + (this.targetX - this.startX) * t;
            
            // Parabolic Y arc
            const jumpHeight = 70;
            const arc = Math.sin(t * Math.PI) * jumpHeight;
            this.y = this.startY + (this.targetY - this.startY) * t - arc;

            if (t >= 1.0) {
                this.isJumping = false;
                this.x = this.targetX; this.y = this.targetY;
                
                const tile = Game.pyramid.getTile(this.row, this.col);
                if (tile && !tile.changed) {
                    tile.changed = true;
                    AudioSys.playChange();
                    for(let i=0; i<15; i++) Game.particles.push(new Particle(this.x, this.y - 20, COLORS.tileTop2));
                } else {
                    AudioSys.playLand();
                }
                Game.pyramid.checkComplete();
            }
        }
    }

    die(fromFall) {
        if (this.dead) return;
        this.dead = true; this.isJumping = false;
        AudioSys.playDie();
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale * (this.facingRight ? 1 : -1), this.scale);

        // Shadow
        if (!this.dead) {
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.ellipse(0, 10, 15, 5, 0, 0, Math.PI*2); ctx.fill();
        }

        // Body
        ctx.fillStyle = COLORS.qbertBody;
        ctx.beginPath(); ctx.ellipse(0, -15, 18, 20, 0, 0, Math.PI*2); ctx.fill();

        // Eyes
        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(-6, -22, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6, -22, 3, 0, Math.PI*2); ctx.fill();
        
        // Eye whites
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(-5, -23, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(7, -23, 1.5, 0, Math.PI*2); ctx.fill();

        // Snout
        ctx.fillStyle = COLORS.qbertNose;
        ctx.beginPath();
        ctx.moveTo(-8, -10); ctx.lineTo(8, -10);
        ctx.lineTo(12, -5); ctx.lineTo(0, 0); ctx.lineTo(-12, -5); ctx.closePath();
        ctx.fill();

        // Legs
        ctx.beginPath(); ctx.arc(-10, 0, 6, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(10, 0, 6, 0, Math.PI*2); ctx.fill();

        ctx.restore();
    }
}

class Enemy {
    constructor(type) {
        this.type = type;
        this.reset();
    }

    reset() {
        this.active = false; this.row = -1; this.col = -1;
        this.x = 0; this.y = 0; this.targetX = 0; this.targetY = 0;
        this.isJumping = false; this.jumpProgress = 0;
    }

    spawn() {
        if (this.active) return;
        
        // Spawn Logic
        if (this.type === 'slick' || this.type === 'sam') {
            this.row = 0; 
            this.col = Math.random() > 0.5 ? 0 : 1;
            const pos = g2s(this.row, this.col);
            this.x = pos.x; this.y = pos.y - 25;
            this.active = true;
        } else if (this.type === 'ugg') {
            this.row = PYRAMID_ROWS - 1; this.col = 0;
            const pos = g2s(this.row, this.col);
            this.x = pos.x; this.y = pos.y - 25;
            this.active = true;
        } else if (this.type === 'wrongway') {
            this.row = PYRAMID_ROWS - 1; this.col = this.row;
            const pos = g2s(this.row, this.col);
            this.x = pos.x; this.y = pos.y - 25;
            this.active = true;
        } else if (this.type === 'coily') {
            this.row = 0; this.col = Math.random() > 0.5 ? 0 : 1;
            const pos = g2s(this.row, this.col);
            this.x = pos.x; this.y = pos.y - 25;
            this.active = true;
        }
    }

    update() {
        if (!this.active) return;

        // --- Slick/Sam Logic ---
        if (this.type === 'slick' || this.type === 'sam') {
            const speed = 0.06 + (Game.level * 0.005);
            
            if (!this.isJumping) {
                // Find closest tile
                let closest = null;
                let minD = Infinity;
                
                // Safety check for pyramid existence
                if(Game.pyramid && Game.pyramid.tiles.length > 0) {
                    Game.pyramid.tiles.forEach(t => {
                        const d = Math.hypot(t.x - this.x, (t.y-25) - this.y);
                        if(d < minD) { minD = d; closest = t; }
                    });
                }

                // If no tile found or we are at the edge (row == col), fall
                if (!closest || closest.row === closest.col) {
                    this.y += 8;
                    if(this.y > HEIGHT + 50) this.active = false;
                    return;
                }

                const r = closest.row;
                const c = closest.col; // FIX: Ensure 'c' is defined here
                
                // Move diagonally down-right (r+1, c+1)
                const nextR = r + 1;
                const nextC = c + 1;

                if(nextR < PYRAMID_ROWS && nextC <= nextR) {
                    const targetPos = g2s(nextR, nextC);
                    this.targetX = targetPos.x;
                    this.targetY = targetPos.y - 25;
                    this.isJumping = true;
                    this.jumpProgress = 0;
                } else {
                     // Fall off
                     this.y += 8;
                     if(this.y > HEIGHT + 50) this.active = false;
                }
            } else {
                this.jumpProgress += speed;
                const t = this.jumpProgress;
                
                // Update internal row/col at midpoint of jump
                if (t > 0.5 && !this.stepped) {
                    this.row++; this.col++;
                    this.stepped = true;
                }

                if(t >= 1) {
                    this.isJumping = false; this.x = this.targetX; this.y = this.targetY;
                    // Check bounds
                    if(this.row === PYRAMID_ROWS - 1 && this.col === PYRAMID_ROWS - 1) {
                        this.active = false; 
                    }
                } else {
                    const startPos = g2s(this.row, this.col); // Use current row for start
                    // Note: This is an approximation. Ideally we store start pos.
                    // For simplicity in this rewrite, we lerp from last known target or similar.
                    // Let's just use the stored target logic:
                    
                    // Re-calc start based on previous step? 
                    // Actually, let's just interpolate between current visual and target
                    const startX = g2s(this.row - (this.stepped?1:0), this.col - (this.stepped?1:0)).x;
                    const startY = g2s(this.row - (this.stepped?1:0), this.col - (this.stepped?1:0)).y - 25;

                    // Better approach for smooth jump:
                    // We need to store 'startX' and 'startY' when jump starts.
                }
            }
            
            // Simplified Jump Physics for Enemies
            if(this.isJumping) {
                 const startX = g2s(this.row, this.col).x;
                 const startY = g2s(this.row, this.col).y - 25;
                 
                 this.x = startX + (this.targetX - startX) * t;
                 const arc = Math.sin(t * Math.PI) * 30;
                 this.y = startY + (this.targetY - startY) * t - arc;
            }
        }

        // --- Ugg / Wrongway Logic ---
        else if (['ugg', 'wrongway'].includes(this.type)) {
             const speed = 0.04 + (Game.level * 0.005);
             
             if(!this.isJumping) {
                 let nextC = this.col;
                 if(this.type === 'ugg') nextC++;
                 else nextC--;
                 
                 // Check bounds
                 if(nextC >= 0 && nextC <= this.row) {
                     const targetPos = g2s(this.row, nextC);
                     this.targetX = targetPos.x; this.targetY = targetPos.y - 25;
                     this.isJumping = true; this.jumpProgress = 0;
                 } else {
                     // Fall
                     this.y += 5; if(this.y > HEIGHT) this.active = false;
                 }
             } else {
                 this.jumpProgress += speed;
                 const t = this.jumpProgress;
                 const startX = g2s(this.row, this.col).x;
                 const startY = g2s(this.row, this.col).y - 25;
                 
                 if(t >= 1) {
                     this.isJumping = false; 
                     this.x = this.targetX; this.y = this.targetY;
                     if(this.type === 'ugg') this.col++;
                     else this.col--;
                     
                     // Fall check again
                     if((this.type === 'ugg' && this.col > this.row) || (this.type === 'wrongway' && this.col < 0)) {
                         this.active = false; 
                     }
                 } else {
                     this.x = startX + (this.targetX - startX) * t;
                     const arc = Math.sin(t * Math.PI) * 20;
                     this.y = startY + (this.targetY - startY) * t - arc;
                 }
             }
        }

        // --- Coily Logic ---
        else if (this.type === 'coily') {
            const speed = 0.05;
            
            if(!this.isJumping) {
                // AI: Move towards Qbert
                const dRow = Game.qbert.row - this.row;
                const dCol = Game.qbert.col - this.col;
                
                let moveR = 0, moveC = 0;
                if(Math.abs(dRow) > Math.abs(dCol)) moveR = dRow > 0 ? 1 : -1;
                else moveC = dCol > 0 ? 1 : -1;

                // Validate
                let valid = false;
                if(moveR === -1 && this.col > 0) valid = true;
                if(moveR === 1) valid = true;
                if(moveC === 1 && this.col < this.row) valid = true;
                if(moveC === -1 && this.col > 0) valid = true;

                if(valid) {
                    const nextR = this.row + moveR;
                    const nextC = this.col + moveC;
                    
                    // Check fall
                    if(nextR >= PYRAMID_ROWS || nextC < 0 || nextC > nextR) {
                        this.active = false; return;
                    }
                    
                    const targetPos = g2s(nextR, nextC);
                    this.targetX = targetPos.x; this.targetY = targetPos.y - 25;
                    this.isJumping = true; this.jumpProgress = 0;
                }
            } else {
                this.jumpProgress += speed;
                const t = this.jumpProgress;
                
                if(t > 0.5 && !this.stepped) {
                     // Determine grid pos
                     const dists = [];
                     [[1,0], [0,1], [-1,0], [0,-1]].forEach(m => {
                         const tr = this.row + m[0];
                         const tc = this.col + m[1];
                         if(tr>=0 && tr<PYRAMID_ROWS && tc>=0 && tc<=tr) {
                             const p = g2s(tr, tc);
                             const d = Math.hypot(p.x - this.targetX, p.y - 25 - this.targetY);
                             dists.push({r: tr, c: tc, d: d});
                         }
                     });
                     if(dists.length > 0) {
                         dists.sort((a,b) => a.d - b.d);
                         this.row = dists[0].r; this.col = dists[0].c;
                     }
                     this.stepped = true;
                }

                const startX = g2s(this.row, this.col).x;
                const startY = g2s(this.row, this.col).y - 25;

                if(t >= 1) {
                    this.isJumping = false; this.x = this.targetX; this.y = this.targetY;
                    // Fall check
                    if(this.row >= PYRAMID_ROWS || this.col < 0 || this.col > this.row) this.active = false;
                } else {
                    this.x = startX + (this.targetX - startX) * t;
                    const arc = Math.sin(t * Math.PI) * 40;
                    this.y = startY + (this.targetY - startY) * t - arc;
                }
            }
        }

        // Collision
        if(!Game.qbert.dead && !this.dead) {
             const dist = Math.hypot(this.x - Game.qbert.x, (this.y-20) - (Game.qbert.y));
             if(dist < 30) Game.qbert.die();
        }
    }

    draw(ctx) {
        if(!this.active) return;
        ctx.save(); ctx.translate(this.x, this.y);
        
        if(['slick', 'sam'].includes(this.type)) {
            ctx.fillStyle = COLORS.slickSam;
            ctx.beginPath(); ctx.arc(0, -10, 12, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#ccffcc'; ctx.beginPath(); ctx.arc(-4, -14, 3, 0, Math.PI*2); ctx.fill();
        } else if(['ugg', 'wrongway'].includes(this.type)) {
             ctx.fillStyle = COLORS.uggWrongway;
             ctx.beginPath(); ctx.moveTo(-10, -5); ctx.bezierCurveTo(-15, -20, 15, -20, 10, -5);
             ctx.lineTo(12, 0); ctx.lineTo(-12, 0); ctx.fill();
        } else if(this.type === 'coily') {
            ctx.strokeStyle = COLORS.coily; ctx.lineWidth = 6;
            ctx.beginPath(); ctx.moveTo(0, -30); ctx.bezierCurveTo(-10, -20, 10, -10, 0, 0); ctx.stroke();
            ctx.fillStyle = COLORS.coily; ctx.beginPath(); ctx.arc(0, -30, 8, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(-3, -32, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(3, -32, 2, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

// --- GAME CONTROLLER ---
const Game = {
    state: 'MENU', level: 1, score: 0, lives: 3,
    pyramid: null, qbert: null, enemies: [], particles: [],
    
    init: function() {
        this.pyramid = new Pyramid();
        this.qbert = new Qbert();
        
        const types = ['slick', 'sam', 'ugg', 'wrongway', 'coily'];
        this.enemies = [];
        for(let i=0; i<8; i++) this.enemies.push(new Enemy(types[i % 5]));
        
        requestAnimationFrame(this.loop.bind(this));
    },
    
    startLevel: function() {
        this.pyramid = new Pyramid();
        this.qbert.reset();
        this.particles = [];
        this.enemies.forEach(e => e.reset());
        this.state = 'PLAYING';
        
        // Spawner
        setInterval(() => {
            if(this.state !== 'PLAYING') return;
            
            const available = this.enemies.filter(e => !e.active);
            if(available.length > 0) {
                let typesAllowed = ['slick', 'sam'];
                if(this.level >= 2) typesAllowed.push('ugg', 'wrongway');
                if(this.level >= 3) typesAllowed.push('coily');
                
                const type = typesAllowed[Math.floor(Math.random() * typesAllowed.length)];
                const enemy = this.enemies.find(en => en.type === type && !en.active);
                if(enemy) enemy.spawn();
            }
        }, 3000 / (1 + this.level * 0.2));
    },
    
    update: function() {
        if(this.state !== 'PLAYING') return;
        
        this.qbert.update();
        this.enemies.forEach(e => e.update());
        this.particles.forEach((p, i) => { p.update(); if(p.life <= 0) this.particles.splice(i, 1); });
    },
    
    draw: function() {
        // Background Gradient
        const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
        grad.addColorStop(0, COLORS.bgTop);
        grad.addColorStop(1, COLORS.bgBottom);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // Stars
        ctx.fillStyle = 'white';
        for(let i=0; i<50; i++) {
            const x = (Math.sin(i * 132) * WIDTH + Date.now() * 0.01) % WIDTH;
            const y = (Math.cos(i * 453) * HEIGHT);
            ctx.fillRect(Math.abs(x), Math.abs(y), 2, 2);
        }

        if(this.state === 'PLAYING' || this.state === 'GAMEOVER') {
            this.pyramid.draw(ctx);
            this.enemies.forEach(e => e.draw(ctx));
            this.qbert.draw(ctx);
            this.particles.forEach(p => p.draw(ctx));
        }
    },
    
    loop: function() { this.update(); this.draw(); requestAnimationFrame(this.loop.bind(this)); },
    
    levelComplete: function() {
        AudioSys.playBonus();
        this.score += 1000 * this.level;
        document.getElementById('score').innerText = this.score;
        this.level++;
        document.getElementById('level').innerText = this.level;
        
        setTimeout(() => this.startLevel(), 2000);
    },
    
    loseLife: function() {
        this.lives--;
        document.getElementById('lives').innerText = Math.max(0, this.lives);
        if(this.lives < 0) {
            this.state = 'GAMEOVER';
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('final-score').innerText = this.score;
        } else {
            this.qbert.reset();
            this.enemies.forEach(e => e.active = false);
        }
    }
};

// --- UI ---
document.getElementById('start-screen').addEventListener('click', () => {
    AudioSys.init();
    document.getElementById('start-screen').style.display = 'none';
    Game.startLevel();
});

Game.init();

</script>
</body>
</html>