<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man - Classic Arcade</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        .game-container {
            text-align: center;
        }
        
        canvas {
            border: 3px solid #0066FF;
            background: #000;
            box-shadow: 0 0 30px rgba(0, 102, 255, 0.5);
        }
        
        .controls {
            color: #FFFF00;
            margin-top: 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="640" height="720"></canvas>
        <div class="controls">
            Use ARROW KEYS or WASD to move | SPACE to start/pause
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const TILE_SIZE = 20;
        const MAZE_WIDTH = 28;
        const MAZE_HEIGHT = 31;
        const CANVAS_WIDTH = MAZE_WIDTH * TILE_SIZE;
        const CANVAS_HEIGHT = MAZE_HEIGHT * TILE_SIZE;

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Game State
        let gameState = 'menu'; // menu, playing, paused, gameOver
        let score = 0;
        let lives = 3;
        let level = 1;
        let dotsEaten = 0;
        let totalDots = 240;

        // Pac-Man Properties
        const pacman = {
            x: 0,
            y: 0,
            direction: { x: 0, y: 0 },
            nextDirection: { x: 0, y: 0 },
            mouthAngle: 0,
            mouthSpeed: 0.3,
            speed: 2,
            radius: 8
        };

        // Ghost Properties
        const ghosts = [
            {
                name: 'blinky',
                color: '#FF0000',
                x: 0, y: 0,
                direction: { x: -1, y: 0 },
                speed: 1.5,
                mode: 'chase', // chase, scatter, frightened, eaten
                targetX: 0, targetY: 0,
                radius: 8,
                eyesOnly: false
            },
            {
                name: 'pinky',
                color: '#FFB8FF',
                x: 0, y: 0,
                direction: { x: -1, y: 0 },
                speed: 1.5,
                mode: 'chase',
                targetX: 0, targetY: 0,
                radius: 8,
                eyesOnly: false
            },
            {
                name: 'inky',
                color: '#00FFFF',
                x: 0, y: 0,
                direction: { x: -1, y: 0 },
                speed: 1.5,
                mode: 'chase',
                targetX: 0, targetY: 0,
                radius: 8,
                eyesOnly: false
            },
            {
                name: 'clyde',
                color: '#FFB852',
                x: 0, y: 0,
                direction: { x: -1, y: 0 },
                speed: 1.5,
                mode: 'chase',
                targetX: 0, targetY: 0,
                radius: 8,
                eyesOnly: false
            }
        ];

        // Power pellet properties
        let powerPelletTimer = 0;
        const POWER_PELLET_DURATION = 6000; // 6 seconds

        // Fruit properties
        let fruitActive = false;
        let fruitX = 0, fruitY = 0;
        let fruitType = 0;
        let fruitTimer = 0;

        // Maze Layout (Classic Pac-Man map)
        const mazeLayout = [
            "############################",
            "#............##............#",
            "#.####.#####.##.#####.####.#",
            "#*####.#####.##.#####.####*#",
            "#.####.#####.##.#####.####.#",
            "#..........................#",
            "#.####.##.########.##.####.#",
            "#.####.##.########.##.####.#",
            "#......##....##....##......#",
            "######.##### ## #####.######",
            "######.##### ## #####.######",
            "######.##          ##.######",
            "######.## ###--### ##.######",
            "######.## #      # ##.######",
            ".......... #      # ........",
            "######.## #      # ##.######",
            "######.## ######## ##.######",
            "######.##          ##.######",
            "######.## ######## ##.######",
            "#............##............#",
            "#.####.#####.##.#####.####.#",
            "#*..##................##..*#",
            "###.##.##.########.##.##.###",
            "###.##.##.########.##.##.###",
            "#......##....##....##......#",
            "#.##########.##.##########.#",
            "#.##########.##.##########.#",
            "#..........................#",
            "#.####.#####.##.#####.####.#",
            "#..........................#",
            "############################"
        ];

        // Initialize game
        function initGame() {
            createMaze();
            resetPacman();
            resetGhosts();
            gameState = 'playing';
        }

        function createMaze() {
            // Create maze data structure
            window.maze = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                window.maze[y] = [];
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const char = mazeLayout[y][x];
                    let cellType = 'empty';
                    
                    if (char === '#') cellType = 'wall';
                    else if (char === '.') cellType = 'dot';
                    else if (char === '*') cellType = 'powerPellet';
                    else if (char === '-') cellType = 'ghostDoor';
                    
                    window.maze[y][x] = {
                        type: cellType,
                        x: x * TILE_SIZE + TILE_SIZE / 2,
                        y: y * TILE_SIZE + TILE_SIZE / 2
                    };
                }
            }

            // Count total dots
            let dotCount = 0;
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (window.maze[y][x].type === 'dot' || window.maze[y][x].type === 'powerPellet') {
                        dotCount++;
                    }
                }
            }
            totalDots = dotCount;
        }

        function resetPacman() {
            pacman.x = 14 * TILE_SIZE + TILE_SIZE / 2; // Center start
            pacman.y = 21 * TILE_SIZE + TILE_SIZE / 2;
            pacman.direction = { x: -1, y: 0 };
            pacman.nextDirection = { x: -1, y: 0 };
        }

        function resetGhosts() {
            const ghostStartX = 14 * TILE_SIZE + TILE_SIZE / 2;
            const ghostStartY = 15 * TILE_SIZE + TILE_SIZE / 2;

            ghosts[0].x = ghostStartX; // Blinky
            ghosts[0].y = ghostStartY - 20;
            
            ghosts[1].x = ghostStartX - 20; // Pinky
            ghosts[1].y = ghostStartY;
            
            ghosts[2].x = ghostStartX + 20; // Inky
            ghosts[2].y = ghostStartY;
            
            ghosts[3].x = ghostStartX; // Clyde
            ghosts[3].y = ghostStartY + 20;

            ghosts.forEach(ghost => {
                ghost.direction = { x: -1, y: 0 };
                ghost.mode = 'chase';
                ghost.eyesOnly = false;
            });
        }

        // Input handling
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === ' ') {
                e.preventDefault();
                if (gameState === 'menu' || gameState === 'paused') {
                    initGame();
                } else if (gameState === 'playing') {
                    gameState = 'paused';
                } else if (gameState === 'paused') {
                    gameState = 'playing';
                }
            }

            // Pac-Man movement
            if (gameState === 'playing') {
                switch(e.key) {
                    case 'ArrowLeft':
                    case 'a':
                        pacman.nextDirection = { x: -1, y: 0 };
                        break;
                    case 'ArrowRight':
                    case 'd':
                        pacman.nextDirection = { x: 1, y: 0 };
                        break;
                    case 'ArrowUp':
                    case 'w':
                        pacman.nextDirection = { x: 0, y: -1 };
                        break;
                    case 'ArrowDown':
                    case 's':
                        pacman.nextDirection = { x: 0, y: 1 };
                        break;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Game Loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            if (gameState !== 'playing') return;

            updatePacman();
            updateGhosts();
            checkCollisions();
            updatePowerPelletTimer();
            updateFruit();
            
            // Check level completion
            if (dotsEaten >= totalDots) {
                nextLevel();
            }
        }

        function updatePacman() {
            // Update mouth animation
            pacman.mouthAngle += pacman.mouthSpeed;
            if (pacman.mouthAngle > Math.PI * 0.8) {
                pacman.mouthSpeed = -Math.abs(pacman.mouthSpeed);
            } else if (pacman.mouthAngle < 0) {
                pacman.mouthSpeed = Math.abs(pacman.mouthSpeed);
            }

            // Try to change direction
            const nextX = pacman.x + pacman.nextDirection.x * pacman.speed;
            const nextY = pacman.y + pacman.nextDirection.y * pacman.speed;
            
            if (canMoveTo(nextX, nextY)) {
                pacman.direction = { ...pacman.nextDirection };
            }

            // Move Pac-Man
            const newX = pacman.x + pacman.direction.x * pacman.speed;
            const newY = pacman.y + pacman.direction.y * pacman.speed;

            if (canMoveTo(newX, newY)) {
                pacman.x = newX;
                pacman.y = newY;
                
                // Handle screen wrapping
                if (pacman.x < 0) pacman.x = CANVAS_WIDTH - TILE_SIZE / 2;
                if (pacman.x > CANVAS_WIDTH) pacman.x = TILE_SIZE / 2;
            }

            // Eat dots
            eatDots();
        }

        function canMoveTo(x, y) {
            const gridX = Math.floor(x / TILE_SIZE);
            const gridY = Math.floor(y / TILE_SIZE);
            
            if (gridX < 0 || gridX >= MAZE_WIDTH || gridY < 0 || gridY >= MAZE_HEIGHT) {
                return true; // Allow screen wrapping
            }
            
            return window.maze[gridY][gridX].type !== 'wall';
        }

        function eatDots() {
            const gridX = Math.floor(pacman.x / TILE_SIZE);
            const gridY = Math.floor(pacman.y / TILE_SIZE);
            
            if (gridX >= 0 && gridX < MAZE_WIDTH && gridY >= 0 && gridY < MAZE_HEIGHT) {
                const cell = window.maze[gridY][gridX];
                
                if (cell.type === 'dot') {
                    cell.type = 'empty';
                    score += 10;
                    dotsEaten++;
                } else if (cell.type === 'powerPellet') {
                    cell.type = 'empty';
                    score += 50;
                    dotsEaten++;
                    activatePowerPellet();
                    
                    // Spawn fruit occasionally
                    if (Math.random() < 0.3 && !fruitActive) {
                        spawnFruit();
                    }
                }
            }
        }

        function activatePowerPellet() {
            powerPelletTimer = POWER_PELLET_DURATION;
            
            ghosts.forEach(ghost => {
                if (!ghost.eyesOnly) {
                    ghost.mode = 'frightened';
                }
            });
        }

        function updatePowerPelletTimer() {
            if (powerPelletTimer > 0) {
                powerPelletTimer--;
                
                if (powerPelletTimer <= 0) {
                    ghosts.forEach(ghost => {
                        if (!ghost.eyesOnly && ghost.mode === 'frightened') {
                            ghost.mode = 'chase';
                        }
                    });
                }
            }
        }

        function spawnFruit() {
            fruitActive = true;
            fruitX = 14 * TILE_SIZE + TILE_SIZE / 2; // Center of maze
            fruitY = 17 * TILE_SIZE + TILE_SIZE / 2;
            fruitType = Math.floor(Math.random() * 5);
            fruitTimer = 600; // 10 seconds at 60fps
        }

        function updateFruit() {
            if (fruitActive) {
                fruitTimer--;
                
                if (fruitTimer <= 0) {
                    fruitActive = false;
                }
            }
        }

        function updateGhosts() {
            ghosts.forEach(ghost => {
                if (!ghost.eyesOnly) {
                    updateGhostAI(ghost);
                    moveGhost(ghost);
                } else {
                    // Eyes returning to ghost house
                    const targetX = 14 * TILE_SIZE + TILE_SIZE / 2;
                    const targetY = 15 * TILE_SIZE + TILE_SIZE / 2;
                    
                    if (Math.abs(ghost.x - targetX) < 5 && Math.abs(ghost.y - targetY) < 5) {
                        ghost.eyesOnly = false;
                        ghost.mode = 'chase';
                    }
                }
            });
        }

        function updateGhostAI(ghost) {
            // Different AI behaviors for each ghost
            switch(ghost.name) {
                case 'blinky': // Red - Direct chase
                    targetPacman(ghost);
                    break;
                    
                case 'pinky': // Pink - Ambush (target 4 tiles ahead)
                    const aheadX = pacman.x + pacman.direction.x * TILE_SIZE * 4;
                    const aheadY = pacman.y + pacman.direction.y * TILE_SIZE * 4;
                    ghost.targetX = aheadX;
                    ghost.targetY = aheadY;
                    break;
                    
                case 'inky': // Cyan - Flank (complex behavior)
                    if (powerPelletTimer > 0) {
                        targetPacman(ghost);
                    } else {
                        const blinky = ghosts[0];
                        const vectorX = pacman.x - blinky.x;
                        const vectorY = pacman.y - blinky.y;
                        ghost.targetX = pacman.x + vectorX * 2;
                        ghost.targetY = pacman.y + vectorY * 2;
                    }
                    break;
                    
                case 'clyde': // Orange - Erratic (chase when far, scatter when near)
                    const distanceToPacman = Math.sqrt(
                        Math.pow(ghost.x - pacman.x, 2) + Math.pow(ghost.y - pacman.y, 2)
                    );
                    
                    if (distanceToPacman > TILE_SIZE * 8) {
                        targetPacman(ghost);
                    } else {
                        // Scatter to corner
                        ghost.targetX = TILE_SIZE;
                        ghost.targetY = CANVAS_HEIGHT - TILE_SIZE;
                    }
                    break;
            }

            // Frightened mode behavior
            if (ghost.mode === 'frightened') {
                const randomDirections = [
                    { x: 1, y: 0 }, { x: -1, y: 0 },
                    { x: 0, y: 1 }, { x: 0, y: -1 }
                ];
                
                // Occasionally change direction randomly
                if (Math.random() < 0.02) {
                    const randomDir = randomDirections[Math.floor(Math.random() * 4)];
                    ghost.direction = randomDir;
                }
            }
        }

        function targetPacman(ghost) {
            ghost.targetX = pacman.x;
            ghost.targetY = pacman.y;
        }

        function moveGhost(ghost) {
            const speed = ghost.mode === 'frightened' ? 1 : ghost.speed;
            
            // Simple movement towards target
            let dx = ghost.targetX - ghost.x;
            let dy = ghost.targetY - ghost.y;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                ghost.direction.x = dx > 0 ? 1 : -1;
                ghost.direction.y = 0;
            } else {
                ghost.direction.x = 0;
                ghost.direction.y = dy > 0 ? 1 : -1;
            }

            const newX = ghost.x + ghost.direction.x * speed;
            const newY = ghost.y + ghost.direction.y * speed;

            if (canMoveTo(newX, newY)) {
                ghost.x = newX;
                ghost.y = newY;
                
                // Handle screen wrapping
                if (ghost.x < 0) ghost.x = CANVAS_WIDTH - TILE_SIZE / 2;
                if (ghost.x > CANVAS_WIDTH) ghost.x = TILE_SIZE / 2;
            }
        }

        function checkCollisions() {
            ghosts.forEach(ghost => {
                const distance = Math.sqrt(
                    Math.pow(pacman.x - ghost.x, 2) + Math.pow(pacman.y - ghost.y, 2)
                );
                
                if (distance < TILE_SIZE / 2) {
                    if (ghost.mode === 'frightened' && !ghost.eyesOnly) {
                        // Eat ghost
                        ghost.eyesOnly = true;
                        score += 200 * Math.pow(2, ghosts.filter(g => g.eyesOnly).length - 1);
                    } else if (!ghost.eyesOnly) {
                        // Pac-Man dies
                        loseLife();
                    }
                }
            });

            // Eat fruit
            if (fruitActive) {
                const distance = Math.sqrt(
                    Math.pow(pacman.x - fruitX, 2) + Math.pow(pacman.y - fruitY, 2)
                );
                
                if (distance < TILE_SIZE / 2) {
                    score += [100, 300, 500, 700, 1000][fruitType];
                    fruitActive = false;
                }
            }
        }

        function loseLife() {
            lives--;
            
            if (lives <= 0) {
                gameState = 'gameOver';
            } else {
                resetPacman();
                resetGhosts();
                powerPelletTimer = 0;
                fruitActive = false;
            }
        }

        function nextLevel() {
            level++;
            dotsEaten = 0;
            
            // Increase difficulty
            ghosts.forEach(ghost => {
                ghost.speed += 0.1;
            });
            
            resetPacman();
            resetGhosts();
            powerPelletTimer = 0;
            fruitActive = false;
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (gameState === 'menu') {
                drawMenu();
            } else if (gameState === 'playing' || gameState === 'paused') {
                drawMaze();
                drawDotsAndPellets();
                drawFruit();
                drawPacman();
                drawGhosts();
                drawUI();
                
                if (gameState === 'paused') {
                    drawPauseScreen();
                }
            } else if (gameState === 'gameOver') {
                drawGameOver();
            }
        }

        function drawMenu() {
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('PAC-MAN', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 50);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '24px Courier New';
            ctx.fillText('Press SPACE to Start', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            
            // Draw classic Pac-Man and ghosts preview
            drawPacmanAt(CANVAS_WIDTH / 2 - 60, CANVAS_HEIGHT / 2 + 80, { x: 1, y: 0 });
            drawGhostPreview(CANVAS_WIDTH / 2 + 40, CANVAS_HEIGHT / 2 + 80);
        }

        function drawMaze() {
            ctx.strokeStyle = '#0066FF';
            ctx.lineWidth = 3;
            
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const cell = window.maze[y][x];
                    
                    if (cell.type === 'wall') {
                        ctx.strokeRect(
                            x * TILE_SIZE + 1,
                            y * TILE_SIZE + 1,
                            TILE_SIZE - 2,
                            TILE_SIZE - 2
                        );
                    }
                }
            }

            // Draw ghost house
            ctx.fillStyle = '#0066FF';
            const houseX = 12 * TILE_SIZE;
            const houseY = 14 * TILE_SIZE;
            ctx.fillRect(houseX, houseY, 4 * TILE_SIZE, 3 * TILE_SIZE);
            
            // Ghost door
            ctx.fillStyle = '#000';
            ctx.fillRect(houseX + 2 * TILE_SIZE - 5, houseY, 10, 3);
        }

        function drawDotsAndPellets() {
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const cell = window.maze[y][x];
                    
                    if (cell.type === 'dot') {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(cell.x, cell.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (cell.type === 'powerPellet') {
                        // Pulsing power pellet
                        const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(cell.x, cell.y, 4 * pulse, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawFruit() {
            if (!fruitActive) return;

            const fruitColors = ['#FF0000', '#FFA500', '#FFFF00', '#00FF00', '#FF69B4'];
            const fruitPoints = [100, 300, 500, 700, 1000];
            
            ctx.fillStyle = fruitColors[fruitType];
            ctx.beginPath();
            ctx.arc(fruitX, fruitY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Fruit stem
            ctx.strokeStyle = '#00FF00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(fruitX, fruitY - 6);
            ctx.lineTo(fruitX + 3, fruitY - 10);
            ctx.stroke();
        }

        function drawPacman() {
            drawPacmanAt(pacman.x, pacman.y, pacman.direction);
        }

        function drawPacmanAt(x, y, direction) {
            // Calculate mouth angle based on direction
            let rotation = 0;
            if (direction.x === -1) rotation = Math.PI; // Left
            else if (direction.y === -1) rotation = -Math.PI / 2; // Up
            else if (direction.y === 1) rotation = Math.PI / 2; // Down

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);

            // Pac-Man body with mouth animation
            ctx.fillStyle = '#FFFF00';
            ctx.beginPath();
            
            const startAngle = pacman.mouthAngle;
            const endAngle = Math.PI * 2 - pacman.mouthAngle;
            
            ctx.arc(0, 0, pacman.radius, startAngle, endAngle);
            ctx.lineTo(0, 0);
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-3, -5, 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawGhosts() {
            ghosts.forEach(ghost => {
                if (ghost.eyesOnly) {
                    drawGhostEyes(ghost.x, ghost.y, ghost.direction);
                } else {
                    drawGhostAt(ghost.x, ghost.y, ghost.color, ghost.mode === 'frightened', ghost.direction);
                }
            });
        }

        function drawGhostAt(x, y, color, frightened = false, direction = { x: -1, y: 0 }) {
            ctx.save();
            ctx.translate(x, y);

            let ghostColor = color;
            if (frightened) {
                const flash = Math.floor(powerPelletTimer / 1000) % 2 === 0 && powerPelletTimer < 3000;
                ghostColor = flash ? '#FFFFFF' : '#0000FF';
            }

            // Ghost body
            ctx.fillStyle = ghostColor;
            ctx.beginPath();
            
            // Head (semicircle)
            ctx.arc(0, -2, 8, Math.PI, 0);
            
            // Body sides
            ctx.lineTo(8, 6);
            
            // Wavy bottom
            for (let i = 0; i < 3; i++) {
                const waveX = 8 - (i + 1) * 5.33;
                const waveY = 6 + (i % 2 === 0 ? 3 : 0);
                ctx.lineTo(waveX, waveY);
            }
            
            ctx.lineTo(-8, 6);
            ctx.closePath();
            ctx.fill();

            // Eyes
            if (!frightened) {
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(-3, -4, 2.5, 0, Math.PI * 2);
                ctx.arc(3, -4, 2.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#0000FF';
                ctx.beginPath();
                ctx.arc(-3 + direction.x * 1, -4 + direction.y * 1, 1, 0, Math.PI * 2);
                ctx.arc(3 + direction.x * 1, -4 + direction.y * 1, 1, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawGhostEyes(x, y, direction) {
            ctx.save();
            ctx.translate(x, y);

            // White eyes
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(-3, -4, 2.5, 0, Math.PI * 2);
            ctx.arc(3, -4, 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Blue pupils
            ctx.fillStyle = '#0000FF';
            ctx.beginPath();
            ctx.arc(-3 + direction.x * 1, -4 + direction.y * 1, 1, 0, Math.PI * 2);
            ctx.arc(3 + direction.x * 1, -4 + direction.y * 1, 1, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawGhostPreview(x, y) {
            const previewColors = ['#FF0000', '#FFB8FF', '#00FFFF', '#FFB852'];
            
            for (let i = 0; i < 4; i++) {
                drawGhostAt(x + i * 25, y, previewColors[i], false, { x: -1, y: 0 });
            }
        }

        function drawUI() {
            // Score
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'left';
            ctx.fillText(`SCORE: ${score}`, 10, 25);

            // Level
            ctx.fillText(`LEVEL: ${level}`, 10, 50);

            // Lives
            for (let i = 0; i < lives; i++) {
                drawPacmanAt(500 + i * 30, 35, { x: -1, y: 0 });
            }

            // Dots remaining
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '16px Courier New';
            ctx.textAlign = 'right';
            ctx.fillText(`DOTS: ${totalDots - dotsEaten}`, CANVAS_WIDTH - 10, 25);
        }

        function drawPauseScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 36px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '18px Courier New';
            ctx.fillText('Press SPACE to continue', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 40);
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            
            ctx.fillStyle = '#FFFF00';
            ctx.font = '24px Courier New';
            ctx.fillText(`Final Score: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '18px Courier New';
            ctx.fillText('Press SPACE to restart', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 70);
        }

        // Start the game loop
        gameLoop();
    </script>
</body>
</html>