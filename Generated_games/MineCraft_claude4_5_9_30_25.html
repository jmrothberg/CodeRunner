<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MindCraft - Voxel Building Game</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
overflow: hidden;
font-family: 'Courier New', monospace;
background: #000;
}
#gameCanvas {
display: block;
width: 100%;
height: 100vh;
}
#crosshair {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 20px;
height: 20px;
pointer-events: none;
z-index: 100;
}
#crosshair::before,
#crosshair::after {
content: '';
position: absolute;
background: rgba(255, 255, 255, 0.8);
}
#crosshair::before {
width: 2px;
height: 20px;
left: 9px;
top: 0;
}
#crosshair::after {
width: 20px;
height: 2px;
left: 0;
top: 9px;
}
#ui {
position: absolute;
top: 10px;
left: 10px;
color: white;
text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
z-index: 10;
font-size: 14px;
line-height: 1.6;
}
#minimap {
position: absolute;
top: 10px;
right: 10px;
width: 200px;
height: 200px;
background: rgba(0, 0, 0, 0.7);
border: 2px solid rgba(255, 255, 255, 0.5);
z-index: 10;
}
#inventory {
position: absolute;
bottom: 20px;
left: 50%;
transform: translateX(-50%);
display: flex;
gap: 5px;
z-index: 10;
}
.inventory-slot {
width: 50px;
height: 50px;
border: 2px solid rgba(255,255,255,0.5);
background: rgba(0,0,0,0.5);
display: flex;
align-items: center;
justify-content: center;
color: white;
font-size: 12px;
text-align: center;
cursor: pointer;
transition: all 0.2s;
}
.inventory-slot.selected {
border-color: white;
background: rgba(255,255,255,0.2);
transform: scale(1.1);
}
.inventory-slot:hover {
background: rgba(255,255,255,0.3);
}
#instructions {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(0, 0, 0, 0.9);
color: white;
padding: 30px;
border-radius: 10px;
text-align: center;
z-index: 1000;
max-width: 600px;
max-height: 80vh;
overflow-y: auto;
}
#instructions h2 {
margin-bottom: 20px;
color: #4CAF50;
}
#instructions ul {
text-align: left;
margin: 20px 0;
list-style-position: inside;
}
#instructions li {
margin: 8px 0;
}
#instructions button {
margin-top: 20px;
padding: 10px 30px;
font-size: 16px;
cursor: pointer;
background: #4CAF50;
color: white;
border: none;
border-radius: 5px;
}
#instructions button:hover {
background: #45a049;
}
#instructions.hidden {
display: none;
}
</style>
</head>
<body>
<div id="crosshair"></div>
<div id="ui">
<div>FPS: <span id="fps">60</span></div>
<div>Position: <span id="position">0, 0, 0</span></div>
<div>Time: <span id="time">Day</span></div>
<div>Blocks: <span id="blockCount">0</span></div>
<div>Selected: <span id="selectedBlock">Grass</span></div>
<div>Mode: <span id="mode">Walk</span></div>
</div>
<div id="minimap">
<canvas id="minimapCanvas" width="200" height="200"></canvas>
</div>
<div id="inventory"></div>
<div id="instructions">
<h2>üéÆ MindCraft Controls</h2>
<ul>
<li><strong>Arrow Keys / WASD:</strong> Move around</li>
<li><strong>Mouse:</strong> Look around (pointer locked)</li>
<li><strong>Space:</strong> Jump</li>
<li><strong>Left Click:</strong> Break/Remove block</li>
<li><strong>Right Click:</strong> Place block</li>
<li><strong>1-9 Keys:</strong> Select block type</li>
<li><strong>E Key:</strong> Toggle fly mode</li>
<li><strong>Shift:</strong> Move down (fly mode only)</li>
<li><strong>H Key:</strong> Toggle this help screen</li>
<li><strong>K Key:</strong> Save world to browser</li>
<li><strong>L Key:</strong> Load saved world</li>
</ul>
<p style="margin-top: 20px; color: #ffeb3b;">Press H anytime to toggle help!</p>
<button onclick="startGame()">Click to Start</button>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
console.log("üéÆ MindCraft Game Initializing...");

// ============================================
// GAME CONFIGURATION
// ============================================
const CONFIG = {
renderDistance: 8,
chunkSize: 16,
worldHeight: 64,
gravity: -25,
jumpForce: 10,
moveSpeed: 5,
flySpeed: 10,
mouseSensitivity: 0.002,
reachDistance: 6
};

// ============================================
// BLOCK TYPES
// ============================================
const BLOCK_TYPES = {
AIR: 0,
GRASS: 1,
DIRT: 2,
STONE: 3,
WOOD: 4,
LEAVES: 5,
SAND: 6,
WATER: 7,
COBBLESTONE: 8,
PLANKS: 9
};

const BLOCK_DATA = {
[BLOCK_TYPES.GRASS]: { name: 'Grass', color: 0x7cb342, topColor: 0x8bc34a, sideColor: 0x6d9b33 },
[BLOCK_TYPES.DIRT]: { name: 'Dirt', color: 0x8b6f47 },
[BLOCK_TYPES.STONE]: { name: 'Stone', color: 0x808080 },
[BLOCK_TYPES.WOOD]: { name: 'Wood', color: 0x6d4c41 },
[BLOCK_TYPES.LEAVES]: { name: 'Leaves', color: 0x4caf50, transparent: true },
[BLOCK_TYPES.SAND]: { name: 'Sand', color: 0xf4a460 },
[BLOCK_TYPES.WATER]: { name: 'Water', color: 0x2196f3, transparent: true },
[BLOCK_TYPES.COBBLESTONE]: { name: 'Cobblestone', color: 0x696969 },
[BLOCK_TYPES.PLANKS]: { name: 'Planks', color: 0xdeb887 }
};

// ============================================
// NOISE FUNCTION (Perlin-like)
// ============================================
class SimplexNoise {
constructor(seed = Math.random()) {
this.seed = seed;
this.perm = this.buildPermutationTable();
}

buildPermutationTable() {
const p = [];
for (let i = 0; i < 256; i++) p[i] = i;
for (let i = 255; i > 0; i--) {
const j = Math.floor((this.seed * 9301 + i * 49297) % 233280 / 233280 * (i + 1));
[p[i], p[j]] = [p[j], p[i]];
}
return [...p, ...p];
}

fade(t) {
return t * t * t * (t * (t * 6 - 15) + 10);
}

lerp(t, a, b) {
return a + t * (b - a);
}

grad(hash, x, y) {
const h = hash & 3;
const u = h < 2 ? x : y;
const v = h < 2 ? y : x;
return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);
}

noise2D(x, y) {
const X = Math.floor(x) & 255;
const Y = Math.floor(y) & 255;
x -= Math.floor(x);
y -= Math.floor(y);
const u = this.fade(x);
const v = this.fade(y);
const a = this.perm[X] + Y;
const b = this.perm[X + 1] + Y;
return this.lerp(v,
this.lerp(u, this.grad(this.perm[a], x, y), this.grad(this.perm[b], x - 1, y)),
this.lerp(u, this.grad(this.perm[a + 1], x, y - 1), this.grad(this.perm[b + 1], x - 1, y - 1))
);
}

octaveNoise2D(x, y, octaves, persistence, scale) {
let total = 0;
let frequency = 1;
let amplitude = 1;
let maxValue = 0;
for (let i = 0; i < octaves; i++) {
total += this.noise2D(x * frequency / scale, y * frequency / scale) * amplitude;
maxValue += amplitude;
amplitude *= persistence;
frequency *= 2;
}
return total / maxValue;
}
}

// ============================================
// GAME STATE
// ============================================
class Game {
constructor() {
this.scene = null;
this.camera = null;
this.renderer = null;
this.world = null;
this.player = null;
this.controls = null;
this.raycaster = new THREE.Raycaster();
this.clock = new THREE.Clock();
this.noise = new SimplexNoise(Math.random());
this.selectedBlockType = BLOCK_TYPES.GRASS;
this.isPointerLocked = false;
this.time = 0;
this.dayLength = 120; // seconds
this.blockCount = 0;
this.flyMode = false;
this.frameCount = 0;
this.lastFpsUpdate = 0;
this.fps = 60;
}

init() {
console.log("üé¨ Initializing game scene...");
this.setupScene();
this.setupLighting();
this.setupWorld();
this.setupPlayer();
this.setupControls();
this.setupUI();
this.setupMinimap();
this.animate();
}

setupScene() {
this.scene = new THREE.Scene();
this.scene.background = new THREE.Color(0x87ceeb);
this.scene.fog = new THREE.Fog(0x87ceeb, 50, CONFIG.renderDistance * CONFIG.chunkSize);

this.camera = new THREE.PerspectiveCamera(
75,
window.innerWidth / window.innerHeight,
0.1,
1000
);

this.renderer = new THREE.WebGLRenderer({ antialias: true });
this.renderer.setSize(window.innerWidth, window.innerHeight);
this.renderer.shadowMap.enabled = true;
this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(this.renderer.domElement);

window.addEventListener('resize', () => this.onWindowResize());
console.log("‚úÖ Scene setup complete");
}

setupLighting() {
// Ambient light
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
this.scene.add(ambientLight);

// Directional light (sun)
this.sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
this.sunLight.position.set(50, 100, 50);
this.sunLight.castShadow = true;
this.sunLight.shadow.camera.left = -50;
this.sunLight.shadow.camera.right = 50;
this.sunLight.shadow.camera.top = 50;
this.sunLight.shadow.camera.bottom = -50;
this.sunLight.shadow.camera.near = 0.5;
this.sunLight.shadow.camera.far = 500;
this.sunLight.shadow.mapSize.width = 2048;
this.sunLight.shadow.mapSize.height = 2048;
this.scene.add(this.sunLight);

console.log("üí° Lighting setup complete");
}

setupWorld() {
this.world = new World(this);
this.world.generate();
console.log("üåç World generated");
}

setupPlayer() {
this.player = new Player(this);
console.log("üßë Player created");
}

setupControls() {
this.controls = new Controls(this);
console.log("üéÆ Controls initialized");
}

setupUI() {
const inventory = document.getElementById('inventory');
const blockTypes = [
BLOCK_TYPES.GRASS,
BLOCK_TYPES.DIRT,
BLOCK_TYPES.STONE,
BLOCK_TYPES.WOOD,
BLOCK_TYPES.LEAVES,
BLOCK_TYPES.SAND,
BLOCK_TYPES.WATER,
BLOCK_TYPES.COBBLESTONE,
BLOCK_TYPES.PLANKS
];

blockTypes.forEach((type, index) => {
const slot = document.createElement('div');
slot.className = 'inventory-slot';
if (index === 0) slot.classList.add('selected');
slot.innerHTML = `<div>${index + 1}<br>${BLOCK_DATA[type].name}</div>`;
slot.onclick = () => this.selectBlock(type);
slot.dataset.blockType = type;
inventory.appendChild(slot);
});

console.log("üé® UI setup complete");
}

setupMinimap() {
this.minimapCanvas = document.getElementById('minimapCanvas');
this.minimapCtx = this.minimapCanvas.getContext('2d');
console.log("üó∫Ô∏è Minimap initialized");
}

selectBlock(type) {
this.selectedBlockType = type;
document.querySelectorAll('.inventory-slot').forEach(slot => {
slot.classList.remove('selected');
if (parseInt(slot.dataset.blockType) === type) {
slot.classList.add('selected');
}
});
document.getElementById('selectedBlock').textContent = BLOCK_DATA[type].name;
console.log(`üéØ Selected block: ${BLOCK_DATA[type].name}`);
}

animate() {
requestAnimationFrame(() => this.animate());
const delta = this.clock.getDelta();

this.player.update(delta);
this.updateDayNightCycle(delta);
this.updateUI();
this.updateMinimap();

this.renderer.render(this.scene, this.camera);
}

updateDayNightCycle(delta) {
this.time += delta / this.dayLength;
if (this.time > 1) this.time = 0;

const angle = this.time * Math.PI * 2;
const sunX = Math.cos(angle) * 100;
const sunY = Math.sin(angle) * 100;
this.sunLight.position.set(sunX, sunY, 50);

// Sky color transition
const dayColor = new THREE.Color(0x87ceeb);
const nightColor = new THREE.Color(0x000033);
const sunsetColor = new THREE.Color(0xff6b35);

let skyColor;
if (this.time < 0.25 || this.time > 0.75) {
skyColor = dayColor;
} else if (this.time > 0.45 && this.time < 0.55) {
skyColor = nightColor;
} else {
const t = this.time < 0.5 ?
(this.time - 0.25) / 0.2 :
(0.75 - this.time) / 0.2;
skyColor = new THREE.Color().lerpColors(dayColor, sunsetColor, Math.sin(t * Math.PI));
}

this.scene.background = skyColor;
this.scene.fog.color = skyColor;

const intensity = Math.max(0.3, Math.sin(angle));
this.sunLight.intensity = intensity;
}

updateUI() {
// FPS calculation with proper timing
this.frameCount++;
const currentTime = performance.now();
if (currentTime >= this.lastFpsUpdate + 1000) {
this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsUpdate));
this.frameCount = 0;
this.lastFpsUpdate = currentTime;
document.getElementById('fps').textContent = this.fps;
}

const pos = this.player.position;
document.getElementById('position').textContent =
`${Math.round(pos.x)}, ${Math.round(pos.y)}, ${Math.round(pos.z)}`;

const timeOfDay = this.time < 0.5 ? 'Day' : 'Night';
document.getElementById('time').textContent = timeOfDay;

document.getElementById('blockCount').textContent = this.blockCount;
document.getElementById('mode').textContent = this.flyMode ? 'Fly' : 'Walk';
}

updateMinimap() {
const ctx = this.minimapCtx;
const size = 200;
const pixelSize = 2;
const viewRange = Math.floor(size / pixelSize / 2);

ctx.fillStyle = '#87ceeb';
ctx.fillRect(0, 0, size, size);

const px = Math.floor(this.player.position.x);
const pz = Math.floor(this.player.position.z);

for (let dx = -viewRange; dx < viewRange; dx++) {
for (let dz = -viewRange; dz < viewRange; dz++) {
const worldX = px + dx;
const worldZ = pz + dz;

let blockType = BLOCK_TYPES.AIR;
for (let y = CONFIG.worldHeight - 1; y >= 0; y--) {
const block = this.world.getBlock(worldX, y, worldZ);
if (block !== BLOCK_TYPES.AIR) {
blockType = block;
break;
}
}

if (blockType !== BLOCK_TYPES.AIR) {
const blockData = BLOCK_DATA[blockType];
const colorHex = (blockType === BLOCK_TYPES.GRASS && blockData.topColor) ?
blockData.topColor : blockData.color;
const color = new THREE.Color(colorHex);
ctx.fillStyle = `rgb(${Math.floor(color.r * 255)}, ${Math.floor(color.g * 255)}, ${Math.floor(color.b * 255)})`;

const screenX = (size / 2) + (dx * pixelSize);
const screenY = (size / 2) + (dz * pixelSize);
ctx.fillRect(screenX, screenY, pixelSize, pixelSize);
}
}
}

ctx.fillStyle = '#ff0000';
ctx.beginPath();
ctx.arc(size / 2, size / 2, 4, 0, Math.PI * 2);
ctx.fill();

ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(size / 2, size / 2);
const angle = this.player.rotation.y;
const dirLength = 12;
ctx.lineTo(
size / 2 + Math.sin(angle) * dirLength,
size / 2 + Math.cos(angle) * dirLength
);
ctx.stroke();
}

onWindowResize() {
this.camera.aspect = window.innerWidth / window.innerHeight;
this.camera.updateProjectionMatrix();
this.renderer.setSize(window.innerWidth, window.innerHeight);
}

saveWorld() {
try {
const worldData = this.world.serialize();
const playerData = {
x: this.player.position.x,
y: this.player.position.y,
z: this.player.position.z,
rotX: this.player.rotation.x,
rotY: this.player.rotation.y
};
const seed = this.noise.seed;

const jsonString = JSON.stringify(worldData);
const sizeKB = (jsonString.length / 1024).toFixed(2);

console.log(`üíæ Attempting to save ${sizeKB}KB of world data...`);
console.log(`üìä Modified chunks: ${worldData.modifiedChunks.length}`);
console.log(`üìç Player position: (${playerData.x.toFixed(2)}, ${playerData.y.toFixed(2)}, ${playerData.z.toFixed(2)})`);

// Check if we're within storage limits
if (jsonString.length > 4000000) {
alert(`‚ö†Ô∏è World too large to save (${sizeKB}KB)!\n\nTry building less or the save will be truncated.`);
console.warn("World data exceeds safe storage limit");
}

localStorage.setItem('mindcraft_world', jsonString);
localStorage.setItem('mindcraft_seed', seed.toString());
localStorage.setItem('mindcraft_player', JSON.stringify(playerData));

console.log("‚úÖ World saved successfully!");
alert(`World saved! (${sizeKB}KB)`);
} catch (e) {
console.error("‚ùå Save failed:", e);
if (e.name === 'QuotaExceededError') {
alert("‚ùå Storage quota exceeded!\n\nYour world is too large to save.");
} else {
alert("‚ùå Failed to save world: " + e.message);
}
}
}

loadWorld() {
try {
const data = localStorage.getItem('mindcraft_world');
const seedData = localStorage.getItem('mindcraft_seed');
const playerData = localStorage.getItem('mindcraft_player');

if (!data) {
alert("No saved world found!");
return;
}

console.log("üîÑ Loading world...");

// Restore seed
if (seedData) {
this.noise.seed = parseFloat(seedData);
this.noise.perm = this.noise.buildPermutationTable();
console.log(`üå± Restored world seed: ${this.noise.seed}`);
}

// Parse world data
const worldData = JSON.parse(data);
console.log(`üì¶ Loading ${worldData.modifiedChunks.length} modified chunks...`);

// Deserialize world
this.world.deserialize(worldData);

// Restore player position
if (playerData) {
const pos = JSON.parse(playerData);
this.player.position.set(pos.x, pos.y, pos.z);
if (pos.rotX !== undefined) this.player.rotation.x = pos.rotX;
if (pos.rotY !== undefined) this.player.rotation.y = pos.rotY;
this.player.velocity.set(0, 0, 0);
console.log(`üìç Restored player position: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);
}

// Update camera immediately
this.camera.position.copy(this.player.position);
this.camera.rotation.copy(this.player.rotation);

console.log("‚úÖ World loaded successfully!");
alert("World loaded successfully!");
} catch (e) {
console.error("‚ùå Load failed:", e);
alert("‚ùå Failed to load world: " + e.message);
}
}
}

// ============================================
// WORLD MANAGEMENT
// ============================================
class World {
constructor(game) {
this.game = game;
this.chunks = new Map();
this.blockMeshes = new Map();
this.modifiedChunks = new Set();
}

generate() {
console.log("üèóÔ∏è Generating world chunks...");
const startX = -CONFIG.renderDistance;
const startZ = -CONFIG.renderDistance;
const endX = CONFIG.renderDistance;
const endZ = CONFIG.renderDistance;

for (let cx = startX; cx < endX; cx++) {
for (let cz = startZ; cz < endZ; cz++) {
this.generateChunk(cx, cz);
}
}

// Generate some trees
for (let i = 0; i < 30; i++) {
const x = Math.floor(Math.random() * CONFIG.chunkSize * CONFIG.renderDistance * 2) - CONFIG.chunkSize * CONFIG.renderDistance;
const z = Math.floor(Math.random() * CONFIG.chunkSize * CONFIG.renderDistance * 2) - CONFIG.chunkSize * CONFIG.renderDistance;
const y = this.getHeightAt(x, z);
if (y > 32) {
this.generateTree(x, y, z);
}
}

console.log(`‚úÖ Generated ${this.chunks.size} chunks`);
}

generateChunk(chunkX, chunkZ) {
const key = `${chunkX},${chunkZ}`;
if (this.chunks.has(key)) return;

const chunk = new Chunk(chunkX, chunkZ);

for (let x = 0; x < CONFIG.chunkSize; x++) {
for (let z = 0; z < CONFIG.chunkSize; z++) {
const worldX = chunkX * CONFIG.chunkSize + x;
const worldZ = chunkZ * CONFIG.chunkSize + z;
const height = this.getHeightAt(worldX, worldZ);

for (let y = 0; y < CONFIG.worldHeight; y++) {
let blockType = BLOCK_TYPES.AIR;

if (y < height - 3) {
blockType = BLOCK_TYPES.STONE;
} else if (y < height - 1) {
blockType = BLOCK_TYPES.DIRT;
} else if (y === height - 1) {
blockType = height < 32 ? BLOCK_TYPES.SAND : BLOCK_TYPES.GRASS;
} else if (y < 30 && y >= height) {
blockType = BLOCK_TYPES.WATER;
}

if (blockType !== BLOCK_TYPES.AIR) {
chunk.setBlock(x, y, z, blockType);
}
}
}
}

this.chunks.set(key, chunk);
this.renderChunk(chunk);
}

getHeightAt(x, z) {
const noise1 = this.game.noise.octaveNoise2D(x, z, 4, 0.5, 50);
const noise2 = this.game.noise.octaveNoise2D(x, z, 2, 0.3, 20);
const height = Math.floor((noise1 * 0.7 + noise2 * 0.3) * 20 + 35);
return Math.max(1, Math.min(CONFIG.worldHeight - 1, height));
}

generateTree(x, y, z) {
const trunkHeight = 4 + Math.floor(Math.random() * 2);

for (let i = 0; i < trunkHeight; i++) {
this.setBlock(x, y + i, z, BLOCK_TYPES.WOOD);
}

const leafStart = y + trunkHeight - 1;
for (let dx = -2; dx <= 2; dx++) {
for (let dz = -2; dz <= 2; dz++) {
for (let dy = 0; dy < 3; dy++) {
if (Math.abs(dx) === 2 && Math.abs(dz) === 2 && dy < 2) continue;
if (dx === 0 && dz === 0 && dy === 0) continue;
this.setBlock(x + dx, leafStart + dy, z + dz, BLOCK_TYPES.LEAVES);
}
}
}

this.setBlock(x, leafStart + 3, z, BLOCK_TYPES.LEAVES);
this.setBlock(x + 1, leafStart + 3, z, BLOCK_TYPES.LEAVES);
this.setBlock(x - 1, leafStart + 3, z, BLOCK_TYPES.LEAVES);
this.setBlock(x, leafStart + 3, z + 1, BLOCK_TYPES.LEAVES);
this.setBlock(x, leafStart + 3, z - 1, BLOCK_TYPES.LEAVES);
}

renderChunk(chunk) {
const geometry = new THREE.BufferGeometry();
const vertices = [];
const colors = [];
const indices = [];
let vertexIndex = 0;

for (let x = 0; x < CONFIG.chunkSize; x++) {
for (let y = 0; y < CONFIG.worldHeight; y++) {
for (let z = 0; z < CONFIG.chunkSize; z++) {
const blockType = chunk.getBlock(x, y, z);
if (blockType === BLOCK_TYPES.AIR) continue;

const worldX = chunk.x * CONFIG.chunkSize + x;
const worldZ = chunk.z * CONFIG.chunkSize + z;

const faces = [
{ dir: [0, 1, 0], corners: [[0,1,0],[1,1,0],[1,1,1],[0,1,1]] },
{ dir: [0, -1, 0], corners: [[0,0,0],[0,0,1],[1,0,1],[1,0,0]] },
{ dir: [1, 0, 0], corners: [[1,0,0],[1,0,1],[1,1,1],[1,1,0]] },
{ dir: [-1, 0, 0], corners: [[0,0,0],[0,1,0],[0,1,1],[0,0,1]] },
{ dir: [0, 0, 1], corners: [[0,0,1],[0,1,1],[1,1,1],[1,0,1]] },
{ dir: [0, 0, -1], corners: [[0,0,0],[1,0,0],[1,1,0],[0,1,0]] }
];

faces.forEach((face, faceIndex) => {
const [dx, dy, dz] = face.dir;
const neighborType = this.getBlock(worldX + dx, y + dy, worldZ + dz);

const isTransparent = BLOCK_DATA[blockType]?.transparent;
const neighborTransparent = BLOCK_DATA[neighborType]?.transparent;

if (neighborType === BLOCK_TYPES.AIR ||
(isTransparent && neighborType !== blockType) ||
(!isTransparent && neighborTransparent && neighborType !== BLOCK_TYPES.AIR)) {

const blockData = BLOCK_DATA[blockType];
let color = blockData.color;

if (blockType === BLOCK_TYPES.GRASS) {
if (faceIndex === 0) color = blockData.topColor;
else if (faceIndex !== 1) color = blockData.sideColor;
}

const c = new THREE.Color(color);
const shade = [1, 0.5, 0.8, 0.8, 0.9, 0.9][faceIndex];
c.multiplyScalar(shade);

face.corners.forEach(corner => {
vertices.push(
worldX + corner[0],
y + corner[1],
worldZ + corner[2]
);
colors.push(c.r, c.g, c.b);
});

indices.push(
vertexIndex, vertexIndex + 1, vertexIndex + 2,
vertexIndex, vertexIndex + 2, vertexIndex + 3
);
vertexIndex += 4;
}
});
}
}
}

if (vertices.length === 0) return;

geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
geometry.setIndex(indices);
geometry.computeVertexNormals();

const material = new THREE.MeshLambertMaterial({
vertexColors: true,
side: THREE.DoubleSide
});

const mesh = new THREE.Mesh(geometry, material);
mesh.receiveShadow = true;
mesh.castShadow = true;

this.game.scene.add(mesh);

const key = `${chunk.x},${chunk.z}`;
this.blockMeshes.set(key, mesh);
}

getBlock(x, y, z) {
if (y < 0 || y >= CONFIG.worldHeight) return BLOCK_TYPES.AIR;

const chunkX = Math.floor(x / CONFIG.chunkSize);
const chunkZ = Math.floor(z / CONFIG.chunkSize);
const key = `${chunkX},${chunkZ}`;

const chunk = this.chunks.get(key);
if (!chunk) return BLOCK_TYPES.AIR;

const localX = ((x % CONFIG.chunkSize) + CONFIG.chunkSize) % CONFIG.chunkSize;
const localZ = ((z % CONFIG.chunkSize) + CONFIG.chunkSize) % CONFIG.chunkSize;

return chunk.getBlock(localX, y, localZ);
}

setBlock(x, y, z, type) {
if (y < 0 || y >= CONFIG.worldHeight) return;

const chunkX = Math.floor(x / CONFIG.chunkSize);
const chunkZ = Math.floor(z / CONFIG.chunkSize);
const key = `${chunkX},${chunkZ}`;

let chunk = this.chunks.get(key);
if (!chunk) {
chunk = new Chunk(chunkX, chunkZ);
this.chunks.set(key, chunk);
}

const localX = ((x % CONFIG.chunkSize) + CONFIG.chunkSize) % CONFIG.chunkSize;
const localZ = ((z % CONFIG.chunkSize) + CONFIG.chunkSize) % CONFIG.chunkSize;

const oldType = chunk.getBlock(localX, y, localZ);
chunk.setBlock(localX, y, localZ, type);

// Mark chunk as modified
this.modifiedChunks.add(key);

if (oldType === BLOCK_TYPES.AIR && type !== BLOCK_TYPES.AIR) {
this.game.blockCount++;
} else if (oldType !== BLOCK_TYPES.AIR && type === BLOCK_TYPES.AIR) {
this.game.blockCount--;
}

const oldMesh = this.blockMeshes.get(key);
if (oldMesh) {
this.game.scene.remove(oldMesh);
oldMesh.geometry.dispose();
oldMesh.material.dispose();
}

this.renderChunk(chunk);
}

serialize() {
const data = {
modifiedChunks: []
};

this.modifiedChunks.forEach(key => {
const chunk = this.chunks.get(key);
if (chunk) {
const compressedBlocks = [];
for (let i = 0; i < chunk.blocks.length; i++) {
if (chunk.blocks[i] !== BLOCK_TYPES.AIR) {
compressedBlocks.push([i, chunk.blocks[i]]);
}
}

if (compressedBlocks.length > 0) {
data.modifiedChunks.push({
key: key,
x: chunk.x,
z: chunk.z,
blocks: compressedBlocks
});
}
}
});

return data;
}

deserialize(data) {
console.log("üîÑ Starting world deserialization...");

// Remove all existing meshes from scene
this.blockMeshes.forEach(mesh => {
this.game.scene.remove(mesh);
mesh.geometry.dispose();
mesh.material.dispose();
});
this.blockMeshes.clear();

// Clear chunks
this.chunks.clear();
this.modifiedChunks.clear();

// Regenerate base world
console.log("üåç Regenerating base terrain...");
const startX = -CONFIG.renderDistance;
const startZ = -CONFIG.renderDistance;
const endX = CONFIG.renderDistance;
const endZ = CONFIG.renderDistance;

for (let cx = startX; cx < endX; cx++) {
for (let cz = startZ; cz < endZ; cz++) {
this.generateChunk(cx, cz);
}
}

// Apply saved modifications
if (data.modifiedChunks && data.modifiedChunks.length > 0) {
console.log(`üì¶ Applying ${data.modifiedChunks.length} modified chunks...`);

data.modifiedChunks.forEach(chunkData => {
const key = chunkData.key;
let chunk = this.chunks.get(key);

if (!chunk) {
// Create chunk if it doesn't exist
chunk = new Chunk(chunkData.x, chunkData.z);
this.chunks.set(key, chunk);
console.log(`Creating new chunk at ${key}`);
}

// Apply modifications
chunkData.blocks.forEach(([index, blockType]) => {
chunk.blocks[index] = blockType;
});

this.modifiedChunks.add(key);

// Re-render the chunk
const oldMesh = this.blockMeshes.get(key);
if (oldMesh) {
this.game.scene.remove(oldMesh);
oldMesh.geometry.dispose();
oldMesh.material.dispose();
this.blockMeshes.delete(key);
}

this.renderChunk(chunk);
console.log(`‚úÖ Rendered modified chunk ${key}`);
});
}

// Regenerate trees
for (let i = 0; i < 30; i++) {
const x = Math.floor(Math.random() * CONFIG.chunkSize * CONFIG.renderDistance * 2) - CONFIG.chunkSize * CONFIG.renderDistance;
const z = Math.floor(Math.random() * CONFIG.chunkSize * CONFIG.renderDistance * 2) - CONFIG.chunkSize * CONFIG.renderDistance;
const y = this.getHeightAt(x, z);
if (y > 32) {
this.generateTree(x, y, z);
}
}

console.log(`‚úÖ World loaded with ${this.chunks.size} chunks and ${this.blockMeshes.size} meshes`);
}
}

// ============================================
// CHUNK CLASS
// ============================================
class Chunk {
constructor(x, z) {
this.x = x;
this.z = z;
this.blocks = new Uint8Array(CONFIG.chunkSize * CONFIG.worldHeight * CONFIG.chunkSize);
}

getBlockIndex(x, y, z) {
return x + y * CONFIG.chunkSize + z * CONFIG.chunkSize * CONFIG.worldHeight;
}

getBlock(x, y, z) {
return this.blocks[this.getBlockIndex(x, y, z)] || BLOCK_TYPES.AIR;
}

setBlock(x, y, z, type) {
this.blocks[this.getBlockIndex(x, y, z)] = type;
}
}

// ============================================
// PLAYER CLASS
// ============================================
class Player {
constructor(game) {
this.game = game;
this.position = new THREE.Vector3(0, 50, 0);
this.velocity = new THREE.Vector3(0, 0, 0);
this.rotation = new THREE.Euler(0, 0, 0, 'YXZ');
this.onGround = false;
this.height = 1.8;
this.radius = 0.4;

this.game.camera.position.copy(this.position);
this.game.camera.rotation.copy(this.rotation);

this.findGround();
}

findGround() {
for (let y = CONFIG.worldHeight - 1; y >= 0; y--) {
if (this.game.world.getBlock(0, y, 0) !== BLOCK_TYPES.AIR) {
this.position.y = y + this.height + 1;
this.velocity.y = 0;
break;
}
}
}

update(delta) {
const controls = this.game.controls;
const moveSpeed = this.game.flyMode ? CONFIG.flySpeed : CONFIG.moveSpeed;

const forward = new THREE.Vector3();
const right = new THREE.Vector3();

this.game.camera.getWorldDirection(forward);
forward.y = 0;
forward.normalize();
right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

const moveDir = new THREE.Vector3();
if (controls.forward) moveDir.add(forward);
if (controls.backward) moveDir.sub(forward);
if (controls.left) moveDir.sub(right);
if (controls.right) moveDir.add(right);

if (moveDir.length() > 0) {
moveDir.normalize();
this.velocity.x = moveDir.x * moveSpeed;
this.velocity.z = moveDir.z * moveSpeed;
} else {
this.velocity.x *= 0.8;
this.velocity.z *= 0.8;
}

if (this.game.flyMode) {
this.velocity.y = 0;
if (controls.jump) this.velocity.y = moveSpeed;
if (controls.sneak) this.velocity.y = -moveSpeed;
} else {
this.velocity.y += CONFIG.gravity * delta;
if (controls.jump && this.onGround) {
this.velocity.y = CONFIG.jumpForce;
this.onGround = false;
}
}

this.applyMovement(delta);

this.game.camera.position.copy(this.position);
this.game.camera.rotation.copy(this.rotation);
}

applyMovement(delta) {
if (this.game.flyMode) {
this.position.add(this.velocity.clone().multiplyScalar(delta));
return;
}

const oldPos = this.position.clone();

this.position.x += this.velocity.x * delta;
if (this.checkCollisionAtPosition(this.position)) {
this.position.x = oldPos.x;
this.velocity.x = 0;
}

this.position.z += this.velocity.z * delta;
if (this.checkCollisionAtPosition(this.position)) {
this.position.z = oldPos.z;
this.velocity.z = 0;
}

this.position.y += this.velocity.y * delta;
const groundCheck = this.checkGroundCollision();
if (groundCheck.collision) {
this.position.y = groundCheck.y;
this.velocity.y = 0;
this.onGround = true;
} else {
this.onGround = false;
}

if (this.checkCeilingCollision()) {
this.velocity.y = Math.min(0, this.velocity.y);
}
}

checkCollisionAtPosition(pos) {
const feet = pos.y - this.height;
const head = pos.y + 0.2;

const checkPoints = [
[0, 0],
[this.radius, 0],
[-this.radius, 0],
[0, this.radius],
[0, -this.radius],
[this.radius * 0.7, this.radius * 0.7],
[this.radius * 0.7, -this.radius * 0.7],
[-this.radius * 0.7, this.radius * 0.7],
[-this.radius * 0.7, -this.radius * 0.7]
];

for (const [dx, dz] of checkPoints) {
const checkX = Math.floor(pos.x + dx);
const checkZ = Math.floor(pos.z + dz);

for (let y = Math.floor(feet); y <= Math.ceil(head); y++) {
const block = this.game.world.getBlock(checkX, y, checkZ);
if (block !== BLOCK_TYPES.AIR && block !== BLOCK_TYPES.WATER) {
return true;
}
}
}

return false;
}

checkGroundCollision() {
const feet = this.position.y - this.height;
const checkY = Math.floor(feet);

const checkPoints = [
[0, 0],
[this.radius * 0.9, 0],
[-this.radius * 0.9, 0],
[0, this.radius * 0.9],
[0, -this.radius * 0.9]
];

for (const [dx, dz] of checkPoints) {
const checkX = Math.floor(this.position.x + dx);
const checkZ = Math.floor(this.position.z + dz);

const block = this.game.world.getBlock(checkX, checkY, checkZ);
if (block !== BLOCK_TYPES.AIR && block !== BLOCK_TYPES.WATER) {
return {
collision: true,
y: checkY + 1 + this.height
};
}
}

return { collision: false };
}

checkCeilingCollision() {
const head = this.position.y + 0.2;
const checkY = Math.ceil(head);
const checkX = Math.floor(this.position.x);
const checkZ = Math.floor(this.position.z);

const block = this.game.world.getBlock(checkX, checkY, checkZ);
return block !== BLOCK_TYPES.AIR && block !== BLOCK_TYPES.WATER;
}
}

// ============================================
// CONTROLS CLASS
// ============================================
class Controls {
constructor(game) {
this.game = game;
this.forward = false;
this.backward = false;
this.left = false;
this.right = false;
this.jump = false;
this.sneak = false;

this.setupEventListeners();
}

setupEventListeners() {
document.addEventListener('keydown', (e) => this.onKeyDown(e));
document.addEventListener('keyup', (e) => this.onKeyUp(e));
document.addEventListener('mousedown', (e) => this.onMouseDown(e));
document.addEventListener('mousemove', (e) => this.onMouseMove(e));
document.addEventListener('contextmenu', (e) => e.preventDefault());

document.addEventListener('pointerlockchange', () => {
this.game.isPointerLocked = document.pointerLockElement !== null;
console.log(`üîí Pointer lock: ${this.game.isPointerLocked ? 'LOCKED' : 'UNLOCKED'}`);
});

document.addEventListener('click', (e) => {
const instructions = document.getElementById('instructions');
if (!this.game.isPointerLocked && instructions.classList.contains('hidden')) {
document.body.requestPointerLock();
}
});
}

onKeyDown(e) {
switch(e.code) {
case 'ArrowUp':
case 'KeyW':
this.forward = true;
break;
case 'ArrowDown':
case 'KeyS':
this.backward = true;
break;
case 'ArrowLeft':
case 'KeyA':
this.left = true;
break;
case 'ArrowRight':
case 'KeyD':
this.right = true;
break;
case 'Space':
this.jump = true;
break;
case 'ShiftLeft':
case 'ShiftRight':
this.sneak = true;
break;
case 'KeyE':
this.game.flyMode = !this.game.flyMode;
console.log(`‚úàÔ∏è Fly mode: ${this.game.flyMode ? 'ON' : 'OFF'}`);
break;
case 'KeyH':
this.toggleHelp();
break;
case 'KeyK':
if (!e.ctrlKey && !e.metaKey && !this.backward) {
e.preventDefault();
this.game.saveWorld();
}
break;
case 'KeyL':
if (!e.ctrlKey && !e.metaKey) {
e.preventDefault();
this.game.loadWorld();
}
break;
case 'Digit1':
case 'Digit2':
case 'Digit3':
case 'Digit4':
case 'Digit5':
case 'Digit6':
case 'Digit7':
case 'Digit8':
case 'Digit9':
const index = parseInt(e.code.replace('Digit', '')) - 1;
const blockTypes = [
BLOCK_TYPES.GRASS, BLOCK_TYPES.DIRT, BLOCK_TYPES.STONE,
BLOCK_TYPES.WOOD, BLOCK_TYPES.LEAVES, BLOCK_TYPES.SAND,
BLOCK_TYPES.WATER, BLOCK_TYPES.COBBLESTONE, BLOCK_TYPES.PLANKS
];
if (blockTypes[index]) {
this.game.selectBlock(blockTypes[index]);
}
break;
}
}

onKeyUp(e) {
switch(e.code) {
case 'ArrowUp':
case 'KeyW':
this.forward = false;
break;
case 'ArrowDown':
case 'KeyS':
this.backward = false;
break;
case 'ArrowLeft':
case 'KeyA':
this.left = false;
break;
case 'ArrowRight':
case 'KeyD':
this.right = false;
break;
case 'Space':
this.jump = false;
break;
case 'ShiftLeft':
case 'ShiftRight':
this.sneak = false;
break;
}
}

toggleHelp() {
const instructions = document.getElementById('instructions');
instructions.classList.toggle('hidden');
if (instructions.classList.contains('hidden')) {
document.body.requestPointerLock();
} else {
document.exitPointerLock();
}
}

onMouseDown(e) {
if (!this.game.isPointerLocked) return;

e.preventDefault();

const intersects = this.raycastBlocks();
if (intersects) {
if (e.button === 0) {
this.game.world.setBlock(
intersects.blockX,
intersects.blockY,
intersects.blockZ,
BLOCK_TYPES.AIR
);
} else if (e.button === 2) {
if (intersects.placeX !== undefined) {
const playerPos = this.game.player.position;
const px = Math.floor(playerPos.x);
const py = Math.floor(playerPos.y);
const pyFeet = Math.floor(playerPos.y - this.game.player.height);
const pz = Math.floor(playerPos.z);

const wouldCollide = (
intersects.placeX === px &&
(intersects.placeY === py || intersects.placeY === pyFeet) &&
intersects.placeZ === pz
);

if (!wouldCollide) {
this.game.world.setBlock(
intersects.placeX,
intersects.placeY,
intersects.placeZ,
this.game.selectedBlockType
);
}
}
}
}
}

raycastBlocks() {
const origin = this.game.camera.position.clone();
const direction = new THREE.Vector3();
this.game.camera.getWorldDirection(direction);

const maxDistance = CONFIG.reachDistance;
const step = 0.05;
let lastAirBlock = null;

for (let t = 0; t < maxDistance; t += step) {
const point = origin.clone().add(direction.clone().multiplyScalar(t));
const x = Math.floor(point.x);
const y = Math.floor(point.y);
const z = Math.floor(point.z);

const block = this.game.world.getBlock(x, y, z);

if (block !== BLOCK_TYPES.AIR && block !== BLOCK_TYPES.WATER) {
return {
blockX: x,
blockY: y,
blockZ: z,
placeX: lastAirBlock ? lastAirBlock.x : x,
placeY: lastAirBlock ? lastAirBlock.y : y,
placeZ: lastAirBlock ? lastAirBlock.z : z
};
}

lastAirBlock = { x, y, z };
}

return null;
}

onMouseMove(e) {
if (!this.game.isPointerLocked) return;

const player = this.game.player;
player.rotation.y -= e.movementX * CONFIG.mouseSensitivity;
player.rotation.x -= e.movementY * CONFIG.mouseSensitivity;
player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
}
}

// ============================================
// GAME INITIALIZATION
// ============================================
let game;

function startGame() {
const instructions = document.getElementById('instructions');
instructions.classList.add('hidden');
document.body.requestPointerLock();

if (!game) {
game = new Game();
game.init();
console.log("üéÆ Game started!");
}
}

window.addEventListener('load', () => {
console.log("üåü MindCraft loaded! Click 'Start' to begin.");
});
</script>
</body>
</html>