<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Missile Command - 1980 Arcade Tribute</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #050510;
            --ground-color: #1a1a2e;
            --terminal-green: #33ff00;
            --radar-sweep: rgba(51, 255, 0, 0.3);
            --glow-white: #ffffff;
            --explosion-core: #ffffaa;
            --ui-font: 'Press Start 2P', monospace;
        }

        body {
            background-color: var(--bg-color);
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: var(--ui-font);
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 800px; /* Base resolution */
            height: 600px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8), 0 0 50px rgba(51, 255, 0, 0.1);
            border: 2px solid #333;
            background: linear-gradient(to bottom, #000000 80%, var(--ground-color) 80%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair; /* System fallback */
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            text-shadow: 0 0 5px var(--terminal-green);
        }

        .score-box, .ammo-box {
            color: var(--terminal-green);
        }

        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border: 2px solid var(--terminal-green);
            pointer-events: auto;
            display: flex; /* Flex to toggle visibility */
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 0 30px rgba(51, 255, 0, 0.2);
            z-index: 10;
        }

        h1 {
            color: var(--terminal-green);
            font-size: 24px;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        p {
            font-size: 12px;
            line-height: 1.6;
            color: #ccc;
        }

        button {
            background: var(--ground-color);
            color: var(--terminal-green);
            border: 2px solid var(--terminal-green);
            padding: 15px 30px;
            font-family: var(--ui-font);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        button:hover {
            background: var(--terminal-green);
            color: black;
            box-shadow: 0 0 15px var(--terminal-green);
        }

        .hidden {
            display: none !important;
        }
        
        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 20;
        }

        /* Custom Cursor */
        #cursor {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: difference;
            display: none; /* Hidden if mouse used, shown for keyboard */
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="scanlines"></div>
    
    <!-- Heads Up Display -->
    <div id="ui-layer">
        <div class="hud-row">
            <div class="score-box">SCORE: <span id="scoreVal">0</span></div>
            <div class="score-box">HIGH SCORE: <span id="highScoreVal">0</span></div>
            <div class="score-box">WAVE: <span id="waveVal">1</span></div>
        </div>
        <div class="hud-row" style="align-items: flex-end;">
            <!-- Ammo bars will be drawn on canvas, but we keep text backup if needed -->
        </div>
    </div>

    <!-- Start / Game Over Screen -->
    <div id="message-overlay">
        <h1>MISSILE COMMAND</h1>
        <p>DEFEND THE CITIES FROM NUCLEAR ANNIHILATION.</p>
        <p style="color: white; font-size: 10px;">CONTROLS:<br>MOUSE to Aim & Fire<br>[LEFT] [RIGHT] + [SPACE] for Keyboard</p>
        <button id="startBtn">START GAME</button>
    </div>

    <!-- Custom Cursor Element -->
    <div id="cursor"></div>
</div>

<script>
/**
 * MISSILE COMMAND - 1980 TRIBUTE
 * 
 * Architecture:
 * - Game Loop: Manages update (logic) and draw (rendering) cycles.
 * - Entity System: Classes for Batteries, Cities, Missiles, Explosions, Particles.
 * - State Machine: Menu -> Playing -> Level Transition -> Game Over.
 * - Audio: Synthesized using Web Audio API (no external files).
 */

// --- CONSTANTS & CONFIG ---
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const GROUND_Y = 500; // Horizon line
const FPS = 60;

const COLORS = {
    WHITE: '#FFFFFF',
    ENEMY_TRAIL: '#FF3333',
    PLAYER_TRAIL: '#33FF33', // Actually usually white in original, but let's make distinct
    EXPLOSION_CORE: '#FFFFAA',
    EXPLOSION_OUTER: '#FF4400',
    CITY_ALIVE: '#33FF00',
    CITY_DEAD: '#555555',
    BATTERY: '#AAAAAA',
    RADAR_LINE: 'rgba(51, 255, 0, 0.4)'
};

// --- AUDIO SYSTEM (Web Audio API) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const SoundFX = {
    playShoot: () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        osc.type = 'square';
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
        
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    },
    
    playExplosion: (size = 1) => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const bufferSize = audioCtx.sampleRate * 0.5; // 0.5 seconds
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        // Filter to make it sound like a deep boom
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800 * size;

        const gainNode = audioCtx.createGain();
        
        noise.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        gainNode.gain.setValueAtTime(0.3 * size, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

        noise.start();
    },

    playCityDestroyed: () => {
        // More chaotic noise
        SoundFX.playExplosion(2);
    },
    
    playSmartBomb: () => {
         if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.8);
        
        gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.8);
        
        osc.start();
        osc.stop(audioCtx.currentTime + 0.8);
    }
};

// --- GAME STATE ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    state: 'MENU', // MENU, PLAYING, LEVEL_TRANSITION, GAMEOVER
    score: 0,
    highScore: localStorage.getItem('mc_highscore') || 0,
    wave: 1,
    
    // Entities
    batteries: [],
    cities: [],
    enemyMissiles: [],
    playerMissiles: [],
    explosions: [],
    particles: [],

    // Input
    mouseX: CANVAS_WIDTH / 2,
    mouseY: GROUND_Y - 50,
    activeBatteryIndex: 1, // 0=Left, 1=Center, 2=Right
    
    // Logic
    levelTimer: null,
    enemySpawnTimer: 0,
    waveActiveMissilesCount: 0,
    
    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Input Listeners
        this.canvas.addEventListener('mousemove', (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            this.mouseX = (e.clientX - rect.left) * scaleX;
            this.mouseY = (e.clientY - rect.top) * scaleY;
        });

        this.canvas.addEventListener('mousedown', () => {
            if (this.state === 'PLAYING') this.firePlayerMissile();
        });
        
        // Keyboard Cursor Support
        window.addEventListener('keydown', (e) => {
            if (this.state !== 'PLAYING') return;
            
            const speed = 15;
            switch(e.key) {
                case 'ArrowLeft': 
                    this.mouseX -= speed; 
                    break;
                case 'ArrowRight': 
                    this.mouseX += speed; 
                    break;
                case 'ArrowUp': 
                    this.mouseY -= speed; 
                    break;
                case 'ArrowDown': 
                    this.mouseY += speed; 
                    break;
                case ' ': // Spacebar
                    e.preventDefault();
                    this.firePlayerMissile();
                    break;
            }
            // Clamp
            this.mouseX = Math.max(0, Math.min(CANVAS_WIDTH, this.mouseX));
            this.mouseY = Math.max(0, Math.min(GROUND_Y, this.mouseY));
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            this.startGame();
        });
        
        // Initial Render
        this.drawBackground();
        this.updateHUD();
    },

    resize() {
        // Keep internal resolution fixed, CSS handles scaling
    },
    
    resetLevelData() {
        this.batteries = [
            new Battery(100),
            new Battery(CANVAS_WIDTH / 2),
            new Battery(CANVAS_WIDTH - 100)
        ];
        
        // Only reset cities if starting fresh game (wave 1), otherwise persist damage
        if (this.wave === 1) {
            this.cities = [];
            const spacing = CANVAS_WIDTH / 7;
            for(let i=0; i<6; i++) {
                this.cities.push(new City(spacing * (i + 1)));
            }
        }

        this.enemyMissiles = [];
        this.playerMissiles = [];
        this.explosions = [];
        this.particles = [];
        
        this.activeBatteryIndex = 1;
    },

    startGame() {
        document.getElementById('message-overlay').classList.add('hidden');
        this.score = 0;
        this.wave = 1;
        this.resetLevelData();
        this.startWave();
        this.state = 'PLAYING';
        this.loop();
    },
    
    startWave() {
        // Determine wave difficulty
        const baseMissiles = 5 + Math.floor(this.wave * 1.5);
        this.waveActiveMissilesCount = baseMissiles;
        this.enemySpawnTimer = 0;
        
        // Bonus city logic: Every few waves or score threshold (simplified to every 4 waves here)
        if (this.wave > 1 && this.wave % 4 === 0) {
            this.restoreCity();
        }
    },
    
    restoreCity() {
        const deadCity = this.cities.find(c => c.dead);
        if (deadCity) {
            deadCity.dead = false;
            // Visual flair for bonus city could go here
            console.log("Bonus city awarded!");
        }
    },

    gameOver() {
        this.state = 'GAMEOVER';
        
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('mc_highscore', this.highScore);
        }
        
        const overlay = document.getElementById('message-overlay');
        overlay.classList.remove('hidden');
        overlay.querySelector('h1').innerText = "GAME OVER";
        overlay.querySelector('p').innerHTML = `FINAL SCORE: ${this.score}<br>CITIES LEFT: ${this.cities.filter(c=>!c.dead).length}`;
        document.getElementById('startBtn').innerText = "PLAY AGAIN";
    },

    firePlayerMissile() {
        const battery = this.batteries[this.activeBatteryIndex];
        
        // If current battery is destroyed or out of ammo, switch to next available
        if (battery.destroyed || battery.ammo <= 0) {
            this.switchBattery();
            return;
        }
        
        // Fire
        battery.ammo--;
        this.playerMissiles.push(new PlayerMissile(battery.x, GROUND_Y - 20, this.mouseX, this.mouseY));
        SoundFX.playShoot();
    },
    
    switchBattery() {
        // Try to find a battery with ammo and not destroyed
        let startIndex = (this.activeBatteryIndex + 1) % 3;
        let found = false;
        
        for(let i=0; i<3; i++) {
            const idx = (startIndex + i) % 3;
            if (!this.batteries[idx].destroyed && this.batteries[idx].ammo > 0) {
                this.activeBatteryIndex = idx;
                found = true;
                break;
            }
        }
        
        // If no battery has ammo, user simply can't fire (wait for end of wave)
    },

    update() {
        if (this.state !== 'PLAYING') return;

        // 1. Spawning Enemies
        this.enemySpawnTimer++;
        // Spawn rate increases with waves
        let spawnRate = Math.max(20, 100 - (this.wave * 5)); 
        
        // Random delay based on wave difficulty
        if (this.spawnEnemyLogic()) {
            this.spawnMissile();
        }

        // 2. Update Entities
        
        // Player Missiles
        for (let i = this.playerMissiles.length - 1; i >= 0; i--) {
            const m = this.playerMissiles[i];
            m.update();
            
            if (m.reachedTarget) {
                this.createExplosion(m.x, m.y, false);
                this.playerMissiles.splice(i, 1);
            }
        }
        
        // Enemy Missiles
        let activeEnemies = 0;
        for (let i = this.enemyMissiles.length - 1; i >= 0; i--) {
            const m = this.enemyMissiles[i];
            m.update();
            
            // Check collision with explosions
            let destroyed = false;
            for (const exp of this.explosions) {
                if (!exp.exploding && !exp.dead && Math.hypot(m.x - exp.x, m.y - exp.y) < exp.currentRadius) {
                    destroyed = true;
                    break;
                }
            }
            
            if (destroyed) {
                // MIRV Logic: Split into smaller warheads
                if (m.isMIRV) {
                     this.triggerMIRVSplit(m);
                }
                
                // Score calculation based on altitude (higher is harder)
                const points = Math.floor((GROUND_Y - m.y) / 4) + 25;
                this.score += points;
                
                this.createExplosion(m.x, m.y, true); // Enemy explosion
                this.enemyMissiles.splice(i, 1);
            } else if (m.reachedTarget) {
                // Impact logic
                this.handleImpact(m);
                this.enemyMissiles.splice(i, 1);
                SoundFX.playCityDestroyed();
            } else {
                activeEnemies++;
            }
        }

        // Explosions
        for (let i = this.explosions.length - 1; i >= 0; i--) {
            const exp = this.explosions[i];
            exp.update();
            
            // Check collision with cities/batteries during expansion
            if (!exp.checkedCollisions) {
                this.checkExplosionDamage(exp);
            }

            if (exp.dead) {
                this.explosions.splice(i, 1);
            }
        }
        
        // Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }

        // Check Wave End
        if (this.waveActiveMissilesCount <= 0 && this.enemyMissiles.length === 0 && this.explosions.length === 0) {
            this.state = 'LEVEL_TRANSITION';
            setTimeout(() => {
                this.wave++;
                this.startWave();
                this.state = 'PLAYING';
            }, 2000);
        }
        
        // Check Game Over
        if (this.cities.every(c => c.dead)) {
            // Allow current explosions to finish for dramatic effect?
            // Immediate end usually feels better in arcade
             if (this.enemyMissiles.length === 0 && this.explosions.length < 2) {
                 this.gameOver();
             }
        }

        this.updateHUD();
    },

    spawnEnemyLogic() {
        if (this.waveActiveMissilesCount <= 0) return false;
        
        // Random chance based on timer and wave
        const chance = 0.02 + (this.wave * 0.005);
        if (Math.random() < chance) {
            this.waveActiveMissilesCount--;
            return true;
        }
        return false;
    },

    spawnMissile() {
        // Random Start X at top
        const startX = Math.random() * CANVAS_WIDTH;
        
        // Target Selection: Batteries or Cities
        let targets = [...this.cities.filter(c => !c.dead), ...this.batteries.filter(b => !b.destroyed)];
        if (targets.length === 0) {
            // If everything dead, aim at random ground spot
             const targetX = Math.random() * CANVAS_WIDTH;
             this.enemyMissiles.push(new EnemyMissile(startX, -10, targetX, GROUND_Y));
             return;
        }
        
        const target = targets[Math.floor(Math.random() * targets.length)];
        
        // MIRV Logic (Smart Bombs)
        let isMIRV = false;
        if (this.wave > 3 && Math.random() < 0.2) {
            isMIRV = true;
        }

        this.enemyMissiles.push(new EnemyMissile(startX, -10, target.x + (Math.random()*20-10), GROUND_Y, isMIRV));
    },

    triggerMIRVSplit(parentMissile) {
        // Split into 3 smaller missiles
        const count = 3;
        for(let i=0; i<count; i++) {
            const spreadX = parentMissile.targetX + (Math.random() * 100 - 50);
            // Ensure target is within screen
            const clampedX = Math.max(50, Math.min(CANVAS_WIDTH-50, spreadX));
            
            const mirv = new EnemyMissile(parentMissile.x, parentMissile.y, clampedX, GROUND_Y, false);
            mirv.speed *= 1.5; // Faster after split
            this.enemyMissiles.push(mirv);
            // Don't decrement wave count again, these are sub-munitions
        }
    },

    createExplosion(x, y, isEnemy) {
        this.explosions.push(new Explosion(x, y, isEnemy));
        
        if (isEnemy) {
             SoundFX.playSmartBomb(); // High pitched for explosion effect
        } else {
             SoundFX.playExplosion();
        }
    },
    
    handleImpact(missile) {
        // Create ground explosion (larger)
        this.createExplosion(missile.x, missile.y, true);
        
        // Check what was hit
        const hitDist = 30; // Radius of impact damage
        
        // Check Cities
        this.cities.forEach(c => {
            if (!c.dead && Math.abs(c.x - missile.targetX) < hitDist) {
                c.dead = true;
                // Add debris particles
                for(let k=0; k<10; k++) this.particles.push(new Particle(c.x, GROUND_Y-5, COLORS.CITY_ALIVE));
            }
        });
        
        // Check Batteries
        this.batteries.forEach(b => {
            if (!b.destroyed && Math.abs(b.x - missile.targetX) < hitDist) {
                b.destroyed = true;
                for(let k=0; k<10; k++) this.particles.push(new Particle(b.x, GROUND_Y-5, COLORS.BATTERY));
                
                // Switch away from destroyed battery
                if (this.batteries[this.activeBatteryIndex] === b) {
                    this.switchBattery();
                }
            }
        });
    },

    checkExplosionDamage(exp) {
        // Determine if explosion is expanding or contracting
        // In original, only expanding destroys things
        
        // Check Enemy Missiles inside explosion radius
        // This logic is handled in the Enemy Missile update loop for performance,
        // but we could add chain reaction logic here.
        
        exp.checkedCollisions = true;
    },

    draw() {
        this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        this.drawBackground();
        
        // Draw Batteries
        this.batteries.forEach(b => b.draw(this.ctx));
        
        // Draw Cities
        this.cities.forEach(c => c.draw(this.ctx));
        
        // Draw Enemy Missiles
        this.enemyMissiles.forEach(m => m.draw(this.ctx));
        
        // Draw Player Missiles
        this.playerMissiles.forEach(m => m.draw(this.ctx));
        
        // Draw Explosions
        this.explosions.forEach(e => e.draw(this.ctx));
        
        // Draw Particles
        this.particles.forEach(p => p.draw(this.ctx));

        // Draw Crosshair
        if (this.state === 'PLAYING' || this.state === 'LEVEL_TRANSITION') {
            this.drawCrosshair();
        }
        
        // Level transition text
        if (this.state === 'LEVEL_TRANSITION') {
            this.ctx.fillStyle = "white";
            this.ctx.font = "40px 'Press Start 2P'";
            this.ctx.textAlign = "center";
            this.ctx.fillText("WAVE " + this.wave + " COMPLETE", CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
        }
    },
    
    drawBackground() {
        // Night Sky
        const grad = this.ctx.createLinearGradient(0, 0, 0, GROUND_Y);
        grad.addColorStop(0, '#020205');
        grad.addColorStop(1, '#1a1a3a');
        this.ctx.fillStyle = grad;
        this.ctx.fillRect(0, 0, CANVAS_WIDTH, GROUND_Y);
        
        // Stars
        this.ctx.fillStyle = "white";
        for(let i=0; i<50; i++) {
            // Deterministic stars based on index to prevent flickering
            const x = (Math.sin(i * 132.1) * 43758.5453 % 1) * CANVAS_WIDTH;
            const y = (Math.cos(i * 42.5) * 1234.5 % 1) * GROUND_Y;
            const size = Math.abs(Math.sin(i)) * 2;
            this.ctx.globalAlpha = Math.abs(Math.sin(Date.now()*0.001 + i)); // Twinkle
            this.ctx.fillRect(x, y, size, size);
        }
        this.ctx.globalAlpha = 1.0;

        // Ground
        this.ctx.fillStyle = COLORS.GROUND_COLOR;
        this.ctx.fillRect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);
        
        // Radar Line (Sweeping effect)
        if (this.state === 'PLAYING') {
            const time = Date.now() * 0.0005;
            const x = (time % 1) * CANVAS_WIDTH;
            
            this.ctx.beginPath();
            this.ctx.moveTo(x, GROUND_Y);
            this.ctx.lineTo(x - 100, GROUND_Y + 50); // Slanted scan line
            this.ctx.strokeStyle = COLORS.RADAR_LINE;
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
        }
    },
    
    drawCrosshair() {
        const x = this.mouseX;
        const y = this.mouseY;
        
        this.ctx.strokeStyle = "white";
        this.ctx.lineWidth = 1;
        
        // Circle
        this.ctx.beginPath();
        this.ctx.arc(x, y, 10, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // Cross lines
        this.ctx.beginPath();
        this.ctx.moveTo(x - 15, y);
        this.ctx.lineTo(x + 15, y);
        this.ctx.moveTo(x, y - 15);
        this.ctx.lineTo(x, y + 15);
        this.ctx.stroke();

        // Connecting line to active battery (if aiming)
        const bat = this.batteries[this.activeBatteryIndex];
        if (!bat.destroyed && bat.ammo > 0) {
             this.ctx.beginPath();
             this.ctx.moveTo(bat.x, GROUND_Y - 20);
             this.ctx.lineTo(x, y);
             this.ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
             this.ctx.setLineDash([5, 5]);
             this.ctx.stroke();
             this.ctx.setLineDash([]);
        }
    },
    
    updateHUD() {
        document.getElementById('scoreVal').innerText = this.score;
        document.getElementById('highScoreVal').innerText = this.highScore;
        document.getElementById('waveVal').innerText = this.wave;
        
        // Draw Ammo bars directly on canvas for retro feel
        this.ctx.fillStyle = "white";
        this.ctx.font = "12px 'Press Start 2P'";
        this.ctx.textAlign = "center";
        
        const ammoY = GROUND_Y + 20;
        
        this.batteries.forEach((b, i) => {
            if (!b.destroyed) {
                // Draw X for shots remaining
                let str = "";
                for(let k=0; k<b.ammo; k++) str += "|";
                this.ctx.fillText(str, b.x, ammoY);
            } else {
                 this.ctx.fillStyle = "red";
                 this.ctx.fillText("DESTROYED", b.x, ammoY);
                 this.ctx.fillStyle = "white";
            }
        });
    },

    loop() {
        if (this.state === 'GAMEOVER' && document.getElementById('message-overlay').classList.contains('hidden')) return;
        
        this.update();
        this.draw();
        
        requestAnimationFrame(() => this.loop());
    }
};

// --- CLASSES ---

class Battery {
    constructor(x) {
        this.x = x;
        this.y = GROUND_Y - 10;
        this.width = 40;
        this.height = 20;
        this.ammo = 10; // Max ammo per battery
        this.destroyed = false;
    }
    
    draw(ctx) {
        if (this.destroyed) return;
        
        ctx.fillStyle = COLORS.BATTERY;
        // Base
        ctx.beginPath();
        ctx.arc(this.x, GROUND_Y, 20, Math.PI, 0);
        ctx.fill();
        // Turret
        ctx.fillRect(this.x - 5, this.y - 15, 10, 15);
        
        // Glow if active
        if (Game.batteries[Game.activeBatteryIndex] === this) {
             ctx.shadowBlur = 10;
             ctx.shadowColor = "white";
             ctx.fillStyle = "#fff";
             ctx.fillRect(this.x-2, this.y-12, 4, 4);
             ctx.shadowBlur = 0;
        }
    }
}

class City {
    constructor(x) {
        this.x = x;
        this.y = GROUND_Y;
        this.dead = false;
        // Generate a random "skyline" shape for the city
        this.shape = [];
        let currentX = -15;
        while(currentX < 15) {
            const w = Math.random() * 8 + 4;
            const h = Math.random() * 12 + 5;
            this.shape.push({x: currentX, w: w, h: h});
            currentX += w;
        }
    }
    
    draw(ctx) {
        if (this.dead) {
             // Rubble
             ctx.fillStyle = COLORS.CITY_DEAD;
             ctx.beginPath();
             ctx.arc(this.x, GROUND_Y, 15, Math.PI, 0);
             ctx.fill();
             return;
        }
        
        ctx.fillStyle = COLORS.CITY_ALIVE;
        
        // Draw buildings
        for (const b of this.shape) {
            ctx.fillRect(this.x + b.x, GROUND_Y - b.h, b.w, b.h);
            // Windows
            ctx.fillStyle = "black";
            if(b.h > 8 && b.w > 4) ctx.fillRect(this.x + b.x + 2, GROUND_Y - b.h + 2, 2, 2);
            ctx.fillStyle = COLORS.CITY_ALIVE;
        }
    }
}

class EnemyMissile {
    constructor(x, y, targetX, targetY, isMIRV = false) {
        this.x = x;
        this.y = y;
        this.targetX = targetX;
        this.targetY = targetY;
        
        const dist = Math.hypot(targetX - x, targetY - y);
        // Speed increases slightly with wave
        const baseSpeed = 0.5 + (Game.wave * 0.1); 
        this.vx = ((targetX - x) / dist) * baseSpeed;
        this.vy = ((targetY - y) / dist) * baseSpeed;
        
        this.trail = []; // Stores previous positions for drawing trail
        this.reachedTarget = false;
        this.isMIRV = isMIRV;
    }
    
    update() {
        this.trail.push({x: this.x, y: this.y});
        if (this.trail.length > 20) this.trail.shift();
        
        this.x += this.vx;
        this.y += this.vy;
        
        // Check arrival
        if (Math.abs(this.y - this.targetY) < Math.abs(this.vy)) {
            this.reachedTarget = true;
        }
    }
    
    draw(ctx) {
        ctx.strokeStyle = COLORS.ENEMY_TRAIL;
        ctx.lineWidth = 2;
        ctx.beginPath();
        if (this.trail.length > 0) {
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (let t of this.trail) ctx.lineTo(t.x, t.y);
        }
        ctx.lineTo(this.x, this.y);
        ctx.stroke();
        
        // Warhead
        ctx.fillStyle = "white";
        ctx.fillRect(this.x - 1, this.y - 1, 3, 3);
    }
}

class PlayerMissile {
    constructor(x, y, targetX, targetY) {
        this.startX = x;
        this.startY = y;
        this.targetX = targetX;
        this.targetY = targetY;
        
        this.x = x;
        this.y = y;
        
        const dist = Math.hypot(targetX - x, targetY - y);
        const speed = 6; // Player missiles are fast
        this.vx = ((targetX - x) / dist) * speed;
        this.vy = ((targetY - y) / dist) * speed;
        
        this.reachedTarget = false;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        
        const d = Math.hypot(this.x - this.startX, this.y - this.startY);
        const totalDist = Math.hypot(this.targetX - this.startX, this.targetY - this.startY);
        
        if (d >= totalDist) {
            this.reachedTarget = true;
            this.x = this.targetX;
            this.y = this.targetY;
        }
    }
    
    draw(ctx) {
        ctx.strokeStyle = COLORS.PLAYER_TRAIL;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.startX, this.startY);
        ctx.lineTo(this.x, this.y);
        ctx.stroke();
        
        // Spark at tip
        if (!this.reachedTarget) {
            ctx.fillStyle = "white";
            ctx.fillRect(this.x-1, this.y-1, 3, 3);
        }
    }
}

class Explosion {
    constructor(x, y, isEnemy) {
        this.x = x;
        this.y = y;
        this.maxRadius = isEnemy ? 35 : 50; // Player explosions are bigger
        this.currentRadius = 0;
        this.growthRate = 1.5;
        this.state = 'EXPANDING'; // EXPANDING, SHRINKING
        this.isEnemy = isEnemy;
        this.dead = false;
        
        // Frame counter for pulsing effect
        this.frame = 0; 
    }
    
    update() {
        this.frame++;
        
        if (this.state === 'EXPANDING') {
            this.currentRadius += this.growthRate;
            if (this.currentRadius >= this.maxRadius) {
                this.state = 'SHRINKING';
            }
        } else {
            this.currentRadius -= 1; // Shrink slower
            if (this.currentRadius <= 0) {
                this.dead = true;
            }
        }
    }
    
    draw(ctx) {
        if (this.currentRadius <= 0) return;
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, Math.max(0, this.currentRadius), 0, Math.PI * 2);
        
        // Retro concentric circle effect
        const color = this.isEnemy ? COLORS.EXPLOSION_OUTER : COLORS.EXPLOSION_CORE;
        ctx.fillStyle = color;
        
        // Flashing effect
        if (Math.floor(this.frame / 4) % 2 === 0) {
            ctx.fillStyle = "white";
        }
        
        ctx.fill();
        
        // Inner core
        ctx.beginPath();
        ctx.arc(this.x, this.y, Math.max(0, this.currentRadius * 0.6), 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 200, 50, 0.5)";
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 1) * 4;
        this.life = 1.0;
        this.color = color;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // Gravity
        this.life -= 0.02;
    }
    
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 3, 3);
        ctx.globalAlpha = 1.0;
    }
}

// Start
window.onload = () => Game.init();

</script>
</body>
</html>