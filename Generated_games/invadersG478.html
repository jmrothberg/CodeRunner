<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders - 1978 Tribute</title>
    <style>
        /* Import a retro pixel font */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #111;
            --terminal-green: #33ff00;
            --text-white: #fff;
            --accent-red: #ff3333;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-white);
            font-family: 'Press Start 2P', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* Game Container */
        #game-container {
            position: relative;
            width: 800px; /* Base resolution scaled up */
            max-width: 95vw;
            aspect-ratio: 3/4;
            background-color: #000;
            border: 4px solid #444;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; /* Sharp edges */
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            text-transform: uppercase;
        }

        .hidden {
            display: none !important;
        }

        /* HUD (Heads Up Display) */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            color: white;
            z-index: 10;
        }

        /* Start / Game Over Screens */
        #start-screen, #game-over-screen {
            background: rgba(0, 0, 0, 0.85);
            pointer-events: auto;
            z-index: 20;
        }

        h1 {
            font-size: 40px;
            color: var(--terminal-green);
            text-shadow: 4px 4px #005500;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        p {
            font-size: 14px;
            line-height: 2;
            color: #ccc;
        }

        .btn {
            margin-top: 30px;
            padding: 15px 30px;
            background: var(--terminal-green);
            color: black;
            border: none;
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--terminal-green);
        }

        .btn:active {
            transform: scale(0.95);
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 50;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Shown via JS on touch devices if needed, keeping simple for now */
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="600" height="800"></canvas>
    
    <!-- CRT Effect -->
    <div class="scanlines"></div>

    <!-- HUD -->
    <div id="hud">
        <div id="score-display">SCORE: 0000</div>
        <div id="lives-display">LIVES: 3</div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="ui-layer">
        <h1>SPACE<br>INVADERS</h1>
        <p>Arrow Keys to Move</p>
        <p>Space to Fire</p>
        <button class="btn" onclick="game.start()">Insert Coin</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="ui-layer hidden">
        <h1 style="color: var(--accent-red); text-shadow: 4px 4px #550000;">GAME OVER</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button class="btn" onclick="game.reset()">Play Again</button>
    </div>
</div>

<script>
/**
 * SPACE INVADERS - 1978 TRIBUTE
 * 
 * Architecture:
 * - Game Loop: Handles update and draw cycles.
 * - Entities: Player, Alien, Bullet, Bunker, Particle, UFO.
 * - Renderer: Draws pixel art from binary maps.
 */

// --- CONFIGURATION ---
const CANVAS_WIDTH = 600;
const CANVAS_HEIGHT = 800;
const FPS = 60;

// Colors
const C_BLACK = '#000000';
const C_WHITE = '#FFFFFF';
const C_GREEN = '#33FF00'; // Player/Bunkers
const C_RED = '#FF3333';   // UFO
const C_ALIEN_1 = '#FFFFFF'; // Squid
const C_ALIEN_2 = '#FFFFFF'; // Crab
const C_ALIEN_3 = '#FFFFFF'; // Octopus

// --- SPRITE BITMAPS (1 = pixel, 0 = empty) ---
// 11x8 grids for aliens
const SPRITES = {
    player: [
        [0,0,0,0,0,1,0,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,1,1,1,1,1,1,1,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1]
    ],
    alien_squid_a: [
        [0,0,0,1,1,0,0,0],
        [0,0,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,0],
        [1,1,0,1,1,0,1,1],
        [1,1,1,1,1,1,1,1],
        [0,0,1,0,0,1,0,0],
        [0,1,0,1,1,0,1,0],
        [1,0,1,0,0,1,0,1]
    ],
    alien_squid_b: [
        [0,0,0,1,1,0,0,0],
        [0,0,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,0],
        [1,1,0,1,1,0,1,1],
        [1,1,1,1,1,1,1,1],
        [0,1,0,1,1,0,1,0],
        [1,0,0,0,0,0,0,1],
        [0,1,0,0,0,0,1,0]
    ],
    alien_crab_a: [
        [0,0,1,0,0,0,0,0,1,0,0],
        [0,0,0,1,0,0,0,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,1,1,0,1,1,1,0,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1],
        [1,0,1,1,1,1,1,1,1,0,1],
        [1,0,1,0,0,0,0,0,1,0,1],
        [0,0,0,1,1,0,1,1,0,0,0]
    ],
    alien_crab_b: [
        [0,0,1,0,0,0,0,0,1,0,0],
        [1,0,0,1,0,0,0,1,0,0,1],
        [1,0,1,1,1,1,1,1,1,0,1],
        [1,1,1,0,1,1,1,0,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1],
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,0,1,0,0,0,0,0,1,0,0],
        [0,1,0,0,0,0,0,0,0,1,0]
    ],
    alien_octopus_a: [
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,1,1,1,0],
        [1,1,1,0,0,1,0,0,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1],
        [0,0,0,1,1,0,1,1,0,0,0],
        [0,0,1,1,0,1,0,1,1,0,0],
        [1,1,0,0,0,0,0,0,0,1,1]
    ],
    alien_octopus_b: [
        [0,0,0,0,1,1,1,0,0,0,0],
        [0,0,1,1,1,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,1,1,1,0],
        [1,1,1,0,0,1,0,0,1,1,1],
        [1,1,1,1,1,1,1,1,1,1,1],
        [0,0,1,1,0,1,0,1,1,0,0],
        [0,1,0,0,1,0,1,0,0,1,0],
        [0,0,1,1,0,0,0,1,1,0,0]
    ],
    ufo: [
        [0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0],
        [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
        [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
        [0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,0],
        [0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0]
    ]
};

// --- AUDIO SYSTEM (Placeholders) ---
const AudioSys = {
    playShoot: () => { console.log("Audio: Shoot"); },
    playExplosion: () => { console.log("Audio: Explosion"); },
    playUfo: () => { console.log("Audio: UFO"); },
    playPlayerDie: () => { console.log("Audio: Player Die"); },
    playAlienMove: (step) => { /* Rhythmic thump */ }
};

// --- UTILS ---
function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || 
             r2.x + r2.w < r1.x || 
             r2.y > r1.y + r1.h || 
             r2.y + r2.h < r1.y);
}

function randomRange(min, max) {
    return Math.random() * (max - min) + min;
}

// --- CLASSES ---

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = randomRange(-2, 2);
        this.vy = randomRange(-2, 2);
        this.life = 1.0; // Opacity
        this.decay = randomRange(0.02, 0.05);
        this.color = color;
        this.size = randomRange(2, 4);
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

class Bullet {
    constructor(x, y, dy, color) {
        this.x = x;
        this.y = y;
        this.w = 4;
        this.h = 10;
        this.dy = dy; // Speed (negative for up, positive for down)
        this.color = color;
        this.active = true;
    }

    update() {
        this.y += this.dy;
        if (this.y < 0 || this.y > CANVAS_HEIGHT) {
            this.active = false;
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
    }
}

class Bunker {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 60; // Width of bunker
        this.h = 40; // Height of bunker
        this.blocks = []; // Array of small rects
        
        // Initialize blocks (pixel grid for destruction)
        const blockSize = 4;
        // Create an arch shape
        for(let by = 0; by < this.h; by += blockSize) {
            for(let bx = 0; bx < this.w; bx += blockSize) {
                // Arch logic: cut out bottom center
                let isArch = false;
                if (by > this.h * 0.6) {
                    const centerX = this.w / 2;
                    const distFromCenter = Math.abs(bx + blockSize/2 - centerX);
                    if (distFromCenter < (this.w * 0.25)) {
                        isArch = true;
                    }
                }

                if (!isArch) {
                    this.blocks.push({
                        x: this.x + bx,
                        y: this.y + by,
                        w: blockSize,
                        h: blockSize,
                        active: true
                    });
                }
            }
        }
    }

    checkCollision(bullet) {
        // Simple AABB against all blocks
        for (let block of this.blocks) {
            if (block.active && rectIntersect({x: bullet.x, y: bullet.y, w: bullet.w, h: bullet.h}, block)) {
                block.active = false;
                bullet.active = false;
                
                // Create particles
                game.createExplosion(block.x + 2, block.y + 2, C_GREEN, 3);
                return true; // Hit handled
            }
        }
        return false;
    }

    draw(ctx) {
        ctx.fillStyle = C_GREEN;
        for (let block of this.blocks) {
            if (block.active) {
                ctx.fillRect(block.x, block.y, block.w, block.h);
            }
        }
    }
}

class Player {
    constructor() {
        this.w = 44; // 11 * 4 scale
        this.h = 32; // 8 * 4 scale
        this.x = CANVAS_WIDTH / 2 - this.w / 2;
        this.y = CANVAS_HEIGHT - 60;
        this.speed = 5;
        this.color = C_GREEN;
        this.bullet = null;
        this.isDead = false;
    }

    update(input) {
        if (this.isDead) return;

        // Movement
        if (input.keys['ArrowLeft'] && this.x > 10) {
            this.x -= this.speed;
        }
        if (input.keys['ArrowRight'] && this.x < CANVAS_WIDTH - this.w - 10) {
            this.x += this.speed;
        }

        // Shooting
        if (input.keys['Space']) {
            if (!this.bullet) {
                this.bullet = new Bullet(this.x + this.w / 2 - 2, this.y, -7, C_WHITE);
                AudioSys.playShoot();
                input.keys['Space'] = false; // Require key release to fire again (machine gun prevention)
            }
        }

        // Update bullet
        if (this.bullet) {
            this.bullet.update();
            if (!this.bullet.active) this.bullet = null;
        }
    }

    draw(ctx) {
        if (this.isDead) return;
        
        // Draw Sprite
        const scale = 4;
        ctx.fillStyle = this.color;
        const map = SPRITES.player;
        
        for(let r=0; r<map.length; r++) {
            for(let c=0; c<map[r].length; c++) {
                if(map[r][c] === 1) {
                    ctx.fillRect(this.x + c*scale, this.y + r*scale, scale, scale);
                }
            }
        }

        // Draw Bullet
        if (this.bullet) this.bullet.draw(ctx);
    }
}

class Alien {
    constructor(c, r, type) {
        this.c = c; // Column index
        this.r = r; // Row index
        this.type = type; // 0: Squid, 1: Crab, 2: Octopus
        
        // Dimensions based on sprite size (scale 4)
        this.scale = 3;
        if(type === 0) { this.w = 8 * this.scale; this.h = 8 * this.scale; } // Squid
        else if (type === 1) { this.w = 11 * this.scale; this.h = 8 * this.scale; } // Crab
        else { this.w = 11 * this.scale; this.h = 8 * this.scale; } // Octopus

        this.x = 0;
        this.y = 0;
        this.active = true;
        this.frame = 0; // Animation frame (0 or 1)
    }

    draw(ctx) {
        if (!this.active) return;

        ctx.fillStyle = C_WHITE;
        
        let map;
        if (this.type === 0) map = this.frame === 0 ? SPRITES.alien_squid_a : SPRITES.alien_squid_b;
        else if (this.type === 1) map = this.frame === 0 ? SPRITES.alien_crab_a : SPRITES.alien_crab_b;
        else map = this.frame === 0 ? SPRITES.alien_octopus_a : SPRITES.alien_octopus_b;

        for(let r=0; r<map.length; r++) {
            for(let c=0; c<map[r].length; c++) {
                if(map[r][c] === 1) {
                    ctx.fillRect(this.x + c*this.scale, this.y + r*this.scale, this.scale, this.scale);
                }
            }
        }
    }
}

class AlienManager {
    constructor() {
        this.aliens = [];
        this.bullets = [];
        this.direction = 1; // 1 right, -1 left
        this.moveTimer = 0;
        this.moveInterval = 60; // Frames between moves (decreases as they die)
        this.dropAmount = 20;
        
        // Grid setup
        const startX = 50;
        const startY = 80;
        const gapX = 45;
        const gapY = 35;

        for(let r=0; r<5; r++) {
            for(let c=0; c<11; c++) {
                let type = 2; // Octopus
                if (r === 0) type = 0; // Squid
                else if (r < 3) type = 1; // Crab

                let alien = new Alien(c, r, type);
                alien.x = startX + c * gapX;
                alien.y = startY + r * gapY;
                this.aliens.push(alien);
            }
        }
    }

    update(player, bunkers) {
        const activeAliens = this.aliens.filter(a => a.active);
        
        // Game Over if aliens reach bottom
        for (let a of activeAliens) {
            if (a.y + a.h >= player.y) {
                game.gameOver();
                return;
            }
        }

        if (activeAliens.length === 0) {
            game.levelUp(); // Respawn/Win logic could go here, for now just reset
            return;
        }

        // Speed calculation: Fewer aliens = faster
        // Base speed + factor based on dead count
        const total = 55;
        const remaining = activeAliens.length;
        this.moveInterval = Math.max(5, 60 - (total - remaining) * 1.2);

        this.moveTimer++;
        
        // Move Logic
        if (this.moveTimer >= this.moveInterval) {
            this.moveTimer = 0;
            
            let hitEdge = false;
            
            // Check edges
            for (let a of activeAliens) {
                if ((this.direction === 1 && a.x + a.w > CANVAS_WIDTH - 20) ||
                    (this.direction === -1 && a.x < 20)) {
                    hitEdge = true;
                    break;
                }
            }

            if (hitEdge) {
                this.direction *= -1;
                for (let a of activeAliens) {
                    a.y += this.dropAmount;
                }
            } else {
                for (let a of activeAliens) {
                    a.x += 10 * this.direction;
                    // Toggle animation frame
                    a.frame = a.frame === 0 ? 1 : 0;
                }
            }
            
            AudioSys.playAlienMove();
        }

        // Alien Shooting Logic
        // Only bottom-most aliens can shoot
        if (Math.random() < 0.02 + (55 - remaining) * 0.0005) { // Increase chance as they die
            // Find columns that have active aliens
            let cols = {};
            for(let a of activeAliens) {
                if (!cols[a.c] || a.y > cols[a.c].y) {
                    cols[a.c] = a;
                }
            }
            
            // Pick random shooter from bottom row
            const shooters = Object.values(cols);
            if (shooters.length > 0) {
                const shooter = shooters[Math.floor(Math.random() * shooters.length)];
                this.bullets.push(new Bullet(shooter.x + shooter.w/2, shooter.y + shooter.h, 4, C_WHITE));
            }
        }

        // Update Bullets
        for (let b of this.bullets) {
            b.update();
            
            // Collision with Player
            if (b.active && rectIntersect(b, player)) {
                b.active = false;
                game.playerHit();
            }

            // Collision with Bunkers
            if (b.active) {
                for (let bunk of bunkers) {
                    if (bunk.checkCollision(b)) break;
                }
            }
        }
        
        // Cleanup inactive bullets
        this.bullets = this.bullets.filter(b => b.active);
    }

    draw(ctx) {
        for (let a of this.aliens) {
            a.draw(ctx);
        }
        for (let b of this.bullets) {
            b.draw(ctx);
        }
    }

    checkPlayerBullet(bullet) {
        if (!bullet || !bullet.active) return;

        for (let a of this.aliens) {
            if (a.active && rectIntersect(bullet, a)) {
                a.active = false;
                bullet.active = false;
                
                // Score
                let points = 10;
                if(a.type === 0) points = 30; // Squid
                else if(a.type === 1) points = 20; // Crab
                else points = 10; // Octopus
                
                game.addScore(points);
                game.createExplosion(a.x + a.w/2, a.y + a.h/2, C_WHITE, 8);
                AudioSys.playExplosion();
                return;
            }
        }
    }
}

class UFO {
    constructor() {
        this.active = false;
        this.timer = 0;
        this.interval = randomRange(600, 1200); // Random spawn time
        this.x = 0;
        this.y = 40;
        this.w = 48; // 16 * 3 scale
        this.h = 21; // 7 * 3 scale
        this.direction = 1;
        this.speed = 3;
    }

    update() {
        if (!this.active) {
            this.timer++;
            if (this.timer > this.interval) {
                this.spawn();
            }
        } else {
            this.x += this.speed * this.direction;
            
            // Despawn if off screen
            if ((this.direction === 1 && this.x > CANVAS_WIDTH) || 
                (this.direction === -1 && this.x < -this.w)) {
                this.active = false;
                this.timer = 0;
                this.interval = randomRange(600, 1200);
            }
        }
    }

    spawn() {
        this.active = true;
        this.direction = Math.random() > 0.5 ? 1 : -1;
        this.x = this.direction === 1 ? -this.w : CANVAS_WIDTH;
        AudioSys.playUfo();
    }

    draw(ctx) {
        if (!this.active) return;
        
        ctx.fillStyle = C_RED;
        const scale = 3;
        const map = SPRITES.ufo;

        for(let r=0; r<map.length; r++) {
            for(let c=0; c<map[r].length; c++) {
                if(map[r][c] === 1) {
                    ctx.fillRect(this.x + c*scale, this.y + r*scale, scale, scale);
                }
            }
        }
    }

    checkCollision(bullet) {
        if (!this.active || !bullet || !bullet.active) return false;
        
        if (rectIntersect(bullet, {x: this.x, y: this.y, w: this.w, h: this.h})) {
            this.active = false;
            bullet.active = false;
            
            // Random Score 50-300
            const points = [50, 100, 150, 200, 300][Math.floor(Math.random()*5)];
            game.addScore(points);
            game.createExplosion(this.x + this.w/2, this.y + this.h/2, C_RED, 15);
            
            // Show floating text (simplified: just log for now or draw to canvas)
            AudioSys.playExplosion();
            return true;
        }
        return false;
    }
}

// --- MAIN GAME CLASS ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Input
        this.input = { keys: {} };
        window.addEventListener('keydown', e => this.input.keys[e.code] = true);
        window.addEventListener('keyup', e => this.input.keys[e.code] = false);

        // UI Elements
        this.scoreEl = document.getElementById('score-display');
        this.livesEl = document.getElementById('lives-display');
        this.startScreen = document.getElementById('start-screen');
        this.gameOverScreen = document.getElementById('game-over-screen');
        this.finalScoreEl = document.getElementById('final-score');

        // Game State
        this.state = 'MENU'; // MENU, PLAYING, GAMEOVER
        this.score = 0;
        this.lives = 3;
        
        // Entities
        this.player = null;
        this.alienManager = null;
        this.bunkers = [];
        this.ufo = null;
        this.particles = [];

        // Bind loop
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    start() {
        this.score = 0;
        this.lives = 3;
        this.updateUI();
        
        this.player = new Player();
        this.alienManager = new AlienManager();
        this.ufo = new UFO();
        this.particles = [];
        
        // Create Bunkers
        this.bunkers = [];
        const spacing = CANVAS_WIDTH / 5;
        for(let i=1; i<=4; i++) {
            this.bunkers.push(new Bunker(i * spacing - 30, CANVAS_HEIGHT - 140));
        }

        this.state = 'PLAYING';
        this.startScreen.classList.add('hidden');
        this.gameOverScreen.classList.add('hidden');
    }

    reset() {
        this.start();
    }

    gameOver() {
        this.state = 'GAMEOVER';
        this.finalScoreEl.innerText = this.score;
        this.gameOverScreen.classList.remove('hidden');
    }

    playerHit() {
        AudioSys.playPlayerDie();
        this.createExplosion(this.player.x + this.player.w/2, this.player.y + this.player.h/2, C_GREEN, 20);
        
        this.lives--;
        this.updateUI();

        if (this.lives <= 0) {
            this.gameOver();
        } else {
            // Respawn player logic
            this.player.bullet = null;
            this.player.x = CANVAS_WIDTH / 2 - this.player.w / 2;
            
            // Small delay before vulnerable again could be added here
        }
    }

    addScore(points) {
        this.score += points;
        this.updateUI();
    }

    updateUI() {
        this.scoreEl.innerText = `SCORE: ${this.score.toString().padStart(4, '0')}`;
        this.livesEl.innerText = `LIVES: ${this.lives}`;
    }

    createExplosion(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    levelUp() {
        // Simple reset for now, could increase difficulty
        this.alienManager = new AlienManager();
        this.player.bullet = null;
        this.ufo.active = false;
        this.addScore(1000); // Bonus for clearing wave
    }

    update() {
        if (this.state !== 'PLAYING') return;

        this.player.update(this.input);
        
        // Check Player Bullet vs Aliens
        if (this.player.bullet) {
            this.alienManager.checkPlayerBullet(this.player.bullet);
            this.ufo.checkCollision(this.player.bullet);
            
            // Check Player Bullet vs Bunkers
            if (this.player.bullet && this.player.bullet.active) {
                for(let b of this.bunkers) {
                    if(b.checkCollision(this.player.bullet)) break;
                }
            }
        }

        this.alienManager.update(this.player, this.bunkers);
        this.ufo.update();

        // Update particles
        for (let p of this.particles) {
            p.update();
        }
        this.particles = this.particles.filter(p => p.life > 0);
    }

    draw() {
        // Clear Screen
        this.ctx.fillStyle = C_BLACK;
        this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        if (this.state === 'PLAYING' || this.state === 'GAMEOVER') {
            // Draw Entities
            for(let b of this.bunkers) b.draw(this.ctx);
            
            if (this.player) this.player.draw(this.ctx);
            
            this.alienManager.draw(this.ctx);
            this.ufo.draw(this.ctx);

            // Draw Particles
            for (let p of this.particles) {
                p.draw(this.ctx);
            }
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

// Initialize Game
const game = new Game();

</script>
</body>
</html>