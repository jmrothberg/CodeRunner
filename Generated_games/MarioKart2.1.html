<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Turbo Kart Legends</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
            font-size: 24px;
        }
        .item-display {
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.5);
            border: 3px solid gold;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
        }
        #minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 50, 0, 0.8);
            border: 2px solid white;
            border-radius: 10px;
        }
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        h1 { font-size: 60px; color: gold; text-shadow: 4px 4px 0 #d35400; margin-bottom: 10px; }
        button {
            padding: 15px 40px;
            font-size: 24px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        button:hover { transform: scale(1.05); background: #ff6b6b; }
        .controls { margin-top: 20px; color: #ccc; text-align: center; line-height: 1.5; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-top">
        <div>LAP: <span id="lap-counter">1/3</span></div>
        <div>POS: <span id="pos-counter">1/6</span></div>
        <div class="item-display" id="current-item"></div>
    </div>
    <canvas id="minimap"></canvas>
</div>

<div id="start-screen">
    <h1>TURBO KART LEGENDS</h1>
    <button onclick="startGame()">START RACE</button>
    <div class="controls">
        ARROWS to Drive<br>
        SPACE to use Item
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * GAME CONFIGURATION & CONSTANTS
 */
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');
const MM_CANVAS = document.getElementById('minimap');
const MM_CTX = MM_CANVAS.getContext('2d');

let WIDTH, HEIGHT;
const TRACK_WIDTH = 140;
const TOTAL_LAPS = 3;
const AI_COUNT = 5;

// Physics Constants
const DRAG_ROAD = 0.96;
const DRAG_GRASS = 0.90;
const ACCEL = 0.4;
const TURN_SPEED = 0.06;
const MAX_SPEED = 14;
const BOOST_SPEED = 22;

let gameState = 'MENU'; // MENU, PLAY, END
let karts = [];
let playerKart;
let items = []; // Active projectiles/traps
let itemBoxes = [];
let particles = [];
let trackPoints = [];

// Input State
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false };

/**
 * UTILITIES
 */
function resize() {
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    CANVAS.width = WIDTH;
    CANVAS.height = HEIGHT;
}
window.addEventListener('resize', resize);
resize();

function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }
function angleDiff(a1, a2) {
    let diff = a2 - a1;
    while (diff > Math.PI) diff -= Math.PI * 2;
    while (diff < -Math.PI) diff += Math.PI * 2;
    return diff;
}

/**
 * TRACK GENERATION
 */
function generateTrack() {
    const cx = 0, cy = 0; 
    trackPoints = [];
    const steps = 100;
    for (let i = 0; i < steps; i++) {
        const theta = (i / steps) * Math.PI * 2;
        let r = 800 + Math.sin(theta * 3) * 300 + Math.cos(theta * 5) * 150;
        trackPoints.push({
            x: cx + Math.cos(theta) * r,
            y: cy + Math.sin(theta) * r
        });
    }
}

function getTrackSurface(x, y) {
    let minD = Infinity;
    for (let p of trackPoints) {
        const d = dist(x, y, p.x, p.y);
        if (d < minD) minD = d;
    }
    return minD < TRACK_WIDTH / 2 ? 'ROAD' : 'GRASS';
}

/**
 * PARTICLE SYSTEM
 */
class Particle {
    constructor(x, y, color, speed, life) {
        this.x = x; this.y = y;
        this.color = color;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = Math.random() * speed;
        this.life = life;
        this.maxLife = life;
    }
    update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life--;
    }
    draw(ctx, camX, camY) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x - camX, this.y - camY, 3 + Math.random()*2, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

/**
 * ITEM SYSTEM
 */
const ITEMS = {
    MUSHROOM: { color: '#e74c3c', icon: 'üçÑ' },
    SHELL: { color: '#f1c40f', icon: 'üê¢' },
    BANANA: { color: '#f39c12', icon: 'üçå' },
    LIGHTNING: { color: '#9b59b6', icon: '‚ö°' },
    STAR: { color: '#3498db', icon: '‚≠ê' }
};

class ItemBox {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.active = true;
        this.pulse = 0;
    }
    update() {
        this.pulse += 0.1;
    }
    draw(ctx, camX, camY) {
        if (!this.active) return;
        const size = 30 + Math.sin(this.pulse) * 5;
        
        ctx.shadowBlur = 20;
        ctx.shadowColor = 'gold';
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x - camX - size/2, this.y - camY - size/2, size, size);
        
        ctx.fillStyle = '#000';
        ctx.font = `bold ${size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('?', this.x - camX, this.y - camY);
        
        ctx.shadowBlur = 0;
    }
}

class Projectile {
    constructor(x, y, angle, type, owner) {
        this.x = x; this.y = y;
        this.angle = angle;
        this.type = type; 
        this.owner = owner;
        this.life = 100;
        
        if (type === 'shell') {
            this.speed = 20;
        } else if (type === 'banana') {
            this.speed = 0; 
        }
    }

    update() {
        if (this.type === 'shell') {
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
            
            if (Math.random() > 0.5) {
                particles.push(new Particle(this.x, this.y, '#fff', 2, 20));
            }
        } 
        this.life--;
    }

    draw(ctx, camX, camY) {
        ctx.save();
        ctx.translate(this.x - camX, this.y - camY);
        
        if (this.type === 'shell') {
            ctx.rotate(this.angle);
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(5, 0, 4, 0, Math.PI*2);
            ctx.fill();
        } else if (this.type === 'banana') {
            ctx.rotate(-Math.PI/4); 
            ctx.font = "30px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("üçå", 0, 0);
        }
        
        ctx.restore();
    }
}

/**
 * KART CLASS
 */
class Kart {
    constructor(x, y, isPlayer, color, startAngle) {
        this.x = x; 
        this.y = y;
        this.isPlayer = isPlayer;
        this.color = color;
        this.angle = startAngle;
        
        // Physics
        this.speed = 0;
        this.vx = 0;
        this.vy = 0;
        
        // State
        this.lap = 1;
        this.checkpointIndex = 0; 
        this.finished = false;
        this.rank = 0;
        
        // Items
        this.item = null;
        this.invincible = false;
        this.boostTimer = 0;
        this.spinTimer = 0;

        // AI specific
        this.currentWaypoint = 1;
    }

    update() {
        if (this.finished) return;

        // Handle Status Effects
        if (this.spinTimer > 0) {
            this.angle += 0.3; 
            this.speed *= 0.9;
            this.spinTimer--;
            particles.push(new Particle(this.x, this.y, 'orange', 5, 10));
            return; 
        }

        if (this.invincible) {
            this.boostTimer--;
            if (this.boostTimer <= 0) this.invincible = false;
        }
        
        if (this.boostTimer > 0 && !this.invincible) {
             this.boostTimer--; 
        }

        const maxS = (this.boostTimer > 0 || this.invincible) ? BOOST_SPEED : MAX_SPEED;

        // --- INPUT / AI LOGIC ---
        let throttle = false;
        let brake = false;
        let turn = 0;

        if (this.isPlayer) {
            if (keys.ArrowUp) throttle = true;
            if (keys.ArrowDown) brake = true;
            if (keys.ArrowLeft) turn = -1;
            if (keys.ArrowRight) turn = 1;
            
            // Use Item
            if (keys.Space && this.item) {
                this.useItem();
                keys.Space = false; 
            }
        } else {
            // AI Logic
            throttle = true;
            const target = trackPoints[this.currentWaypoint];
            const d = dist(this.x, this.y, target.x, target.y);
            
            const desiredAngle = Math.atan2(target.y - this.y, target.x - this.x);
            let diff = angleDiff(this.angle, desiredAngle);
            
            if (diff > 0.1) turn = 1;
            else if (diff < -0.1) turn = -1;

            // Slow down for sharp turns
            if (Math.abs(diff) > 0.5) throttle = false; 

            // Switch waypoint when close
            if (d < 100) {
                this.currentWaypoint = (this.currentWaypoint + 1) % trackPoints.length;
            }
            
            // AI Item Usage 
            if (!this.item && Math.random() < 0.01 && dist(this.x, this.y, playerKart.x, playerKart.y) < 300) {
                 const types = Object.keys(ITEMS);
                 this.item = types[Math.floor(Math.random() * types.length)];
            }
            
            if (this.item && Math.random() < 0.05) {
                this.useItem();
            }
        }

        // --- PHYSICS ---
        
        // Acceleration
        if (throttle) this.speed += ACCEL;
        if (brake) this.speed -= ACCEL;

        // Friction & Surface detection
        const surface = getTrackSurface(this.x, this.y);
        let drag = (surface === 'ROAD') ? DRAG_ROAD : DRAG_GRASS;
        
        // Apply Drag
        this.speed *= drag;

        // Cap speed
        if (this.speed > maxS) this.speed = maxS;
        if (this.speed < -maxS/2) this.speed = -maxS/2;

        // Turning 
        if (Math.abs(this.speed) > 0.5) {
            this.angle += turn * TURN_SPEED;
            
            this.vx = Math.cos(this.angle) * this.speed;
            this.vy = Math.sin(this.angle) * this.speed;
        } else {
            this.vx = 0; 
            this.vy = 0;
        }

        // Apply Movement
        this.x += this.vx;
        this.y += this.vy;

        // Particles (Exhaust)
        if (Math.abs(this.speed) > 2 && Math.random() < 0.3) {
             const offX = this.x - Math.cos(this.angle) * 20;
             const offY = this.y - Math.sin(this.angle) * 20;
             particles.push(new Particle(offX, offY, (surface==='GRASS'?'brown':'gray'), 1, 15));
        }

        // --- COLLISIONS & PROGRESSION ---
        
        // Checkpoints 
        const nextCpIndex = (this.checkpointIndex + 1) % trackPoints.length;
        const nextCp = trackPoints[nextCpIndex];
        if (dist(this.x, this.y, nextCp.x, nextCp.y) < TRACK_WIDTH) {
            this.checkpointIndex = nextCpIndex;
            
            // Lap completion
            if (this.checkpointIndex === 0) {
                this.lap++;
                if (this.isPlayer) console.log(`Lap ${this.lap}`);
                if (this.lap > TOTAL_LAPS) {
                    this.finished = true;
                    this.rank = karts.filter(k => k.finished).length + 1; 
                    if(this.isPlayer) endGame();
                }
            }
        }

        // Item Box Collision
        itemBoxes.forEach(box => {
            if (box.active && dist(this.x, this.y, box.x, box.y) < 40) {
                box.active = false;
                setTimeout(() => box.active = true, 5000); 
                
                const types = Object.keys(ITEMS);
                this.item = types[Math.floor(Math.random() * types.length)];
                
                if (this.isPlayer) updateHUD();
                
                for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, 'gold', 5, 20));
            }
        });

        // Projectile Collision
        items.forEach(item => {
            if (item.type === 'shell' && item.owner !== this) {
                if (dist(this.x, this.y, item.x, item.y) < 30) {
                    this.spinTimer = 60;
                    item.life = 0; 
                    for(let i=0; i<15; i++) particles.push(new Particle(this.x, this.y, 'orange', 8, 30));
                }
            } else if (item.type === 'banana' && item.owner !== this) {
                 if (dist(this.x, this.y, item.x, item.y) < 30) {
                     this.spinTimer = 60;
                     item.life = 0; 
                     for(let i=0; i<15; i++) particles.push(new Particle(this.x, this.y, 'yellow', 8, 30));
                 }
            }
        });
    }

    useItem() {
        if (!this.item) return;
        
        const type = this.item;
        this.item = null;
        if (this.isPlayer) updateHUD();

        console.log(`Used: ${type}`);

        if (type === 'MUSHROOM') {
            this.boostTimer = 120; 
        } else if (type === 'STAR') {
            this.invincible = true;
            this.boostTimer = 300;
        } else if (type === 'SHELL') {
            items.push(new Projectile(this.x, this.y, this.angle, 'shell', this));
        } else if (type === 'BANANA') {
            const bx = this.x - Math.cos(this.angle) * 60;
            const by = this.y - Math.sin(this.angle) * 60;
            items.push(new Projectile(bx, by, 0, 'banana', this));
        } else if (type === 'LIGHTNING') {
            karts.forEach(k => {
                if (k !== this && !k.invincible) {
                    k.speed *= 0.3; 
                }
            });
            CTX.fillStyle = 'rgba(255, 255, 255, 0.5)';
            CTX.fillRect(0,0,WIDTH,HEIGHT);
        }
    }

    draw(ctx, camX, camY) {
        ctx.save();
        ctx.translate(this.x - camX, this.y - camY);
        
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        ctx.ellipse(0, 10, 15, 8, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.rotate(this.angle);

        // Invincibility Glow
        if (this.invincible || this.spinTimer > 0) {
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'white';
        }

        // Kart Body
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.roundRect(-20, -12, 40, 24, 5);
        ctx.fill();
        
        // Spoiler
        ctx.fillStyle = '#333';
        ctx.fillRect(-22, -10, 4, 20);

        // Driver Head
        ctx.fillStyle = 'white'; 
        ctx.beginPath();
        ctx.arc(0, 0, 6, 0, Math.PI*2);
        ctx.fill();

        // Wheels
        ctx.fillStyle = 'black';
        ctx.fillRect(-15, -14, 10, 4); 
        ctx.fillRect(5, -14, 10, 4);   
        ctx.fillRect(-15, 10, 10, 4);  
        ctx.fillRect(5, 10, 10, 4);    

        ctx.restore();
        
        // Name tag / Arrow above player
        if (this.isPlayer) {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(this.x - camX, this.y - camY - 40);
            ctx.lineTo(this.x - camX - 5, this.y - camY - 50);
            ctx.lineTo(this.x - camX + 5, this.y - camY - 50);
            ctx.fill();
        }
    }
}

/**
 * GAME LOOP & RENDERING
 */

function initGame() {
    generateTrack();
    
    const startX = trackPoints[0].x;
    const startY = trackPoints[0].y;
    
    karts = [];
    
    // Player
    playerKart = new Kart(startX, startY - 30, true, '#e74c3c', Math.PI/2);
    karts.push(playerKart);

    // AI
    const colors = ['#3498db', '#9b59b6', '#f1c40f', '#2ecc71', '#e67e22'];
    for(let i=0; i<AI_COUNT; i++) {
        let offset = (i % 2 === 0) ? -30 : 30;
        karts.push(new Kart(startX - (i*40), startY + offset, false, colors[i], Math.PI/2));
    }

    // Setup Item Boxes
    itemBoxes = [];
    for(let i=0; i<trackPoints.length; i+=15) {
        const p = trackPoints[i];
        const rx = p.x + (Math.random() - 0.5) * 50;
        const ry = p.y + (Math.random() - 0.5) * 50;
        itemBoxes.push(new ItemBox(rx, ry));
    }
}

function updateHUD() {
    document.getElementById('lap-counter').innerText = `${playerKart.lap}/${TOTAL_LAPS}`;
    
    const sortedKarts = [...karts].sort((a, b) => {
        if (a.lap !== b.lap) return b.lap - a.lap;
        if (a.checkpointIndex !== b.checkpointIndex) return b.checkpointIndex - a.checkpointIndex;
        const nextA = trackPoints[(a.checkpointIndex + 1) % trackPoints.length];
        const distA = dist(a.x, a.y, nextA.x, nextA.y);
        const nextB = trackPoints[(b.checkpointIndex + 1) % trackPoints.length];
        const distB = dist(b.x, b.y, nextB.x, nextB.y);
        return distA - distB;
    });
    
    const pos = sortedKarts.indexOf(playerKart) + 1;
    document.getElementById('pos-counter').innerText = `${pos}/${karts.length}`;
    
    const itemDiv = document.getElementById('current-item');
    if (playerKart.item) {
        itemDiv.innerHTML = ITEMS[playerKart.item].icon;
        itemDiv.style.borderColor = ITEMS[playerKart.item].color;
    } else {
        itemDiv.innerHTML = '';
        itemDiv.style.borderColor = 'gold';
    }
}

function drawTrack(ctx, camX, camY) {
    // Draw Grass
    ctx.fillStyle = '#2ecc71'; 
    ctx.fillRect(camX - WIDTH/2, camY - HEIGHT/2, WIDTH*2, HEIGHT*2); 
    
    // Draw Road
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Border (Curb)
    ctx.beginPath();
    ctx.strokeStyle = '#ecf0f1'; 
    ctx.lineWidth = TRACK_WIDTH + 10;
    drawTrackPath(ctx, camX, camY); // Pass camera vars
    ctx.stroke();
    
    ctx.beginPath();
    ctx.strokeStyle = '#c0392b'; 
    ctx.lineWidth = TRACK_WIDTH + 10;
    ctx.setLineDash([20, 20]);
    drawTrackPath(ctx, camX, camY); // Pass camera vars
    ctx.stroke();
    ctx.setLineDash([]);

    // Asphalt
    ctx.beginPath();
    ctx.strokeStyle = '#555';
    ctx.lineWidth = TRACK_WIDTH;
    drawTrackPath(ctx, camX, camY); // Pass camera vars
    ctx.stroke();

    // Start/Finish Line
    const startP = trackPoints[0];
    const nextP = trackPoints[1];
    const angle = Math.atan2(nextP.y - startP.y, nextP.x - startP.x);
    
    ctx.save();
    ctx.translate(startP.x - camX, startP.y - camY);
    ctx.rotate(angle);
    ctx.fillStyle = 'white';
    for(let i=0; i<10; i++) {
        for(let j=0; j<2; j++) {
            if ((i+j)%2===0) ctx.fillRect(0, -TRACK_WIDTH/2 + i*(TRACK_WIDTH/10), 10, TRACK_WIDTH/10);
        }
    }
    ctx.restore();
}

// Fixed: Added camX and camY parameters
function drawTrackPath(ctx, camX, camY) {
    if (trackPoints.length === 0) return;
    ctx.moveTo(trackPoints[0].x - camX, trackPoints[0].y - camY);
    for (let i = 1; i < trackPoints.length; i++) {
        ctx.lineTo(trackPoints[i].x - camX, trackPoints[i].y - camY);
    }
    ctx.closePath();
}

function drawMinimap() {
    MM_CTX.clearRect(0, 0, 200, 200);
    
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    trackPoints.forEach(p => {
        if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
    });
    
    const scaleX = 180 / (maxX - minX);
    const scaleY = 180 / (maxY - minY);
    const offsetX = 10;
    const offsetY = 10;

    MM_CTX.strokeStyle = '#555';
    MM_CTX.lineWidth = 5;
    MM_CTX.beginPath();
    trackPoints.forEach((p, i) => {
        const mx = (p.x - minX) * scaleX + offsetX;
        const my = (p.y - minY) * scaleY + offsetY;
        if (i===0) MM_CTX.moveTo(mx, my);
        else MM_CTX.lineTo(mx, my);
    });
    MM_CTX.closePath();
    MM_CTX.stroke();

    karts.forEach(k => {
        const mx = (k.x - minX) * scaleX + offsetX;
        const my = (k.y - minY) * scaleY + offsetY;
        
        MM_CTX.fillStyle = k.isPlayer ? 'red' : 'white';
        MM_CTX.beginPath();
        MM_CTX.arc(mx, my, 3, 0, Math.PI*2);
        MM_CTX.fill();
    });
}

function loop() {
    if (gameState !== 'PLAY') return;

    // Update
    karts.forEach(k => k.update());
    
    items.forEach((item, index) => {
        item.update();
        if (item.life <= 0) items.splice(index, 1);
    });

    particles.forEach((p, index) => {
        p.update();
        if (p.life <= 0) particles.splice(index, 1);
    });
    
    itemBoxes.forEach(b => b.update());

    updateHUD();

    // Camera Follow Player
    const camX = playerKart.x - WIDTH / 2;
    const camY = playerKart.y - HEIGHT / 2;

    // Draw World
    CTX.clearRect(0, 0, WIDTH, HEIGHT);
    
    drawTrack(CTX, camX, camY);

    itemBoxes.forEach(b => b.draw(CTX, camX, camY));
    items.forEach(i => i.draw(CTX, camX, camY));
    karts.forEach(k => k.draw(CTX, camX, camY));
    particles.forEach(p => p.draw(CTX, camX, camY));

    drawMinimap();

    requestAnimationFrame(loop);
}

function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    initGame();
    gameState = 'PLAY';
    
    // Input Listeners
    window.addEventListener('keydown', e => {
        if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
        if (e.code === "Space") keys.Space = true;
    });
    window.addEventListener('keyup', e => {
        if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
        if (e.code === "Space") keys.Space = false;
    });

    loop();
}

function endGame() {
    gameState = 'END';
    const pos = document.getElementById('pos-counter').innerText.split('/')[0];
    let msg = "";
    if(pos == 1) msg = "VICTORY! üèÜ";
    else msg = "FINISHED! Position: " + pos;
    
    const screen = document.getElementById('start-screen');
    screen.style.display = 'flex';
    screen.querySelector('h1').innerText = msg;
    screen.querySelector('button').innerText = "PLAY AGAIN";
}

</script>
</body>
</html>