<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galaxa Defender</title>
    <style>
        :root {
            --bg-color: #0d0e15;
            --terminal-green: #33ff00;
            --accent-red: #ff3333;
            --ui-font: 'Courier New', Courier, monospace;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: white;
            font-family: var(--ui-font);
            overflow: hidden; /* Prevent scrolling */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px; /* Arcade cabinet aspect ratio feel */
            aspect-ratio: 3/4;
            background: radial-gradient(circle at center, #1a1c29 0%, #000000 100%);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas usually */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px var(--terminal-green);
            color: var(--terminal-green);
        }

        /* Screens (Start / Game Over) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            transition: opacity 0.3s;
            z-index: 10;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 4px 4px 0px var(--accent-red);
            text-align: center;
        }

        p {
            font-size: 16px;
            line-height: 1.5;
            color: #ccc;
            margin-bottom: 30px;
            text-align: center;
            max-width: 80%;
        }

        .btn {
            background: transparent;
            color: var(--terminal-green);
            border: 2px solid var(--terminal-green);
            padding: 15px 40px;
            font-size: 20px;
            font-family: var(--ui-font);
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(51, 255, 0, 0.2);
        }

        .btn:hover {
            background: var(--terminal-green);
            color: black;
            box-shadow: 0 0 20px rgba(51, 255, 0, 0.8);
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Hidden by default on desktop */
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 120px;
            pointer-events: auto;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            user-select: none;
        }
        
        .control-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        .d-pad {
            display: flex;
            gap: 15px;
        }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: flex; }
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Heads Up Display -->
    <div class="ui-layer">
        <div class="hud">
            <span id="scoreDisplay">SCORE: 0</span>
            <span id="livesDisplay">LIVES: 3</span>
        </div>
        
        <!-- Mobile Controls (Visible on touch devices) -->
        <div id="mobile-controls">
            <div class="d-pad">
                <div class="control-btn" id="btnLeft">‚Üê</div>
                <div class="control-btn" id="btnRight">‚Üí</div>
            </div>
            <div class="control-btn" id="btnFire">üî•</div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="screen">
        <h1>Galaxa</h1>
        <p>Defend the galaxy from the alien swarm.<br><br>Arrows / A-D to Move<br>Space to Shoot</p>
        <button class="btn" id="startBtn">Insert Coin / Start</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen hidden">
        <h1 style="color: var(--accent-red); text-shadow: 4px 4px 0px #fff;">Game Over</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="btn" id="restartBtn">Try Again</button>
    </div>
</div>

<script>
/**
 * GALAXA GAME ENGINE
 * Expertly structured for readability and performance.
 */

// --- CONFIGURATION & CONSTANTS ---
const CANVAS_WIDTH = 600;
const CANVAS_HEIGHT = 800;
const PLAYER_SPEED = 5;
const BULLET_SPEED = 10;
const ENEMY_BULLET_SPEED = 5;
const FIRE_COOLDOWN = 15; // Frames between shots

// Colors
const COLORS = {
    player: '#33ccff',
    enemyA: '#ff3333', // Red (Top)
    enemyB: '#33ff00', // Green (Middle)
    enemyC: '#ffff33', // Yellow (Bottom - Divers)
    bulletPlayer: '#ffffaa',
    bulletEnemy: '#ff5555'
};

// --- AUDIO SYSTEM (Stub) ---
// NOTE: No external files allowed. This is where AudioContext logic would go.
const audioSys = {
    shoot: () => { console.log("[Audio] Player Shoot"); /* synth oscillator here */ },
    enemyShoot: () => { console.log("[Audio] Enemy Shoot"); },
    explosion: () => { console.log("[Audio] Explosion"); },
    start: () => { console.log("[Audio] Game Start"); }
};

// --- GAME STATE ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Set internal resolution
canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;

let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
let score = 0;
let lives = 3;
let frameCount = 0;
let level = 1;

// Entities
let player;
let bullets = [];
let enemyBullets = [];
let enemies = []; // The grid of aliens
let particles = [];
let stars = [];

// Inputs
const keys = {
    ArrowLeft: false, ArrowRight: false,
    a: false, d: false,
    Space: false
};

// --- CLASSES ---

class Star {
    constructor() {
        this.reset();
        this.y = Math.random() * CANVAS_HEIGHT; // Initial random placement
    }

    reset() {
        this.x = Math.random() * CANVAS_WIDTH;
        this.y = -10;
        this.size = Math.random() * 2 + 0.5;
        this.speed = Math.random() * 3 + 0.5;
        this.brightness = Math.random();
    }

    update() {
        this.y += this.speed;
        // Twinkle effect
        this.brightness += (Math.random() - 0.5) * 0.1;
        if (this.brightness > 1) this.brightness = 1;
        if (this.brightness < 0.3) this.brightness = 0.3;

        if (this.y > CANVAS_HEIGHT) {
            this.reset();
        }
    }

    draw() {
        ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`;
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 0.5) * 6;
        this.life = 1.0; // Opacity/Life
        this.decay = Math.random() * 0.03 + 0.02;
        this.color = color;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
    }

    draw() {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2 + this.life * 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Bullet {
    constructor(x, y, isPlayer) {
        this.x = x;
        this.y = y;
        this.width = 4;
        this.height = 10;
        this.isPlayer = isPlayer;
        this.markedForDeletion = false;
    }

    update() {
        if (this.isPlayer) {
            this.y -= BULLET_SPEED;
            if (this.y < -20) this.markedForDeletion = true;
        } else {
            this.y += ENEMY_BULLET_SPEED + (level * 0.5); // Get faster each level
            if (this.y > CANVAS_HEIGHT + 20) this.markedForDeletion = true;
        }
    }

    draw() {
        ctx.fillStyle = this.isPlayer ? COLORS.bulletPlayer : COLORS.bulletEnemy;
        
        // Draw a laser shape
        ctx.beginPath();
        if(this.isPlayer) {
            ctx.rect(this.x - 2, this.y, 4, 12);
        } else {
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x - 3, this.y + 8);
            ctx.lineTo(this.x + 3, this.y + 8);
            ctx.fill();
        }
        ctx.fill();
    }
}

class Player {
    constructor() {
        this.width = 40;
        this.height = 30;
        this.x = CANVAS_WIDTH / 2 - this.width / 2;
        this.y = CANVAS_HEIGHT - 60;
        this.cooldown = 0;
        this.isDead = false;
        this.invincibleTimer = 0;
    }

    update() {
        if (this.isDead) return;

        // Movement
        if ((keys.ArrowLeft || keys.a) && this.x > 10) this.x -= PLAYER_SPEED;
        if ((keys.ArrowRight || keys.d) && this.x < CANVAS_WIDTH - this.width - 10) this.x += PLAYER_SPEED;

        // Shooting
        if (this.cooldown > 0) this.cooldown--;
        
        if ((keys.Space || keys.FireMobile) && this.cooldown <= 0) {
            bullets.push(new Bullet(this.x + this.width / 2, this.y, true));
            this.cooldown = FIRE_COOLDOWN;
            audioSys.shoot();
        }

        // Invincibility blink
        if (this.invincibleTimer > 0) this.invincibleTimer--;
    }

    draw() {
        if (this.isDead) return;

        if (this.invincibleTimer > 0 && Math.floor(frameCount / 4) % 2 === 0) return; // Blink effect

        ctx.fillStyle = COLORS.player;
        
        // Draw Fighter Jet Shape using paths
        ctx.beginPath();
        ctx.moveTo(this.x + this.width/2, this.y); // Nose
        ctx.lineTo(this.x + this.width, this.y + this.height); // Right Wing tip
        ctx.lineTo(this.x + this.width/2, this.y + this.height - 10); // Center engine
        ctx.lineTo(this.x, this.y + this.height); // Left Wing tip
        ctx.closePath();
        ctx.fill();

        // Engine flame
        ctx.fillStyle = '#ff9900';
        ctx.beginPath();
        ctx.moveTo(this.x + this.width/2 - 5, this.y + this.height - 5);
        ctx.lineTo(this.x + this.width/2 + 5, this.y + this.height - 5);
        ctx.lineTo(this.x + this.width/2, this.y + this.height + (Math.random() * 10 + 5));
        ctx.fill();
    }

    hit() {
        if (this.invincibleTimer > 0) return;
        
        createExplosion(this.x + this.width/2, this.y + this.height/2, COLORS.player, 30);
        audioSys.explosion();
        lives--;
        updateHUD();

        if (lives <= 0) {
            this.isDead = true;
            setTimeout(endGame, 1000);
        } else {
            this.invincibleTimer = 120; // 2 seconds at 60fps
            this.x = CANVAS_WIDTH / 2 - this.width / 2; // Respawn center
        }
    }
}

class Enemy {
    constructor(gridX, gridY, type) {
        this.gridX = gridX; // Grid column index
        this.gridY = gridY; // Grid row index
        
        // Determine properties based on type (0=Top/Red, 1=Mid/Green, 2=Bot/Yellow)
        this.type = type;
        if (type === 0) { this.color = COLORS.enemyA; this.score = 80; }
        else if (type === 1) { this.color = COLORS.enemyB; this.score = 40; }
        else { this.color = COLORS.enemyC; this.score = 20; }

        this.width = 30;
        this.height = 24;
        
        // Formation offsets
        this.startX = gridX * 45 + 50;
        this.startY = gridY * 40 + 60;

        this.x = this.startX;
        this.y = -100 - (gridY * 50); // Start off screen for entry animation
        
        this.state = 'ENTERING'; // ENTERING, FORMATION, DIVING, RETURNING
        this.divePath = [];
        this.pathIndex = 0;
        
        // Animation frames
        this.animFrame = 0;
    }

    update(globalXOffset) {
        this.animFrame++;

        if (this.state === 'ENTERING') {
            // Move to grid position
            const targetY = this.startY + Math.sin(frameCount * 0.02) * 10; // Idle bobbing
            if (this.y < this.startY) {
                this.y += 2;
            } else {
                this.state = 'FORMATION';
            }
        } 
        else if (this.state === 'FORMATION') {
            // Move with the group
            this.x = this.startX + globalXOffset;
            this.y = this.startY;

            // Random chance to dive
            // Lower rows dive more often, higher levels dive more often
            let diveChance = 0.002 + (level * 0.001);
            if (this.type === 2) diveChance *= 1.5; // Bottom row dives more

            if (Math.random() < diveChance && this.y > 0) {
                this.startDive();
            }
        } 
        else if (this.state === 'DIVING') {
            // Follow curve
            if (this.pathIndex < this.divePath.length) {
                const point = this.divePath[this.pathIndex];
                this.x = point.x;
                this.y = point.y;
                this.pathIndex++;
                
                // Shoot randomly while diving
                if (Math.random() < 0.03) {
                    enemyBullets.push(new Bullet(this.x + this.width/2, this.y + this.height, false));
                    audioSys.enemyShoot();
                }
            } else {
                this.state = 'RETURNING';
            }
        } 
        else if (this.state === 'RETURNING') {
            // Fly back to top
            this.y -= 5;
            this.x += (this.startX - this.x) * 0.05; // Slide x back towards grid
            
            // If reached top area, snap back to formation logic
            if (this.y < this.startY) {
                this.state = 'FORMATION';
                this.pathIndex = 0;
            }
        }
    }

    startDive() {
        this.state = 'DIVING';
        this.divePath = [];
        
        // Quadratic Bezier curve for dive
        // Start: Current Pos
        // Control: Below player but horizontally offset
        // End: Opposite side of screen
        
        const startX = this.x;
        const startY = this.y;
        
        // Target roughly near player X, bottom of screen Y
        const targetX = Math.random() * CANVAS_WIDTH; 
        const targetY = CANVAS_HEIGHT + 50;

        const controlX = (startX + targetX) / 2 + (Math.random() - 0.5) * 200;
        const controlY = CANVAS_HEIGHT / 2;

        // Generate points
        for (let t = 0; t <= 1; t += 0.02) {
            const invT = 1 - t;
            const x = invT * invT * startX + 2 * invT * t * controlX + t * t * targetX;
            const y = invT * invT * startY + 2 * invT * t * controlY + t * t * targetY;
            this.divePath.push({x, y});
        }
    }

    draw() {
        ctx.fillStyle = this.color;
        
        // Draw different shapes based on type
        const cx = this.x + this.width/2;
        const cy = this.y + this.height/2;

        ctx.save();
        ctx.translate(cx, cy);

        // Flap animation
        if (Math.floor(this.animFrame / 15) % 2 === 0) {
            ctx.scale(1.1, 0.9);
        } else {
            ctx.scale(1, 1);
        }

        if (this.type === 0) { 
            // Crab/Butterfly (Red)
            ctx.beginPath();
            ctx.arc(0, 2, 10, Math.PI, 0); // Top shell
            ctx.lineTo(-12, 12);
            ctx.lineTo(-5, 8);
            ctx.lineTo(0, 14); // Bottom spike
            ctx.lineTo(5, 8);
            ctx.lineTo(12, 12);
            ctx.fill();
            // Eyes
            ctx.fillStyle = 'black';
            ctx.fillRect(-4, -2, 2, 2);
            ctx.fillRect(2, -2, 2, 2);
        } 
        else if (this.type === 1) {
            // Bee (Green)
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.lineTo(8, 5);
            ctx.lineTo(12, 10); // Wing
            ctx.lineTo(4, 6);
            ctx.lineTo(-4, 6);
            ctx.lineTo(-12, 10); // Wing
            ctx.lineTo(-8, 5);
            ctx.fill();
        } 
        else {
            // Bug (Yellow)
            ctx.beginPath();
            ctx.moveTo(0, -8);
            ctx.bezierCurveTo(10, -5, 15, 5, 0, 12);
            ctx.bezierCurveTo(-15, 5, -10, -5, 0, -8);
            ctx.fill();
        }

        ctx.restore();
    }
}

// --- HELPER FUNCTIONS ---

function createExplosion(x, y, color, count = 10) {
    for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function checkCollisions() {
    // Player Bullets hitting Enemies
    bullets.forEach(bullet => {
        if (bullet.markedForDeletion) return;

        enemies.forEach(enemy => {
            // Simple AABB collision
            if (
                bullet.x < enemy.x + enemy.width &&
                bullet.x + bullet.width > enemy.x &&
                bullet.y < enemy.y + enemy.height &&
                bullet.y + bullet.height > enemy.y
            ) {
                // Hit!
                bullet.markedForDeletion = true;
                
                // Remove enemy (filter out later)
                enemy.markedForDeletion = true; 
                
                score += enemy.score * level;
                updateHUD();
                createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color);
                audioSys.explosion();

                console.log(`[Debug] Enemy Hit. Score: ${score}`);
            }
        });
    });

    // Enemy Bullets hitting Player
    if (!player.isDead && player.invincibleTimer <= 0) {
        enemyBullets.forEach(bullet => {
            if (bullet.markedForDeletion) return;

            if (
                bullet.x < player.x + player.width &&
                bullet.x + bullet.width > player.x &&
                bullet.y < player.y + player.height &&
                bullet.y + bullet.height > player.y
            ) {
                bullet.markedForDeletion = true;
                player.hit();
            }
        });
        
        // Enemies crashing into player
        enemies.forEach(enemy => {
             if (
                enemy.x < player.x + player.width &&
                enemy.x + enemy.width > player.x &&
                enemy.y < player.y + player.height &&
                enemy.y + enemy.height > player.y
            ) {
                enemy.markedForDeletion = true;
                createExplosion(enemy.x, enemy.y, enemy.color);
                player.hit();
            }
        });
    }

    // Cleanup
    bullets = bullets.filter(b => !b.markedForDeletion);
    enemyBullets = enemyBullets.filter(b => !b.markedForDeletion);
    
    const prevCount = enemies.length;
    enemies = enemies.filter(e => !e.markedForDeletion);
    
    if (prevCount > 0 && enemies.length === 0) {
        nextLevel();
    }
}

function initLevel() {
    enemies = [];
    bullets = [];
    enemyBullets = [];
    
    // Grid Formation: 5 Rows, 8 Columns
    for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 8; col++) {
            let type = 2; // Default yellow
            if (row === 0) type = 0; // Red top
            else if (row < 3) type = 1; // Green mid
            
            enemies.push(new Enemy(col, row, type));
        }
    }
    
    console.log(`[Debug] Level ${level} Initialized. Enemies: ${enemies.length}`);
}

function nextLevel() {
    level++;
    audioSys.start();
    
    // Show small message or just pause briefly
    setTimeout(() => {
        initLevel();
    }, 1000);
}

function updateHUD() {
    document.getElementById('scoreDisplay').innerText = `SCORE: ${score}`;
    document.getElementById('livesDisplay').innerText = `LIVES: ${lives}`;
}

// --- MAIN LOOP ---

let swarmDirection = 1; // 1 = right, -1 = left
let swarmXOffset = 0;

function gameLoop() {
    if (gameState === 'PLAYING') {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        frameCount++;

        // Update Background Stars
        stars.forEach(star => { star.update(); star.draw(); });

        // Calculate Swarm Movement (Swaying)
        swarmXOffset += Math.sin(frameCount * 0.02) * 1.5;

        // Update Player
        player.update();
        player.draw();

        // Update Enemies
        enemies.forEach(enemy => {
            enemy.update(swarmXOffset);
            enemy.draw();
        });

        // Update Bullets
        bullets.forEach(b => { b.update(); b.draw(); });
        enemyBullets.forEach(b => { b.update(); b.draw(); });

        // Update Particles
        particles.forEach((p, index) => {
            p.update();
            p.draw();
            if (p.life <= 0) particles.splice(index, 1);
        });

        checkCollisions();
    } else {
        // Even in menu, draw stars for effect
        ctx.fillStyle = 'rgba(13, 14, 21, 0.3)';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        stars.forEach(star => { star.update(); star.draw(); });
    }

    requestAnimationFrame(gameLoop);
}

// --- INITIALIZATION & EVENT LISTENERS ---

function startGame() {
    score = 0;
    lives = 3;
    level = 1;
    gameState = 'PLAYING';
    
    player = new Player();
    initLevel();
    updateHUD();

    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    
    audioSys.start();
    console.log("[Debug] Game Started");
}

function endGame() {
    gameState = 'GAMEOVER';
    document.getElementById('finalScore').innerText = score;
    document.getElementById('gameOverScreen').classList.remove('hidden');
    console.log("[Debug] Game Over");
}

// Keyboard
window.addEventListener('keydown', e => {
    if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) {
        keys[e.key] = true;
        if(e.code === 'Space') keys.Space = true;
    }
});

window.addEventListener('keyup', e => {
    if (keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) {
        keys[e.key] = false;
        if(e.code === 'Space') keys.Space = false;
    }
});

// Touch Controls
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnFire = document.getElementById('btnFire');

const addTouch = (elem, code) => {
    elem.addEventListener('touchstart', (e) => { e.preventDefault(); keys[code] = true; });
    elem.addEventListener('touchend', (e) => { e.preventDefault(); keys[code] = false; });
};

addTouch(btnLeft, 'ArrowLeft');
addTouch(btnRight, 'ArrowRight');
addTouch(btnFire, 'Space'); // Map fire button to space logic

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

// Initialize Starfield
for(let i=0; i<50; i++) stars.push(new Star());

// Start Loop
requestAnimationFrame(gameLoop);

</script>
</body>
</html>