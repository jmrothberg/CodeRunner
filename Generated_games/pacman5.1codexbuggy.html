<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pac-Man 1980 Recreation</title>
<style>
    html, body {
        height: 100%;
        margin: 0;
        background: #000;
        font-family: 'Press Start 2P', monospace, sans-serif;
        color: #ffe600;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    canvas {
        border: 12px solid #000;
        box-shadow: 0 0 40px #0011ff;
        background: #000;
    }
    @font-face {
        font-family: 'Press Start 2P';
        src: url('https://fonts.gstatic.com/s/pressstart2p/v14/e3t4euO8T-267oIAQAu6jDQyK3nVivKIg7Y.woff2') format('woff2');
    }
</style>
</head>
<body>
<canvas id="game" width="448" height="576"></canvas>

<script>
/* ===============================
   PAC-MAN 1980 RECREATION
   =============================== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const TILE = 16; // Grid size (28x36)
const ROWS = 36;
const COLS = 28;

const COLORS = {
    wall: '#001eff',
    dot: '#fff9c4',
    pellet: '#ffdd57',
    pacman: '#ffe600',
    blinky: '#ff0000',
    pinky: '#ffb8ff',
    inky:  '#00ffff',
    clyde: '#ffb852',
    vulnerable: '#1b75fe',
    eyes: '#ffffff'
};

// Sound placeholders (replace with actual audio paths if available)
const sounds = {
    intro: new Audio(''),
    waka: new Audio(''),
    eatGhost: new Audio(''),
    eatFruit: new Audio(''),
    power: new Audio(''),
    death: new Audio('')
};
Object.values(sounds).forEach(sound => sound.volume = 0.4);

// Maze layout (0 empty, 1 wall, 2 dot, 3 power pellet)
const maze = [
/* 28 columns per row, 36 rows */
"1111111111111111111111111111",
"1666666666666616666666666661",
"1611116111111616111116111161",
"1311116111111616111116111131",
"1611116111111616111116111161",
"1666666666666666666666666661",
"1611111611111111111611111161",
"1611111611111111111611111161",
"1666666666111111666666666661",
"1111111611111111111611111111",
"0000011616666666611610000000",
"1111111616111111611611111111",
"6666661616111111611666666666",
"1111111616666666611611111111",
"0000011611111111611610000000",
"1111111611111111611611111111",
"1666666666666666666666666661",
"1611111611111611111611111161",
"1611111611111611111611111161",
"1366666611111111666666631131",
"1611111111111111111111111161",
"1611111111111111111111111161",
"1666666666111111666666666661",
"1111111611111111111611111111",
"0000011616666666611610000000",
"1111111616111111611611111111",
"6666661616111111611666666666",
"1111111616666666611611111111",
"0000011611111111611610000000",
"1111111611111111611611111111",
"1666666666666666666666666661",
"1611116111111111111116111161",
"1311116111111111111116111131",
"1611116111111111111116111161",
"1666666666666666666666666661",
"1111111111111111111111111111"
].map(row => row.split('').map(Number));

const DOT_COUNT = maze.flat().filter(v => v === 2).length + maze.flat().filter(v => v === 3).length;

const directions = {
    up:    {x: 0, y: -1, angle: 1.5*Math.PI},
    down:  {x: 0, y: 1,  angle: 0.5*Math.PI},
    left:  {x: -1,y: 0,  angle: Math.PI},
    right: {x: 1, y: 0,  angle: 0}
};

let state = {
    level: 1,
    score: 0,
    lives: 3,
    dotsEaten: 0,
    powerMode: false,
    powerTimer: 0,
    fruitTimer: 0,
    fruitActive: false,
    fruitPos: {x: 13, y: 17},
    inPlay: false,
    mouthAngle: 0
};

const pacman = {
    x: 13.5,
    y: 26,
    dir: directions.left,
    nextDir: directions.left,
    speed: 0.09,
    alive: true
};

function createGhost(name, color, scatterTarget) {
    return {
        name,
        color,
        x: 13.5,
        y: 14,
        dir: directions.left,
        speed: 0.08,
        mode: 'scatter', // chase/scatter/flee/eyes
        scatterTarget,
        target: scatterTarget,
        corner: scatterTarget
    };
}

const ghosts = [
    createGhost('Blinky', COLORS.blinky, {x: 25, y: 0}),
    createGhost('Pinky',  COLORS.pinky,  {x: 2,  y: 0}),
    createGhost('Inky',   COLORS.inky,   {x: 27, y: 35}),
    createGhost('Clyde',  COLORS.clyde,  {x: 0,  y: 35})
];

const scatterSchedule = [
    {mode: 'scatter', duration: 7},
    {mode: 'chase',   duration: 20},
    {mode: 'scatter', duration: 7},
    {mode: 'chase',   duration: 20},
    {mode: 'scatter', duration: 5},
    {mode: 'chase',   duration: 20},
    {mode: 'scatter', duration: 5},
    {mode: 'chase',   duration: Infinity}
];
let scheduleIndex = 0;
let modeTimer = 0;

// Input handling
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.key] = true;
    switch(e.key) {
        case 'ArrowUp': pacman.nextDir = directions.up; break;
        case 'ArrowDown': pacman.nextDir = directions.down; break;
        case 'ArrowLeft': pacman.nextDir = directions.left; break;
        case 'ArrowRight': pacman.nextDir = directions.right; break;
        case ' ': if (!state.inPlay) startRound(); break;
    }
});
window.addEventListener('keyup', e => keys[e.key] = false);

function startRound(resetPositions = true) {
    if (state.lives <= 0) {
        resetGame();
        return;
    }
    state.inPlay = true;
    state.powerMode = false;
    state.powerTimer = 0;
    state.fruitTimer = 0;
    state.fruitActive = false;
    state.dotsEaten = 0;
    state.mouthAngle = 0;
    scheduleIndex = 0;
    modeTimer = 0;
    if (resetPositions) {
        pacman.x = 13.5;
        pacman.y = 26;
        pacman.dir = directions.left;
        pacman.nextDir = directions.left;
        pacman.alive = true;
        ghosts[0].x = 13.5; ghosts[0].y = 14; ghosts[0].mode = 'scatter';
        ghosts[1].x = 14.5; ghosts[1].y = 14; ghosts[1].mode = 'scatter';
        ghosts[2].x = 13.5; ghosts[2].y = 16; ghosts[2].mode = 'scatter';
        ghosts[3].x = 14.5; ghosts[3].y = 16; ghosts[3].mode = 'scatter';
    }
    // Optionally play intro
    // sounds.intro.play();
}

function resetGame() {
    state.level = 1;
    state.score = 0;
    state.lives = 3;
    recreateDots();
    startRound(true);
}

function recreateDots() {
    // reset dots/pellets
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            let char = maze[r][c];
            if (char === 0) {
                // Restore dot or pellet depending on original map
                if (originalMaze[r][c] === 2) maze[r][c] = 2;
                if (originalMaze[r][c] === 3) maze[r][c] = 3;
            }
        }
    }
}

const originalMaze = maze.map(row => row.slice());

function gameLoop(timestamp) {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

function update() {
    if (!state.inPlay) return;
    updatePacman();
    updateGhostModes();
    ghosts.forEach(updateGhost);
    checkCollisions();
    updateFruit();
}

function updatePacman() {
    // Align to grid
    if (canMove(pacman, pacman.nextDir)) {
        pacman.dir = pacman.nextDir;
    } else if (!canMove(pacman, pacman.dir)) {
        return;
    }
    pacman.x += pacman.dir.x * pacman.speed;
    pacman.y += pacman.dir.y * pacman.speed;

    // Wrap tunnels
    if (pacman.x < -1) pacman.x = COLS;
    if (pacman.x > COLS) pacman.x = -1;

    eatTile(Math.round(pacman.y), Math.round(pacman.x));

    state.mouthAngle += 0.15;
}

function canMove(entity, dir) {
    const nextX = entity.x + dir.x * 0.5;
    const nextY = entity.y + dir.y * 0.5;
    const col = Math.floor(nextX);
    const row = Math.floor(nextY);
    if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return true;
    return maze[row][col] !== 1;
}

function eatTile(row, col) {
    const tile = maze[row][col];
    if (tile === 2) {
        maze[row][col] = 0;
        state.score += 10;
        state.dotsEaten++;
        sounds.waka.play();
    } else if (tile === 3) {
        maze[row][col] = 0;
        state.score += 50;
        state.powerMode = true;
        state.powerTimer = 6;
        ghosts.forEach(g => {
            if (g.mode !== 'eyes') g.mode = 'flee';
        });
        sounds.power.play();
    }
    if (state.dotsEaten >= DOT_COUNT) {
        state.level++;
        recreateDots();
        startRound(true);
    }
}

function updateGhostModes() {
    modeTimer += 1/60;
    if (modeTimer >= scatterSchedule[scheduleIndex].duration) {
        modeTimer = 0;
        scheduleIndex = Math.min(scheduleIndex + 1, scatterSchedule.length - 1);
        const newMode = scatterSchedule[scheduleIndex].mode;
        ghosts.forEach(g => {
            if (g.mode !== 'eyes' && g.mode !== 'flee') g.mode = newMode;
        });
    }
    if (state.powerMode) {
        state.powerTimer -= 1/60;
        if (state.powerTimer <= 0) {
            state.powerMode = false;
            ghosts.forEach(g => {
                if (g.mode === 'flee') g.mode = scatterSchedule[scheduleIndex].mode;
            });
        }
    }
}

function updateGhost(ghost) {
    if (ghost.mode === 'flee') ghost.speed = 0.06;
    else if (ghost.mode === 'eyes') ghost.speed = 0.12;
    else ghost.speed = 0.08;

    // Determine target tile
    switch(ghost.name) {
        case 'Blinky':
            ghost.target = {x: Math.round(pacman.x), y: Math.round(pacman.y)};
            break;
        case 'Pinky':
            ghost.target = {
                x: Math.round(pacman.x) + pacman.dir.x * 4,
                y: Math.round(pacman.y) + pacman.dir.y * 4
            };
            break;
        case 'Inky':
            const ahead = {
                x: Math.round(pacman.x) + pacman.dir.x * 2,
                y: Math.round(pacman.y) + pacman.dir.y * 2
            };
            const blinky = ghosts[0];
            ghost.target = {
                x: ahead.x * 2 - Math.round(blinky.x),
                y: ahead.y * 2 - Math.round(blinky.y)
            };
            break;
        case 'Clyde':
            const distance = Math.hypot(ghost.x - pacman.x, ghost.y - pacman.y);
            if (distance > 8) ghost.target = {x: Math.round(pacman.x), y: Math.round(pacman.y)};
            else ghost.target = ghost.corner;
            break;
    }
    if (ghost.mode === 'scatter') ghost.target = ghost.scatterTarget;
    if (ghost.mode === 'flee') ghost.target = {x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS)};
    if (ghost.mode === 'eyes') ghost.target = {x: 13.5, y: 14};

    moveGhost(ghost);
}

function moveGhost(ghost) {
    const options = [];
    for (const dir of Object.values(directions)) {
        const nextX = ghost.x + dir.x * 0.5;
        const nextY = ghost.y + dir.y * 0.5;
        const col = Math.floor(nextX);
        const row = Math.floor(nextY);
        if (dir.x === -ghost.dir.x && dir.y === -ghost.dir.y) continue; // no reverse
        if (col < 0 || col >= COLS || row < 0 || row >= ROWS || maze[row][col] === 1) continue;
        options.push({dir, nextX, nextY});
    }
    if (options.length === 0) return;

    let best = options[0];
    let bestDist = Infinity;
    options.forEach(opt => {
        const dist = Math.hypot(opt.nextX - ghost.target.x, opt.nextY - ghost.target.y);
        if (dist < bestDist) { bestDist = dist; best = opt; }
    });
    ghost.dir = best.dir;
    ghost.x += ghost.dir.x * ghost.speed;
    ghost.y += ghost.dir.y * ghost.speed;

    if (ghost.x < -1) ghost.x = COLS;
    if (ghost.x > COLS) ghost.x = -1;

    // Reaching pen center in eyes mode
    if (ghost.mode === 'eyes' && Math.hypot(ghost.x - 13.5, ghost.y - 14) < 0.3) {
        ghost.mode = scatterSchedule[scheduleIndex].mode;
    }
}

function checkCollisions() {
    ghosts.forEach(ghost => {
        const distance = Math.hypot(ghost.x - pacman.x, ghost.y - pacman.y);
        if (distance < 0.5) {
            if (ghost.mode === 'flee') {
                ghost.mode = 'eyes';
                state.score += 200;
                sounds.eatGhost.play();
            } else if (ghost.mode !== 'eyes') {
                loseLife();
            }
        }
    });
}

function loseLife() {
    state.lives--;
    pacman.alive = false;
    sounds.death.play();
    if (state.lives >= 0) {
        setTimeout(() => startRound(true), 2000);
    } else {
        state.inPlay = false;
    }
}

function updateFruit() {
    state.fruitTimer += 1/60;
    if (!state.fruitActive && state.fruitTimer > 15) {
        state.fruitActive = true;
        state.fruitTimer = 0;
    } else if (state.fruitActive && state.fruitTimer > 10) {
        state.fruitActive = false;
        state.fruitTimer = 0;
    }
    if (state.fruitActive && Math.hypot(pacman.x - state.fruitPos.x, pacman.y - state.fruitPos.y) < 0.5) {
        state.score += 100;
        state.fruitActive = false;
        sounds.eatFruit.play();
    }
}

/* ---------- DRAWING ---------- */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMaze();
    drawDots();
    drawFruit();
    drawGhosts();
    drawPacman();
    drawHUD();
    if (!state.inPlay) drawStartScreen();
}

function drawMaze() {
    ctx.strokeStyle = COLORS.wall;
    ctx.lineWidth = 2;
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (maze[r][c] === 1) {
                ctx.strokeRect(c*TILE, r*TILE, TILE, TILE);
            }
        }
    }
    // Ghost house door
    ctx.strokeStyle = '#ff9c9c';
    ctx.beginPath();
    ctx.moveTo(12*TILE, 14*TILE);
    ctx.lineTo(15*TILE, 14*TILE);
    ctx.stroke();
}

function drawDots() {
    ctx.fillStyle = COLORS.dot;
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (maze[r][c] === 2) {
                ctx.beginPath();
                ctx.arc(c*TILE + TILE/2, r*TILE + TILE/2, 2.5, 0, Math.PI*2);
                ctx.fill();
            }
            if (maze[r][c] === 3) {
                ctx.fillStyle = COLORS.pellet;
                ctx.beginPath();
                ctx.arc(c*TILE + TILE/2, r*TILE + TILE/2, 6, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = COLORS.dot;
            }
        }
    }
}

function drawPacman() {
    ctx.save();
    ctx.translate(pacman.x*TILE + TILE/2, pacman.y*TILE + TILE/2);
    ctx.rotate(pacman.dir.angle);
    const mouth = Math.abs(Math.sin(state.mouthAngle)) * 0.4;
    ctx.fillStyle = COLORS.pacman;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, TILE/2 - 1, mouth, Math.PI*2 - mouth);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function drawGhosts() {
    ghosts.forEach(ghost => {
        ctx.save();
        ctx.translate(ghost.x*TILE + TILE/2, ghost.y*TILE + TILE/2);
        if (ghost.mode === 'flee') ctx.fillStyle = COLORS.vulnerable;
        else if (ghost.mode === 'eyes') ctx.fillStyle = COLORS.eyes;
        else ctx.fillStyle = ghost.color;

        const bodyWidth = TILE - 2;
        const bodyHeight = TILE - 4;
        const wave = Math.sin(Date.now()/200 + ghost.x)*2;

        ctx.beginPath();
        ctx.arc(0, -bodyHeight/4, bodyWidth/2, Math.PI, 0);
        ctx.lineTo(bodyWidth/2, bodyHeight/2);
        for (let i = 2; i >= -2; i--) {
            ctx.quadraticCurveTo((i+0.5)*bodyWidth/5, bodyHeight/2 + wave, i*bodyWidth/5, bodyHeight/2);
        }
        ctx.closePath();
        ctx.fill();

        if (ghost.mode !== 'eyes') {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-5, -4, 4, 0, Math.PI*2);
            ctx.arc(5, -4, 4, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#00f';
            ctx.beginPath();
            ctx.arc(-5 + ghost.dir.x*2, -4 + ghost.dir.y*2, 2, 0, Math.PI*2);
            ctx.arc(5 + ghost.dir.x*2, -4 + ghost.dir.y*2, 2, 0, Math.PI*2);
            ctx.fill();
        } else {
            ctx.fillStyle = '#00f';
            ctx.beginPath();
            ctx.arc(-5, -4, 3, 0, Math.PI*2);
            ctx.arc(5, -4, 3, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
    });
}

function drawFruit() {
    if (!state.fruitActive) return;
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(state.fruitPos.x*TILE + TILE/2, state.fruitPos.y*TILE + TILE/2, 6, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#008000';
    ctx.fillRect(state.fruitPos.x*TILE + TILE/2 - 1, state.fruitPos.y*TILE + TILE/2 - 10, 2, 6);
}

function drawHUD() {
    ctx.fillStyle = '#ffe600';
    ctx.font = '16px "Press Start 2P"';
    ctx.fillText(`SCORE  ${state.score.toString().padStart(6, '0')}`, 16, 24);
    ctx.fillText(`LEVEL ${state.level}`, 16, 48);
    ctx.fillText(`LIVES`, canvas.width - 120, 24);

    for (let i = 0; i < state.lives; i++) {
        ctx.fillStyle = COLORS.pacman;
        ctx.beginPath();
        ctx.arc(canvas.width - 90 + i*24, 36, 10, 0.2*Math.PI, 1.8*Math.PI);
        ctx.lineTo(canvas.width - 90 + i*24, 36);
        ctx.fill();
    }
}

function drawStartScreen() {
    ctx.fillStyle = '#ffe600';
    ctx.font = '20px "Press Start 2P"';
    ctx.fillText('PAC-MAN', canvas.width/2 - 70, canvas.height/2 - 40);
    ctx.font = '14px "Press Start 2P"';
    ctx.fillText('PRESS SPACE TO START', canvas.width/2 - 150, canvas.height/2 + 10);
}
</script>
</body>
</html>