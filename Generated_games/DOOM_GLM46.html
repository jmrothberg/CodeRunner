 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raycasting FPS - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            cursor: crosshair;
        }
        
        #gameCanvas {
            display: block;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #weaponDisplay {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffff00;
            font-size: 24px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9);
            z-index: 100;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 101;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
        }
        
        #crosshair::before {
            width: 2px;
            height: 10px;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            width: 10px;
            height: 2px;
            left: -12px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        #weaponSelect {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
       
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            border: 2px solid #00ff00;
            background: rgba(0, 0, 0, 0.8);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            z-index: 102;
        }
        
        
        .flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(255,255,200,0.3) 0%, transparent 50%);
            pointer-events: none;
            opacity: 0;
            z-index: 99;
        }
        
        .damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(255,0,0,0.4) 0%, transparent 50%);
            pointer-events: none;
            opacity: 0;
            z-index: 98;
        }
    </style>
</head>
<body>
    <div id="gameCanvas"></div>
    
    <div id="hud">
        Health: <span id="health">100</span><br>
        Ammo: <span id="ammo">∞</span><br>
        Score: <span id="score">0</span><br>
        Enemies: <span id="enemyCount">0</span>
    </div>
    
    <div id="weaponDisplay">
        <span id="currentWeapon">PISTOL</span>
    </div>
    
    <div id="weaponSelect">
        [1] Pistol [2] Shotgun [3] Chaingun [4] Rocket Launcher
    </div>
    
    <div id="crosshair"></div>
    <div class="flash" id="muzzleFlash"></div>
    <div class="damage-flash" id="damageFlash"></div>
    <canvas id="minimap" width="200" height="200"></canvas>
\
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        const config = {
            mapSize: 20,
            cellSize: 10,
            playerSpeed: 0.3,
            mouseSensitivity: 0.002,
            enemySpeed: 0.05,
            enemyDamage: 5,
            enemyAttackRange: 8,
            weaponDamage: {
                pistol: 25,
                shotgun: 60,
                chaingun: 15,
                rocket: 100
            },
            weaponFireRate: {
                pistol: 300,
                shotgun: 800,
                chaingun: 100,
                rocket: 1200
            },
            weaponAmmo: {
                pistol: Infinity,
                shotgun: 24,
                chaingun: 200,
                rocket: 8
            }
        };
        
        // Game State
        const gameState = {
            health: 100,
            score: 0,
            currentWeapon: 'pistol',
            ammo: { ...config.weaponAmmo },
            lastFireTime: 0,
            keys: {},
            mouse: { x: 0, y: 0 },
            isPointerLocked: false
        };
        
        // Map Layout (1 = wall, 0 = empty)
        const mapLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
            [1,0,1,0,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,0,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
            [1,1,1,0,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
            [1,0,1,0,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
            [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        // Three.js Setup
        let scene, camera, renderer;
        let walls = [];
        let enemies = [];
        let bullets = [];
        let particles = [];
        let raycaster, mouseVector;
        let minimapCanvas, minimapCtx;
        const minimapConfig = {
            size: 200,
            scale: 10
             };
        // Initialize Three.js Scene
        
        
        
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x444444, 20, 100); // Much lighter fog
            
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(config.cellSize * 2, 5, config.cellSize * 2);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x666666); // Lighter background color
            document.getElementById('gameCanvas').appendChild(renderer.domElement);
            
            raycaster = new THREE.Raycaster();
            mouseVector = new THREE.Vector2();
        }
        
        // Add this function after initThreeJS
         function initMinimap() {
                minimapCanvas = document.getElementById('minimap');
                minimapCtx = minimapCanvas.getContext('2d');
                console.log('Minimap initialized');
                 }
        
        // Add this function before createLighting
        
        function drawMinimap() {
                if (!minimapCtx) return;
    
                const cellSize = minimapConfig.size / config.mapSize;
    
                // Clear canvas with lighter background
                minimapCtx.fillStyle = 'rgba(20, 20, 20, 0.9)';
                minimapCtx.fillRect(0, 0, minimapConfig.size, minimapConfig.size);
    
                // Draw map layout
                for (let z = 0; z < config.mapSize; z++) {
                    for (let x = 0; x < config.mapSize; x++) {
                        if (mapLayout[z][x] === 1) {
                            // Walls - lighter gray
                            minimapCtx.fillStyle = '#666666';
                            minimapCtx.fillRect(x * cellSize, z * cellSize, cellSize, cellSize);
                
                            // Wall borders
                            minimapCtx.strokeStyle = '#888888';
                            minimapCtx.lineWidth = 1;
                            minimapCtx.strokeRect(x * cellSize, z * cellSize, cellSize, cellSize);
                        } else {
                            // Floor - lighter color
                            minimapCtx.fillStyle = '#333333';
                            minimapCtx.fillRect(x * cellSize, z * cellSize, cellSize, cellSize);
                        }
                    }
                }
    
                // Draw grid lines
                minimapCtx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                minimapCtx.lineWidth = 0.5;
                for (let i = 0; i <= config.mapSize; i++) {
                    minimapCtx.beginPath();
                    minimapCtx.moveTo(i * cellSize, 0);
                    minimapCtx.lineTo(i * cellSize, minimapConfig.size);
                    minimapCtx.stroke();
        
                    minimapCtx.beginPath();
                    minimapCtx.moveTo(0, i * cellSize);
                    minimapCtx.lineTo(minimapConfig.size, i * cellSize);
                    minimapCtx.stroke();
                }
    
                // Convert world coordinates to minimap coordinates
                function worldToMinimap(worldX, worldZ) {
                    const mapCenter = (config.mapSize * config.cellSize) / 2;
                    const miniX = ((worldX + mapCenter) / config.cellSize) * cellSize;
                    const miniY = ((worldZ + mapCenter) / config.cellSize) * cellSize;
                    return { x: miniX, y: miniY };
                }
    
                // Draw enemies
                enemies.forEach(enemy => {
                    const pos = worldToMinimap(enemy.mesh.position.x, enemy.mesh.position.z);
        
                    // Pulsing red enemy dots
                    const pulse = Math.sin(Date.now() * 0.005) * 2 + 4;
                    minimapCtx.fillStyle = '#ff0000';
                    minimapCtx.beginPath();
                    minimapCtx.arc(pos.x, pos.y, pulse, 0, Math.PI * 2);
                    minimapCtx.fill();
        
                    // Enemy glow
                    minimapCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    minimapCtx.lineWidth = 2;
                    minimapCtx.beginPath();
                    minimapCtx.arc(pos.x, pos.y, pulse + 3, 0, Math.PI * 2);
                    minimapCtx.stroke();
                });
    
                // Draw player
                const playerPos = worldToMinimap(camera.position.x, camera.position.z);
    
                // Green player dot
                minimapCtx.fillStyle = '#00ff00';
                minimapCtx.beginPath();
                minimapCtx.arc(playerPos.x, playerPos.y, 5, 0, Math.PI * 2);
                minimapCtx.fill();
    
                // Player direction indicator
                const dirLength = 15;
                const dirX = playerPos.x - Math.sin(camera.rotation.y) * dirLength;
                const dirY = playerPos.y - Math.cos(camera.rotation.y) * dirLength;
    
                minimapCtx.strokeStyle = '#00ff00';
                minimapCtx.lineWidth = 3;
                minimapCtx.beginPath();
                minimapCtx.moveTo(playerPos.x, playerPos.y);
                minimapCtx.lineTo(dirX, dirY);
                minimapCtx.stroke();
    
    // Player view cone
                minimapCtx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                minimapCtx.beginPath();
                minimapCtx.moveTo(playerPos.x, playerPos.y);
                const fovAngle = Math.PI / 4;
                const leftAngle = camera.rotation.y - fovAngle;
                const rightAngle = camera.rotation.y + fovAngle;
    
                for (let angle = leftAngle; angle <= rightAngle; angle += 0.1) {
                    const coneX = playerPos.x + Math.sin(angle) * 30;
                    const coneY = playerPos.y + Math.cos(angle) * 30;
                    minimapCtx.lineTo(coneX, coneY);
                }
                minimapCtx.closePath();
                minimapCtx.fill();
            }
        // Create Lighting - MUCH BRIGHTER NOW
        function createLighting() {
            // Strong ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Increased from 0.3 to 0.8
            scene.add(ambientLight);
            
            // Multiple directional lights for better illumination
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight1.position.set(10, 20, 10);
            directionalLight1.castShadow = true;
            directionalLight1.shadow.camera.left = -50;
            directionalLight1.shadow.camera.right = 50;
            directionalLight1.shadow.camera.top = 50;
            directionalLight1.shadow.camera.bottom = -50;
            scene.add(directionalLight1);
            
            // Additional fill light
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-10, 15, -10);
            scene.add(directionalLight2);
            
            // Player flashlight - brighter and wider
            const spotLight = new THREE.SpotLight(0xffffff, 1.5); // Increased intensity
            spotLight.position.copy(camera.position);
            spotLight.target.position.set(
                camera.position.x + Math.sin(camera.rotation.y) * 10,
                camera.position.y - 5,
                camera.position.z + Math.cos(camera.rotation.y) * 10
            );
            spotLight.angle = Math.PI / 4; // Wider angle
            spotLight.penumbra = 0.4;
            spotLight.decay = 1.5;
            spotLight.distance = 50;
            spotLight.castShadow = true;
            scene.add(spotLight);
            scene.add(spotLight.target);
            
            return spotLight;
        }
        
        // Create Textured Materials - BRIGHTER COLORS
        function createMaterials() {
            const textureLoader = new THREE.TextureLoader();
            
            // Create procedural wall texture - LIGHTER
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Lighter gray base
            ctx.fillStyle = '#b0b0b0'; // Changed from #808080 to #b0b0b0
            ctx.fillRect(0, 0, 256, 256);
            
            // Add brick pattern with lighter lines
            ctx.strokeStyle = '#909090'; // Lighter brick lines
            ctx.lineWidth = 2;
            for (let y = 0; y < 256; y += 32) {
                for (let x = 0; x < 256; x += 64) {
                    const offset = (y / 32) % 2 === 0 ? 0 : 32;
                    ctx.strokeRect(x + offset, y, 64, 32);
                }
            }
            
            // Add lighter noise
            for (let i = 0; i < 1000; i++) {
                ctx.fillStyle = `rgba(${150 + Math.random() * 50}, ${150 + Math.random() * 50}, ${150 + Math.random() * 50}, 0.3)`;
                ctx.fillRect(Math.random() * 256, Math.random() * 256, 2, 2);
            }
            
            const wallTexture = new THREE.CanvasTexture(canvas);
            wallTexture.wrapS = THREE.RepeatWrapping;
            wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(4, 4);
            
            const wallMaterial = new THREE.MeshPhongMaterial({
                map: wallTexture,
                normalScale: new THREE.Vector2(0.5, 0.5),
                color: 0xffffff // Ensure full brightness
            });
            
            // Floor material - MUCH LIGHTER
            const floorCanvas = document.createElement('canvas');
            floorCanvas.width = 256;
            floorCanvas.height = 256;
            const floorCtx = floorCanvas.getContext('2d');
            
            // Light concrete pattern
            floorCtx.fillStyle = '#606060'; // Changed from #2a2a2a to #606060
            floorCtx.fillRect(0, 0, 256, 256);
            
            for (let i = 0; i < 50; i++) {
                floorCtx.strokeStyle = `rgba(${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${100 + Math.random() * 50}, 0.5)`;
                floorCtx.beginPath();
                floorCtx.moveTo(Math.random() * 256, Math.random() * 256);
                floorCtx.lineTo(Math.random() * 256, Math.random() * 256);
                floorCtx.stroke();
            }
            
            const floorTexture = new THREE.CanvasTexture(floorCanvas);
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(20, 20);
            
            const floorMaterial = new THREE.MeshPhongMaterial({
                map: floorTexture,
                color: 0xffffff
            });
            
            // Ceiling material - LIGHTER
            const ceilingMaterial = new THREE.MeshPhongMaterial({
                color: 0x808080 // Changed from #1a1a1a to #808080
            });
            
            return { wallMaterial, floorMaterial, ceilingMaterial };
        }
        
        // Build the Map
        function buildMap() {
            const materials = createMaterials();
            
            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(
                config.mapSize * config.cellSize,
                config.mapSize * config.cellSize
            );
            const floor = new THREE.Mesh(floorGeometry, materials.floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Create ceiling
            const ceiling = new THREE.Mesh(floorGeometry, materials.ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 10;
            scene.add(ceiling);
            
            // Create walls
            for (let z = 0; z < config.mapSize; z++) {
                for (let x = 0; x < config.mapSize; x++) {
                    if (mapLayout[z][x] === 1) {
                        const wallGeometry = new THREE.BoxGeometry(
                            config.cellSize,
                            10,
                            config.cellSize
                        );
                        const wall = new THREE.Mesh(wallGeometry, materials.wallMaterial);
                        wall.position.set(
                            x * config.cellSize - (config.mapSize * config.cellSize) / 2 + config.cellSize / 2,
                            5,
                            z * config.cellSize - (config.mapSize * config.cellSize) / 2 + config.cellSize / 2
                        );
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        walls.push({
                            mesh: wall,
                            x: x,
                            z: z
                        });
                    }
                }
            }
        }
        
        // Create Enemy - BRIGHTER COLORS
        function createEnemy(x, z) {
            const enemyGeometry = new THREE.ConeGeometry(1.5, 4, 8);
            const enemyMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL(Math.random(), 0.9, 0.6), // Brighter colors
                emissive: new THREE.Color().setHSL(Math.random(), 0.9, 0.4), // Stronger glow
                emissiveIntensity: 0.5
            });
            
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.set(x, 2, z);
            enemy.castShadow = true;
            scene.add(enemy);
            
            // Add stronger glow effect
            const glowGeometry = new THREE.SphereGeometry(2.5, 8, 8); // Larger glow
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: enemyMaterial.color,
                transparent: true,
                opacity: 0.5 // More visible
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            enemy.add(glow);
            
            enemies.push({
                mesh: enemy,
                health: 50,
                speed: config.enemySpeed + Math.random() * 0.02,
                lastAttackTime: 0,
                attackCooldown: 2000
            });
        }
        
        // Spawn Enemies
        function spawnEnemies() {
            const spawnPoints = [
                { x: -80, z: -80 },
                { x: 80, z: -80 },
                { x: -80, z: 80 },
                { x: 80, z: 80 },
                { x: 0, z: -90 },
                { x: 0, z: 90 }
            ];
            
            for (let i = 0; i < 8; i++) {
                const spawn = spawnPoints[i % spawnPoints.length];
                createEnemy(
                    spawn.x + (Math.random() - 0.5) * 20,
                    spawn.z + (Math.random() - 0.5) * 20
                );
            }
            
            updateHUD();
        }
        
        // Create Bullet Effect
        function createBulletEffect(startPos, direction, weaponType) {
            const bulletGeometry = new THREE.SphereGeometry(weaponType === 'rocket' ? 0.5 : 0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({
                color: weaponType === 'rocket' ? 0xff4444 : 0xffff00,
                emissive: weaponType === 'rocket' ? 0xff0000 : 0xffff00
            });
            
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(startPos);
            scene.add(bullet);
            
            // Add trail effect for rockets
            if (weaponType === 'rocket') {
                const trailGeometry = new THREE.CylinderGeometry(0.2, 0.4, 2, 8);
                const trailMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.7
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                trail.position.y = -1;
                bullet.add(trail);
            }
            
            bullets.push({
                mesh: bullet,
                velocity: direction.multiplyScalar(weaponType === 'rocket' ? 0.5 : 2),
                damage: config.weaponDamage[weaponType],
                weaponType: weaponType,
                lifetime: 60
            });
        }
        
        // Create Explosion Effect - BRIGHTER
        function createExplosion(position) {
            const particleCount = 30;
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 1, 0.7), // Brighter particles
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                scene.add(particle);
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    lifetime: 30 + Math.random() * 20,
                    material: particleMaterial
                });
            }
            
            // Flash effect
            const flash = document.getElementById('muzzleFlash');
            flash.style.opacity = '1';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 100);
        }
        
        // Handle Shooting
        function shoot() {
            const now = Date.now();
            const fireRate = config.weaponFireRate[gameState.currentWeapon];
            
            if (now - gameState.lastFireTime < fireRate) return;
            
            if (gameState.ammo[gameState.currentWeapon] <= 0 && 
                gameState.ammo[gameState.currentWeapon] !== Infinity) {
                console.log('Out of ammo!');
                return;
            }
            
            gameState.lastFireTime = now;
            
            // Consume ammo
            if (gameState.ammo[gameState.currentWeapon] !== Infinity) {
                gameState.ammo[gameState.currentWeapon]--;
            }
            
            // Calculate shoot direction
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            // Create muzzle flash effect
            const flash = document.getElementById('muzzleFlash');
            flash.style.opacity = '0.5';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 50);
            
            // Handle different weapon types
            if (gameState.currentWeapon === 'shotgun') {
                // Shotgun fires multiple pellets
                for (let i = 0; i < 8; i++) {
                    const spread = (Math.random() - 0.5) * 0.2;
                    const pelletDirection = direction.clone();
                    pelletDirection.x += spread;
                    pelletDirection.z += spread;
                    pelletDirection.normalize();
                    
                    createBulletEffect(
                        camera.position.clone(),
                        pelletDirection,
                        'shotgun'
                    );
                }
            } else {
                createBulletEffect(
                    camera.position.clone(),
                    direction,
                    gameState.currentWeapon
                );
            }
            
            updateHUD();
        }
        
        // Check Collision
        function checkCollision(position, radius = 1) {
            const gridX = Math.floor((position.x + (config.mapSize * config.cellSize) / 2) / config.cellSize);
            const gridZ = Math.floor((position.z + (config.mapSize * config.cellSize) / 2) / config.cellSize);
            
            if (gridX < 0 || gridX >= config.mapSize || gridZ < 0 || gridZ >= config.mapSize) {
                return true;
            }
            
            // Check surrounding cells
            for (let dz = -1; dz <= 1; dz++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = gridX + dx;
                    const checkZ = gridZ + dz;
                    
                    if (checkX >= 0 && checkX < config.mapSize && 
                        checkZ >= 0 && checkZ < config.mapSize) {
                        if (mapLayout[checkZ][checkX] === 1) {
                            const wallCenterX = checkX * config.cellSize - (config.mapSize * config.cellSize) / 2 + config.cellSize / 2;
                            const wallCenterZ = checkZ * config.cellSize - (config.mapSize * config.cellSize) / 2 + config.cellSize / 2;
                            
                            const distance = Math.sqrt(
                                Math.pow(position.x - wallCenterX, 2) +
                                Math.pow(position.z - wallCenterZ, 2)
                            );
                            
                            if (distance < config.cellSize / 2 + radius) {
                                return true;
                            }
                        }
                    }
                }
            }
            
            return false;
        }
        
       // Update Player Movement - FIXED FOR PROPER RELATIVE MOVEMENT
        function updatePlayerMovement() {
            const moveVector = new THREE.Vector3();
    
            // Use arrow keys for movement
            if (gameState.keys['ArrowUp']) moveVector.z -= 1;    // Forward
            if (gameState.keys['ArrowDown']) moveVector.z += 1;  // Backward  
            if (gameState.keys['ArrowLeft']) moveVector.x -= 1;  // Strafe left
            if (gameState.keys['ArrowRight']) moveVector.x += 1; // Strafe right
    
            if (moveVector.length() > 0) {
                moveVector.normalize();
        
                // Get camera's forward and right vectors
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
        
                camera.getWorldDirection(forward);
                forward.y = 0; // Keep movement on horizontal plane
                forward.normalize();
        
                // Right vector is perpendicular to forward (cross product with up)
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
        
                // Calculate movement based on camera direction
                const movement = new THREE.Vector3();
                movement.addScaledVector(right, moveVector.x);    // Strafe
                movement.addScaledVector(forward, -moveVector.z); // Forward/Back (negative because forward is -Z in our input)
        
                const newPosition = camera.position.clone();
                newPosition.x += movement.x * config.playerSpeed;
                newPosition.z += movement.z * config.playerSpeed;
        
                // Check collision before moving
                if (!checkCollision(newPosition, 0.5)) {
                    camera.position.copy(newPosition);
                }
            }
        }
        
        // Update Enemies
        function updateEnemies() {
            const now = Date.now();
            
            enemies.forEach((enemy, index) => {
                if (enemy.health <= 0) {
                    scene.remove(enemy.mesh);
                    enemies.splice(index, 1);
                    gameState.score += 100;
                    
                    // Create death explosion
                    createExplosion(enemy.mesh.position);
                    
                    updateHUD();
                    return;
                }
                
                // Calculate direction to player
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, enemy.mesh.position);
                direction.y = 0; // Keep enemies on ground level
                direction.normalize();
                
                // Move towards player
                const newPosition = enemy.mesh.position.clone();
                newPosition.add(direction.multiplyScalar(enemy.speed));
                
                // Check collision for enemy movement
                if (!checkCollision(newPosition, 1.5)) {
                    enemy.mesh.position.copy(newPosition);
                }
                
                // Rotate enemy to face player
                enemy.mesh.lookAt(camera.position);
                
                // Animate enemy (bobbing effect)
                enemy.mesh.position.y = 2 + Math.sin(now * 0.005) * 0.2;
                
                // Check if close enough to attack
                const distance = enemy.mesh.position.distanceTo(camera.position);
                if (distance < config.enemyAttackRange && now - enemy.lastAttackTime > enemy.attackCooldown) {
                    enemy.lastAttackTime = now;
                    gameState.health -= config.enemyDamage;
                    
                    // Damage flash effect
                    const damageFlash = document.getElementById('damageFlash');
                    damageFlash.style.opacity = '0.5';
                    setTimeout(() => {
                        damageFlash.style.opacity = '0';
                    }, 200);
                    
                    if (gameState.health <= 0) {
                        gameState.health = 0;
                        console.log('Game Over!');
                        // Reset game or show game over screen
                    }
                    
                    updateHUD();
                }
            });
            
            // Spawn new enemies if too few remain
            if (enemies.length < 3 && Math.random() < 0.01) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 80 + Math.random() * 20;
                createEnemy(
                    Math.cos(angle) * distance,
                    Math.sin(angle) * distance
                );
            }
        }
        
        // Update Bullets
        function updateBullets() {
            bullets.forEach((bullet, index) => {
                bullet.mesh.position.add(bullet.velocity);
                bullet.lifetime--;
                
                // Check collision with walls
                if (checkCollision(bullet.mesh.position, 0.5)) {
                    scene.remove(bullet.mesh);
                    
                    if (bullet.weaponType === 'rocket') {
                        createExplosion(bullet.mesh.position);
                        
                        // Damage nearby enemies
                        enemies.forEach(enemy => {
                            const distance = enemy.mesh.position.distanceTo(bullet.mesh.position);
                            if (distance < 10) {
                                enemy.health -= bullet.damage * (1 - distance / 10);
                            }
                        });
                    }
                    
                    bullets.splice(index, 1);
                    return;
                }
                
                // Check collision with enemies
                enemies.forEach(enemy => {
                    const distance = enemy.mesh.position.distanceTo(bullet.mesh.position);
                    if (distance < 2) {
                        enemy.health -= bullet.damage;
                        
                        scene.remove(bullet.mesh);
                        
                        if (bullet.weaponType === 'rocket') {
                            createExplosion(bullet.mesh.position);
                            
                            // Damage nearby enemies
                            enemies.forEach(otherEnemy => {
                                const otherDistance = otherEnemy.mesh.position.distanceTo(bullet.mesh.position);
                                if (otherDistance < 10 && otherEnemy !== enemy) {
                                    otherEnemy.health -= bullet.damage * 0.5 * (1 - otherDistance / 10);
                                }
                            });
                        }
                        
                        bullets.splice(index, 1);
                    }
                });
                
                // Remove old bullets
                if (bullet.lifetime <= 0) {
                    scene.remove(bullet.mesh);
                    bullets.splice(index, 1);
                }
            });
        }
        
        // Update Particles
        function updateParticles() {
            particles.forEach((particle, index) => {
                particle.mesh.position.add(particle.velocity);
                particle.velocity.y -= 0.02; // Gravity
                particle.lifetime--;
                
                particle.material.opacity = particle.lifetime / 50;
                
                if (particle.lifetime <= 0) {
                    scene.remove(particle.mesh);
                    particles.splice(index, 1);
                }
            });
        }
        
        // Update HUD
        function updateHUD() {
            document.getElementById('health').textContent = gameState.health;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('enemyCount').textContent = enemies.length;
            
            const ammoDisplay = gameState.ammo[gameState.currentWeapon] === Infinity ? 
                '∞' : gameState.ammo[gameState.currentWeapon];
            document.getElementById('ammo').textContent = ammoDisplay;
            
            const weaponNames = {
                pistol: 'PISTOL',
                shotgun: 'SHOTGUN',
                chaingun: 'CHAINGUN',
                rocket: 'ROCKET LAUNCHER'
            };
            document.getElementById('currentWeapon').textContent = weaponNames[gameState.currentWeapon];
        }
        
        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayerMovement();
            updateEnemies();
            updateBullets();
            updateParticles();
            drawMinimap();
            renderer.render(scene, camera);
        }
        
        
        
        // Event Listeners
        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.code] = true;
                // Space bar to shoot
                if (e.code === 'Space') {
                    e.preventDefault();
                    shoot();
                }
                // Weapon switching
                if (e.code === 'Digit1') gameState.currentWeapon = 'pistol';
                if (e.code === 'Digit2') gameState.currentWeapon = 'shotgun';
                if (e.code === 'Digit3') gameState.currentWeapon = 'chaingun';
                if (e.code === 'Digit4') gameState.currentWeapon = 'rocket';
                
                updateHUD();
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.code] = false;
            });
            
            // Mouse controls
            document.addEventListener('click', () => {
                if (!gameState.isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                } else {
                    shoot();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                gameState.isPointerLocked = document.pointerLockElement === renderer.domElement;
            });
            
            document.addEventListener('mousemove', (e) => {
                if (gameState.isPointerLocked) {
                    camera.rotation.y -= e.movementX * config.mouseSensitivity;
                    camera.rotation.x -= e.movementY * config.mouseSensitivity;
                    
                    // Limit vertical rotation
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // Initialize Game
        function init() {
            console.log('Initializing Raycasting FPS...');
            
            initThreeJS();
            const spotLight = createLighting();
            buildMap();
            spawnEnemies();
            setupEventListeners();
            
            // Update spotlight position in animation loop
            setInterval(() => {
                if (spotLight) {
                    spotLight.position.copy(camera.position);
                    spotLight.target.position.set(
                        camera.position.x + Math.sin(camera.rotation.y) * 10,
                        camera.position.y - 5,
                        camera.position.z + Math.cos(camera.rotation.y) * 10
                    );
                }
            }, 16);
            
            animate();
            initMinimap();
            console.log('Game initialized successfully!');
        }
        
        // Start the game
        init();
    </script>
</body>
</html> 