<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clown Dig: Underground Chaos</title>
    <style>
        :root {
            --bg-color: #1a1510;
            --ui-bg: #2d241b;
            --accent: #ffcc00;
            --text-color: #f0e6d2;
            --danger: #ff4444;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            border: 4px solid var(--ui-bg);
            border-radius: 8px;
            background: linear-gradient(to bottom, #3e2723, #1a100c);
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        .life-container span {
            color: var(--danger);
            margin-right: 5px;
        }

        /* Screens (Start, Game Over, Win) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: var(--accent);
            text-shadow: 4px 4px 0 #d35400;
            letter-spacing: 2px;
            text-align: center;
        }

        p {
            font-size: 18px;
            max-width: 600px;
            text-align: center;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .btn {
            background: linear-gradient(to bottom, #e67e22, #d35400);
            border: none;
            padding: 15px 40px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 6px 0 #a04000, 0 10px 10px rgba(0,0,0,0.5);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #a04000, 0 4px 4px rgba(0,0,0,0.5);
        }

        .controls-info {
            display: grid;
            grid-template-columns: auto auto;
            gap: 10px 20px;
            text-align: left;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .key {
            background: #eee;
            color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-family: monospace;
            box-shadow: 0 2px 0 #bbb;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div class="hud-top">
            <div>SCORE: <span id="scoreVal">0</span></div>
            <div>LIVES: <span id="livesVal" class="life-container">❤️❤️❤️</span></div>
            <div>LEVEL: <span id="levelVal">1</span></div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="screen">
        <h1>CLOWN DIG</h1>
        <p>Descend into the depths! Dig tunnels, push apples to crush monsters, and use your trusty Powerball.</p>
        
        <div class="controls-info">
            <div><span class="key">Arrows</span></div><div>Move & Dig</div>
            <div><span class="key">Z</span> or <span class="key">Space</span></div><div>Throw Powerball</div>
        </div>

        <p style="font-size: 14px; color: #aaa;">Tip: Crush monsters with apples for big points. Collect letters E-X-T-R-A from Alpha Monsters for a bonus life!</p>
        
        <button class="btn" onclick="game.startLevel()">START GAME</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen hidden">
        <h1 style="color: var(--danger)">GAME OVER</h1>
        <p>The underground claimed you.</p>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="btn" onclick="game.resetGame()">TRY AGAIN</button>
    </div>

    <!-- Level Complete Screen -->
    <div id="levelScreen" class="screen hidden">
        <h1 style="color: #2ecc71">LEVEL CLEARED!</h1>
        <p>The monsters are gone.</p>
        <button class="btn" onclick="game.nextLevel()">NEXT LEVEL</button>
    </div>
    
    <!-- Victory Screen -->
    <div id="victoryScreen" class="screen hidden">
        <h1 style="color: var(--accent)">YOU WIN!</h1>
        <p>You have conquered the underground!</p>
        <p>Final Score: <span id="winScore">0</span></p>
        <button class="btn" onclick="game.resetGame()">PLAY AGAIN</button>
    </div>
</div>

<script>
/**
 * GAME ENGINE & LOGIC
 */

// Constants
const TILE_SIZE = 40;
const COLS = 20;
const ROWS = 15;
const GRAVITY = 0.5;
const MAX_SPEED = 4;

// Tile Types
const T_EMPTY = 0;
const T_DIRT = 1;
const T_ROCK = 2; // Indestructible border

// Entity Types
const E_PLAYER = 'player';
const E_MONSTER = 'monster';
const E_APPLE = 'apple';
const E_CHERRY = 'cherry';
const E_POWERBALL = 'powerball';

// Utility: Random Range
const rand = (min, max) => Math.random() * (max - min) + min;

// Input Handling
class InputHandler {
    constructor() {
        this.keys = {};
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);
    }
    
    isDown(code) { return !!this.keys[code]; }
    
    justPressed(code) {
        if (this.keys[code]) {
            this.keys[code] = false; // Consume event
            return true;
        }
        return false;
    }
}

// Particle System for effects
class Particle {
    constructor(x, y, color, speed, size, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.size = size;
        this.life = life;
        this.maxLife = life;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.size *= 0.95;
    }
    
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

// Base Entity Class
class Entity {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.width = TILE_SIZE - 4;
        this.height = TILE_SIZE - 4;
        this.type = type;
        this.vx = 0;
        this.vy = 0;
        this.markedForDeletion = false;
        
        // Animation properties
        this.frameX = 0;
        this.frameTimer = 0;
    }
    
    getBounds() {
        return { x: this.x + 2, y: this.y + 2, w: this.width - 4, h: this.height - 4 };
    }
    
    getCenter() {
        return { x: this.x + this.width/2, y: this.y + this.height/2 };
    }

    update(dt) {}
    draw(ctx) {}
}

// Player Class (The Clown)
class Player extends Entity {
    constructor(x, y) {
        super(x, y, E_PLAYER);
        this.speed = 3;
        this.facingRight = true;
        this.state = 'idle'; // idle, walk, dig
        this.digTimer = 0;
        this.invincibleTimer = 0;
        
        // Powerball logic
        this.hasPowerball = true;
        this.powerballCooldown = 0;
    }

    update(dt, map, input) {
        if (this.invincibleTimer > 0) this.invincibleTimer--;
        if (this.powerballCooldown > 0) this.powerballCooldown--;

        let dx = 0;
        let dy = 0;

        // Movement Input
        if (input.isDown('ArrowLeft')) { dx = -this.speed; this.facingRight = false; }
        else if (input.isDown('ArrowRight')) { dx = this.speed; this.facingRight = true; }
        else if (input.isDown('ArrowUp')) dy = -this.speed;
        else if (input.isDown('ArrowDown')) dy = this.speed;

        // Attempt Move
        if (dx !== 0 || dy !== 0) {
            this.state = 'walk';
            
            // Check dig interaction before moving
            const cx = Math.floor((this.x + this.width/2 + dx * 5) / TILE_SIZE);
            const cy = Math.floor((this.y + this.height/2 + dy * 5) / TILE_SIZE);

            if (cx >= 0 && cx < COLS && cy >= 0 && cy < ROWS) {
                if (map[cy][cx] === T_DIRT) {
                    // Digging
                    map[cy][cx] = T_EMPTY;
                    this.state = 'dig';
                    this.digTimer = 10;
                    game.spawnParticles(cx * TILE_SIZE + TILE_SIZE/2, cy * TILE_SIZE + TILE_SIZE/2, '#8d6e63', 5);
                    game.score += 10;
                }
            }

            // Apply movement with collision against rocks
            if (!this.move(dx, dy, map)) {
                // If horizontal move failed, try vertical (diagonal sliding)
                this.move(dx, 0, map); 
                if(!this.move(0, dy, map) && dx === 0) {
                     // Vertical push check for apples happens in Game loop
                }
            }

        } else {
            this.state = 'idle';
        }

        if (this.digTimer > 0) this.digTimer--;

        // Throw Powerball
        if ((input.justPressed('KeyZ') || input.justPressed('Space')) && this.hasPowerball && this.powerballCooldown <= 0) {
            game.throwPowerball(this);
        }
    }

    move(vx, vy, map) {
        const nextX = this.x + vx;
        const nextY = this.y + vy;
        
        // Check bounds
        if (nextX < 0 || nextX + this.width > COLS * TILE_SIZE ||
            nextY < 0 || nextY + this.height > ROWS * TILE_SIZE) {
            return false;
        }

        // Simple tile collision (treating player as smaller than tile for smoother feel)
        const margin = 4;
        const checkPoints = [
            {x: nextX + margin, y: nextY + margin},
            {x: nextX + this.width - margin, y: nextY + margin},
            {x: nextX + margin, y: nextY + this.height - margin},
            {x: nextX + this.width - margin, y: nextY + this.height - margin}
        ];

        for (let p of checkPoints) {
            const col = Math.floor(p.x / TILE_SIZE);
            const row = Math.floor(p.y / TILE_SIZE);
            
            if (map[row][col] === T_ROCK) return false;
            // Don't collide with dirt, we dig it
        }

        this.x = nextX;
        this.y = nextY;
        
        // Snap to grid slightly for alignment
        const centerX = Math.floor(this.x / TILE_SIZE);
        const centerY = Math.floor(this.y / TILE_SIZE);
        
        return true;
    }
    
    draw(ctx) {
        if (this.invincibleTimer > 0 && Math.floor(Date.now() / 100) % 2 === 0) return;

        ctx.save();
        ctx.translate(Math.floor(this.x + this.width/2), Math.floor(this.y + this.height/2));
        if (!this.facingRight) ctx.scale(-1, 1);
        
        // --- Draw Clown ---
        const w = 32;
        const h = 32;

        // Shoes
        ctx.fillStyle = '#222';
        ctx.beginPath(); ctx.ellipse(-10, 14, 6, 4, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(10, 14, 6, 4, 0, 0, Math.PI*2); ctx.fill();

        // Body (Striped suit)
        ctx.fillStyle = '#e74c3c'; // Red base
        ctx.fillRect(-8, -5, 16, 20);
        ctx.fillStyle = '#f1c40f'; // Yellow stripe
        ctx.fillRect(-8, 2, 16, 4);

        // Head (White face)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(0, -10, 12, 0, Math.PI*2);
        ctx.fill();

        // Hat
        ctx.fillStyle = '#3498db'; // Blue hat
        ctx.beginPath(); ctx.moveTo(-14, -16); ctx.lineTo(14, -16); ctx.lineTo(0, -28); ctx.fill();
        
        // Pom pom
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath(); ctx.arc(0, -28, 4, 0, Math.PI*2); ctx.fill();

        // Eyes (Expression changes based on state)
        ctx.fillStyle = '#000';
        if (this.state === 'dig') {
            // Concentrated eyes
            ctx.fillRect(-6, -12, 3, 1);
            ctx.fillRect(3, -12, 3, 1);
        } else {
            // Happy eyes
            ctx.beginPath(); ctx.arc(-4, -11, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(4, -11, 2, 0, Math.PI*2); ctx.fill();
        }

        // Nose (Red ball)
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.arc(0, -7, 4, 0, Math.PI*2);
        ctx.fill();

        // Mouth
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        if (this.state === 'dig') {
             ctx.moveTo(-4, -3); ctx.lineTo(4, -3); // Straight mouth
        } else {
             ctx.arc(0, -3, 5, 0.2, Math.PI - 0.2); // Smile
        }
        ctx.stroke();

        // Arms
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.beginPath();
        if (this.state === 'walk') {
            const swing = Math.sin(Date.now() / 100) * 5;
            ctx.moveTo(-8, -2); ctx.lineTo(-14, 0 + swing);
            ctx.moveTo(8, -2); ctx.lineTo(14, 0 - swing);
        } else if (this.state === 'dig') {
            ctx.moveTo(-6, 0); ctx.lineTo(-12, -5); // Arms up
            ctx.moveTo(6, 0); ctx.lineTo(12, -5);
        } else {
            ctx.moveTo(-8, -2); ctx.lineTo(-12, 4);
            ctx.moveTo(8, -2); ctx.lineTo(12, 4);
        }
        ctx.stroke();

        ctx.restore();
    }
}

// Monster Class
class Monster extends Entity {
    constructor(x, y, type) {
        super(x, y, E_MONSTER);
        this.monsterType = type; // 'blob' or 'alpha'
        this.color = type === 'alpha' ? '#9b59b6' : '#2ecc71'; // Purple or Green
        this.speed = type === 'alpha' ? 1.5 : 1;
        this.dir = Math.floor(Math.random() * 4); // 0:R, 1:D, 2:L, 3:U
        this.moveTimer = 0;
        this.panic = false; // Panic when apple falls near
        
        // Extra life letter logic
        this.letterIndex = -1; 
        if (type === 'alpha') {
            const letters = ['E', 'X', 'T', 'R', 'A'];
            this.letterIndex = Math.floor(Math.random() * letters.length);
            this.letter = letters[this.letterIndex];
        }
    }

    update(dt, map) {
        // Simple AI: Move until hit wall, then change direction
        if (this.moveTimer <= 0) {
            // Randomly change direction occasionally
            if (Math.random() < 0.1) this.dir = Math.floor(Math.random() * 4);
            this.moveTimer = rand(20, 60);
        }
        
        let dx = 0;
        let dy = 0;
        
        const panicSpeed = this.panic ? this.speed * 2 : this.speed;

        if (this.dir === 0) dx = panicSpeed;
        else if (this.dir === 1) dy = panicSpeed;
        else if (this.dir === 2) dx = -panicSpeed;
        else if (this.dir === 3) dy = -panicSpeed;

        const nextX = this.x + dx;
        const nextY = this.y + dy;
        
        // Collision Check
        let collided = false;
        const bounds = {x: nextX+4, y: nextY+4, w: this.width-8, h: this.height-8};
        
        if (bounds.x < 0 || bounds.x + bounds.w > COLS * TILE_SIZE ||
            bounds.y < 0 || bounds.y + bounds.h > ROWS * TILE_SIZE) {
            collided = true;
        } else {
             // Check Rocks
             const c1 = Math.floor(bounds.x / TILE_SIZE);
             const r1 = Math.floor(bounds.y / TILE_SIZE);
             const c2 = Math.floor((bounds.x + bounds.w) / TILE_SIZE);
             const r2 = Math.floor((bounds.y + bounds.h) / TILE_SIZE);

             if (map[r1][c1] === T_ROCK || map[r1][c2] === T_ROCK || 
                 map[r2][c1] === T_ROCK || map[r2][c2] === T_ROCK) {
                 collided = true;
             }
        }

        if (!collided) {
            this.x = nextX;
            this.y = nextY;
        } else {
            // Pick new random direction
            this.dir = Math.floor(Math.random() * 4);
            this.moveTimer = 30;
        }
        
        this.panic = false; // Reset panic frame
    }

    draw(ctx) {
        const centerX = this.x + this.width/2;
        const centerY = this.y + this.height/2;
        
        ctx.save();
        ctx.translate(centerX, centerY);
        
        // Wobble animation
        const wobble = Math.sin(Date.now() / 150) * 2;
        ctx.rotate(wobble * 0.1);

        // Body
        ctx.fillStyle = this.color;
        if (this.panic) ctx.fillStyle = '#fff'; // Flash white when panicked
        
        ctx.beginPath();
        ctx.arc(0, 0, this.width/2 - 2, 0, Math.PI*2);
        ctx.fill();

        // Shine
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath(); ctx.arc(-6, -6, 4, 0, Math.PI*2); ctx.fill();

        // Eyes (Goggles)
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        if (this.panic) {
            // X eyes
             ctx.strokeStyle = '#000'; ctx.lineWidth=2;
             ctx.moveTo(-8,-5); ctx.lineTo(-2, 1);
             ctx.moveTo(-2,-5); ctx.lineTo(-8, 1);
             ctx.moveTo(2,-5); ctx.lineTo(8, 1);
             ctx.moveTo(8,-5); ctx.lineTo(2, 1);
             ctx.stroke();
        } else {
            // Normal eyes
            ctx.ellipse(-6, -2, 4, 6, 0, 0, Math.PI*2);
            ctx.ellipse(6, -2, 4, 6, 0, 0, Math.PI*2);
            ctx.fill();
            
            // Pupils (look at player)
            const p = game.player;
            let dx = p.x - this.x;
            let dy = p.y - this.y;
            const len = Math.sqrt(dx*dx + dy*dy);
            dx /= len; dy /= len;
            
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(-6 + dx*2, -2 + dy*2, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(6 + dx*2, -2 + dy*2, 2, 0, Math.PI*2); ctx.fill();
        }

        // Mouth
        if (this.monsterType === 'alpha') {
             ctx.fillStyle = '#000';
             ctx.font = 'bold 12px Arial';
             ctx.textAlign = 'center';
             ctx.fillText(this.letter, 0, 10);
        } else {
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(0, 6, 4, 0, Math.PI); ctx.stroke();
        }
        
        ctx.restore();
    }
}

// Apple Class (Physics Object)
class Apple extends Entity {
    constructor(x, y) {
        super(x, y, E_APPLE);
        this.resting = true;
    }

    update(dt, map, entities) {
        // Check if support below is gone
        const centerX = Math.floor((this.x + this.width/2) / TILE_SIZE);
        const bottomY = Math.floor((this.y + this.height + 2) / TILE_SIZE);

        let supported = false;
        
        // Supported by map?
        if (bottomY < ROWS && map[bottomY][centerX] !== T_EMPTY) {
            supported = true;
        }
        
        // Supported by another apple?
        for (let e of entities) {
            if (e === this || !(e instanceof Apple)) continue;
            // Check directly below
            if (Math.abs(e.x - this.x) < 5 && Math.abs((e.y + e.height) - (this.y + this.height)) < 10 && e.y > this.y) {
                supported = true;
                break; 
            }
        }

        if (!supported) {
            this.resting = false;
            this.vy += GRAVITY;
            // Cap fall speed
            if (this.vy > MAX_SPEED + 2) this.vy = MAX_SPEED + 2;
            
            this.y += this.vy;

            // Detect Crush
            for (let e of entities) {
                if (e === this) continue;
                const bounds = this.getBounds();
                const eBounds = e.getBounds();

                if (this.checkCollide(bounds, eBounds)) {
                    if (e instanceof Monster && this.vy > 1) {
                        // Crushed monster
                        game.crushMonster(e);
                        this.vy = 0; // Stop falling momentarily? No, keep going for combo
                    } else if (e instanceof Player && this.vy > 2) {
                         // Crush player?
                         if(game.player.invincibleTimer <= 0) game.killPlayer();
                    }
                }
            }
            
            // Hit ground/rock
            const hitY = Math.floor((this.y + this.height) / TILE_SIZE);
            const hitX = Math.floor((this.x + this.width/2) / TILE_SIZE);
            
            if (hitY < ROWS && map[hitY][hitX] === T_ROCK) {
                this.y = (hitY - 1) * TILE_SIZE;
                this.vy = 0;
                this.resting = true;
            } else if (hitY >= ROWS) {
                 // Bottom of screen
                 this.y = ROWS * TILE_SIZE - this.height;
                 this.vy = 0;
                 this.resting = true;
            }

        } else {
            this.vy = 0;
            // Snap to Y grid when resting
            const targetY = Math.round(this.y / TILE_SIZE) * TILE_SIZE;
            if (Math.abs(targetY - this.y) < 5) this.y = targetY;
            
            // Check for being pushed horizontally by player
            const p = game.player;
            const dx = p.x - this.x;
            const dy = p.y - this.y; // Must be on same row roughly

            if (Math.abs(dy) < 10 && Math.abs(dx) < TILE_SIZE + 5 && Math.abs(dx) > 5) {
                // Check if push direction is clear
                const dir = dx > 0 ? 1 : -1;
                const nextCol = centerX + dir;
                
                // Check Map collision for push
                let canPush = false;
                if (nextCol >= 0 && nextCol < COLS) {
                    if (map[bottomY-1][nextCol] === T_EMPTY && map[bottomY][nextCol] === T_EMPTY) {
                        // Check entity collision
                        let blockedByEntity = false;
                        for(let other of entities) {
                            if(other === this || other instanceof Apple) continue; // Can push apples into apples? Let's say no
                            const oX = Math.floor((other.x + other.width/2)/TILE_SIZE);
                            const oY = Math.floor((other.y + other.height/2)/TILE_SIZE);
                            if(oX === nextCol && (oY === bottomY-1 || oY === bottomY)) {
                                blockedByEntity = true;
                                break;
                            }
                        }
                        
                        if(!blockedByEntity) canPush = true;
                    }
                }

                if (canPush) {
                    this.x += dir * 2; // Push speed
                    // Snap X
                    const currentCol = Math.floor((this.x + this.width/2)/TILE_SIZE);
                    if(currentCol !== centerX) {
                        // Crossed tile boundary
                        this.resting = false; // Re-evaluate gravity
                    }
                }
            }
        }
    }

    checkCollide(r1, r2) {
        return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
                r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
    }

    draw(ctx) {
        const cx = this.x + this.width/2;
        const cy = this.y + this.height/2;
        
        ctx.fillStyle = '#c0392b';
        ctx.beginPath();
        ctx.arc(cx, cy, 16, 0, Math.PI*2);
        ctx.fill();
        
        // Highlight
        ctx.fillStyle = '#e74c3c'; 
        ctx.beginPath(); ctx.ellipse(cx - 5, cy - 5, 8, 5, -0.5, 0, Math.PI*2); ctx.fill();

        // Stem
        ctx.strokeStyle = '#27ae60';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(cx, cy - 14);
        ctx.quadraticCurveTo(cx + 4, cy - 18, cx + 8, cy - 16);
        ctx.stroke();

        // Leaf
        if (this.resting) {
             ctx.fillStyle = '#2ecc71';
             ctx.beginPath();
             ctx.ellipse(cx+8, cy-16, 6, 3, 0.5, 0, Math.PI*2);
             ctx.fill();
        }
    }
}

// Cherry (Collectible)
class Cherry extends Entity {
    constructor(x, y) {
        super(x + 10, y + 10, E_CHERRY); // Center in tile
        this.width = 20;
        this.height = 20;
        this.baseY = y + 10;
        this.floatOffset = Math.random() * Math.PI * 2;
    }
    
    update(dt) {
        // Float animation
        this.y = this.baseY + Math.sin(Date.now() / 200 + this.floatOffset) * 3;
        
        // Collect check
        const pBounds = game.player.getBounds();
        const cBounds = this.getBounds();
        
        if (pBounds.x < cBounds.x + cBounds.w && pBounds.x + pBounds.w > cBounds.x &&
            pBounds.y < cBounds.y + cBounds.h && pBounds.y + pBounds.h > cBounds.y) {
                game.collectCherry(this);
            }
    }
    
    draw(ctx) {
        const cx = this.x + 10;
        const cy = this.y + 10;
        
        ctx.fillStyle = '#e91e63';
        ctx.beginPath(); ctx.arc(cx - 6, cy + 2, 8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + 6, cy + 2, 8, 0, Math.PI*2); ctx.fill();
        
        // Shine
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.beginPath(); ctx.arc(cx - 9, cy - 1, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + 3, cy - 1, 3, 0, Math.PI*2); ctx.fill();

        // Stems
        ctx.strokeStyle = '#27ae60';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - 6, cy - 5);
        ctx.quadraticCurveTo(cx, cy - 15, cx + 6, cy - 5);
        ctx.stroke();
    }
}

// Powerball (Boomerang)
class Powerball extends Entity {
    constructor(x, y, dirX, dirY) {
        super(x, y, E_POWERBALL);
        this.vx = dirX * 8;
        this.vy = dirY * 8; // Initial burst
        this.state = 'out'; // out, return
        this.life = 60; // Frames before returning
        this.returnSpeed = 8;
    }
    
    update(dt) {
        if (this.state === 'out') {
            this.x += this.vx;
            this.y += this.vy;
            
            // Bounce off walls
            if (this.x < 0 || this.x > COLS * TILE_SIZE) { this.vx *= -1; this.life -= 10; }
            if (this.y < 0 || this.y > ROWS * TILE_SIZE) { this.vy *= -1; this.life -= 10; }
            
            this.life--;
            // Friction
            this.vx *= 0.98;
            this.vy *= 0.98;
            
            if (this.life <= 0 || (Math.abs(this.vx) < 1 && Math.abs(this.vy) < 1)) {
                this.state = 'return';
            }
        } else {
            // Return to player
            const p = game.player;
            const dx = (p.x + p.width/2) - (this.x + this.width/2);
            const dy = (p.y + p.height/2) - (this.y + this.height/2);
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < 10) {
                this.markedForDeletion = true; // Caught
                // Visual flash could go here
                game.player.hasPowerball = true;
                return;
            }
            
            this.x += (dx / dist) * this.returnSpeed;
            this.y += (dy / dist) * this.returnSpeed;
        }
        
        // Hit Monster
        for(let m of game.monsters) {
             const mx = m.x + m.width/2; 
             const my = m.y + m.height/2;
             const bx = this.x; 
             const by = this.y;
             const dist = Math.sqrt((mx-bx)**2 + (my-by)**2);
             
             if(dist < 20) {
                 game.killMonster(m, true); // True = killed by ball
                 this.markedForDeletion = true; // Ball destroys on impact
                 break;
             }
        }
    }
    
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + 10, this.y + 10);
        ctx.rotate(Date.now() / 50); // Spin
        
        ctx.fillStyle = '#f1c40f'; // Gold
        ctx.strokeStyle = '#e67e22';
        ctx.lineWidth = 2;
        
        // Star shape
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
            ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * 12,
                       -Math.sin((18 + i * 72) * Math.PI / 180) * 12);
            ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * 5,
                       -Math.sin((54 + i * 72) * Math.PI / 180) * 5);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
    }
}

// Main Game Class
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.input = new InputHandler();
        
        this.map = [];
        this.entities = [];
        this.particles = [];
        this.monsters = []; // Reference for quick access
        
        this.player = null;
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        
        this.extrasCollected = []; // Letters collected
        this.isPlaying = false;

        // UI Elements
        this.scoreEl = document.getElementById('scoreVal');
        this.livesEl = document.getElementById('livesVal');
        this.levelEl = document.getElementById('levelVal');
        
        // Screens
        this.screens = {
            start: document.getElementById('startScreen'),
            gameOver: document.getElementById('gameOverScreen'),
            level: document.getElementById('levelScreen'),
            victory: document.getElementById('victoryScreen')
        };
    }

    init() {
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    generateLevel(lvl) {
        this.map = [];
        this.entities = [];
        this.monsters = [];
        this.particles = [];
        
        // 1. Fill Map
        for (let r = 0; r < ROWS; r++) {
            let row = [];
            for (let c = 0; c < COLS; c++) {
                if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) {
                    row.push(T_ROCK);
                } else if (r < 2) {
                    row.push(T_EMPTY); // Sky / Start area
                } else {
                    row.push(T_DIRT);
                }
            }
            this.map.push(row);
        }

        // 2. Place Player
        const startX = Math.floor(COLS/2) * TILE_SIZE;
        const startY = TILE_SIZE; 
        this.player = new Player(startX, startY);
        this.entities.push(this.player);

        // 3. Procedural Generation (Apples, Cherries, Monsters)
        let numMonsters = 3 + lvl;
        let numApples = 4 + Math.floor(lvl / 2);
        let numCherries = 2 + Math.floor(lvl / 3);
        
        // Helper to find empty dirt spot
        const getSpot = () => {
            let r, c;
            do {
                r = Math.floor(rand(3, ROWS - 1));
                c = Math.floor(rand(1, COLS - 1));
            } while (this.map[r][c] !== T_DIRT || this.isEntityAt(c, r));
            
            // Clear dirt for entity
            this.map[r][c] = T_EMPTY;
            return {x: c * TILE_SIZE, y: r * TILE_SIZE};
        };

        // Place Apples
        for(let i=0; i<numApples; i++) {
            const pos = getSpot();
            this.entities.push(new Apple(pos.x, pos.y));
        }

        // Place Cherries
        for(let i=0; i<numCherries; i++) {
            const pos = getSpot();
            this.entities.push(new Cherry(pos.x, pos.y));
        }
        
        // Place Monsters
        for(let i=0; i<numMonsters; i++) {
            const pos = getSpot();
            // First monster is Alpha (drops letter)
            const type = (i === 0 && lvl > 1) ? 'alpha' : 'blob';
            const m = new Monster(pos.x, pos.y, type);
            this.entities.push(m);
            this.monsters.push(m);
        }
        
        console.log(`Level ${lvl} Generated. Monsters: ${numMonsters}`);
    }

    isEntityAt(c, r) {
        for(let e of this.entities) {
            const ec = Math.floor((e.x + e.width/2)/TILE_SIZE);
            const er = Math.floor((e.y + e.height/2)/TILE_SIZE);
            if (ec === c && er === r) return true;
        }
        return false;
    }

    startLevel() {
        this.hideAllScreens();
        this.generateLevel(this.level);
        this.isPlaying = true;
        this.extrasCollected = [];
        this.updateUI();
    }
    
    resetGame() {
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.startLevel();
    }

    nextLevel() {
        this.level++;
        if (this.level > 5) {
            this.showScreen('victory');
            document.getElementById('winScore').innerText = this.score;
            this.isPlaying = false;
        } else {
            this.startLevel();
        }
    }

    hideAllScreens() {
        Object.values(this.screens).forEach(s => s.classList.add('hidden'));
    }

    showScreen(name) {
        this.hideAllScreens();
        this.screens[name].classList.remove('hidden');
    }

    spawnParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color, 4, rand(2,5), 30));
        }
    }

    throwPowerball(player) {
        player.hasPowerball = false;
        player.powerballCooldown = 60;
        
        // Direction based on currently held keys or facing
        let dx = 0; 
        let dy = 0;
        
        if (this.input.isDown('ArrowUp')) dy = -1;
        else if (this.input.isDown('ArrowDown')) dy = 1;
        else dx = player.facingRight ? 1 : -1;

        const ball = new Powerball(
            player.x + player.width/2, 
            player.y + player.height/2,
            dx, dy
        );
        this.entities.push(ball);
    }

    killMonster(monster, byBall = false) {
        if (monster.markedForDeletion) return;
        
        monster.markedForDeletion = true;
        this.spawnParticles(monster.x + monster.width/2, monster.y + monster.height/2, monster.color, 15);
        this.score += byBall ? 100 : 200; // Crush gives more points
        
        if (monster.monsterType === 'alpha') {
            // Drop Letter
            const letter = monster.letter;
            console.log("Alpha killed! Drops: " + letter);
            
            // Visual popup for letter
            const ctx = this.ctx;
            // We'll just add to score immediately UI-wise, but technically it collects the item
            if (!this.extrasCollected.includes(letter)) {
                this.extrasCollected.push(letter);
                this.score += 500;
                // Sort to check EXTRA
                this.extrasCollected.sort();
                
                const word = this.extrasCollected.join("");
                if (word === "AER TX" || this.extrasCollected.length === 5) { // Simplified check, order doesn't matter usually but let's just give life on 5 letters
                     // Actually standard logic: Collect E X T R A in any order = 1UP.
                     const hasAll = ['E','X','T','R','A'].every(l => this.extrasCollected.includes(l));
                     if(hasAll) {
                         this.lives++;
                         this.extrasCollected = []; // Reset
                         this.spawnParticles(this.player.x, this.player.y, '#ff0000', 30); // Heart effect
                     }
                }
            }
        }

        // Check Win Condition
        const remaining = this.monsters.filter(m => !m.markedForDeletion).length;
        if (remaining === 0) {
            setTimeout(() => {
                if(this.isPlaying) this.showScreen('level');
            }, 1000);
        }
    }
    
    crushMonster(monster) {
        monster.panic = true; // Look surprised
        // Small delay before actual death for animation effect? 
        // Let's just kill it but spawn "splatter" particles
        this.killMonster(monster, false); 
        // Shake screen slightly?
    }

    collectCherry(cherry) {
        cherry.markedForDeletion = true;
        this.score += 50;
        this.spawnParticles(cherry.x+10, cherry.y+10, '#e91e63', 8);
    }
    
    killPlayer() {
        this.lives--;
        this.updateUI();
        
        if (this.lives <= 0) {
            this.isPlaying = false;
            document.getElementById('finalScore').innerText = this.score;
            this.showScreen('gameOver');
        } else {
            // Respawn logic
            this.player.x = Math.floor(COLS/2) * TILE_SIZE;
            this.player.y = TILE_SIZE;
            this.player.invincibleTimer = 120; // 2 seconds invincibility
            this.player.hasPowerball = true;
            
            // Reset nearby monsters? Optional.
        }
    }

    updateUI() {
        this.scoreEl.innerText = this.score;
        this.levelEl.innerText = this.level;
        
        let hearts = "";
        for(let i=0; i<this.lives; i++) hearts += "❤️";
        this.livesEl.innerHTML = hearts;
    }

    loop() {
        // 1. Update
        if (this.isPlaying && this.player) {
            // Player
            this.player.update(1, this.map, this.input);
            
            // Entities (Update others only to avoid double-updating player with wrong args)
            this.entities.forEach(e => {
                if (e !== this.player) {
                    e.update(1, this.map, this.entities);
                }
            });
            
            // Cleanup deleted entities
            this.entities = this.entities.filter(e => !e.markedForDeletion);
            this.monsters = this.monsters.filter(m => !m.markedForDeletion);
            
            // Particles
            this.particles.forEach(p => p.update());
            this.particles = this.particles.filter(p => p.life > 0);

            this.updateUI();
        }

        // 2. Draw
        this.draw();

        requestAnimationFrame(this.loop);
    }

    draw() {
        const ctx = this.ctx;
        
        // Clear Background
        ctx.fillStyle = '#1a1510'; // Dark underground base
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (!this.map || this.map.length === 0) return;

        // Draw Map
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const tile = this.map[r][c];
                const x = c * TILE_SIZE;
                const y = r * TILE_SIZE;

                if (tile === T_DIRT) {
                    // Dirt Texture
                    ctx.fillStyle = '#5d4037';
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    
                    // Detail: Rocks in dirt
                    ctx.fillStyle = '#4e342e';
                    ctx.beginPath(); ctx.arc(x+10, y+10, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(x+30, y+25, 5, 0, Math.PI*2); ctx.fill();

                } else if (tile === T_ROCK) {
                    // Rock Border
                    ctx.fillStyle = '#212121';
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    
                    // Highlight bevel
                    ctx.strokeStyle = '#424242';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x+2, y+2, TILE_SIZE-4, TILE_SIZE-4);
                } else {
                    // Empty space (tunnel)
                    // Darker background for depth
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        // Draw Entities
        this.entities.forEach(e => e.draw(ctx));
        
        // Draw Particles
        this.particles.forEach(p => p.draw(ctx));

        // Lighting Effect (Vignette)
        const gradient = ctx.createRadialGradient(
            this.player.x + 20, this.player.y + 20, 60,
            this.player.x + 20, this.player.y + 20, 400
        );
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

// Start Game
const game = new Game();
game.init();

</script>
</body>
</html>