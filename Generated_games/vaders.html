<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders 1978</title>
    <style>
        body {
            background-color: #111;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        h1 { margin: 10px 0; text-transform: uppercase; letter-spacing: 5px; color: #00ff00; text-shadow: 2px 2px #fff; }
        canvas {
            border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            background-color: #000;
        }
        .controls { margin-top: 10px; font-size: 14px; color: #aaa; }
    </style>
</head>
<body>

    <h1>Space Invaders</h1>
    <canvas id="gameCanvas" width="600" height="700"></canvas>
    <div class="controls">ARROWS to Move | SPACE to Fire</div>

<script>
/**
 * SPACE INVADERS (1978) CLONE
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONSTANTS & CONFIG ---
const GAME_WIDTH = 600;
const GAME_HEIGHT = 700;
const PLAYER_SPEED = 4;
const BULLET_SPEED = 7;
const ALIEN_BULLET_SPEED = 4;
const PARTICLE_LIFE = 30;

// Sprite Maps (1 = draw pixel, 0 = transparent)
// 8x11 grids
const SPRITES = {
    squid: [ // Top row (Red/Pink)
        [0,0,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,0],
        [1,1,0,1,1,0,1,1],
        [1,1,1,1,1,1,1,1],
        [1,1,1,0,0,1,1,1],
        [0,1,0,1,1,0,1,0],
        [1,0,0,0,0,0,0,1],
        [0,1,0,0,0,0,1,0],
        [0,1,0,0,0,0,1,0],
        [0,0,1,1,1,1,0,0],
        [0,0,1,0,0,1,0,0]
    ],
    bug: [ // Middle rows (Green)
        [0,0,1,0,0,1,0,0],
        [0,0,0,1,1,0,0,0],
        [0,0,1,1,1,1,0,0],
        [0,1,1,0,0,1,1,0],
        [1,1,1,1,1,1,1,1],
        [1,0,1,1,1,1,0,1],
        [1,0,1,0,0,1,0,1],
        [0,0,0,1,1,0,0,0],
        [0,0,1,0,0,1,0,0],
        [0,1,0,0,0,0,1,0],
        [1,0,0,0,0,0,0,1]
    ],
    octopus: [ // Bottom rows (Cyan/White)
        [0,0,0,1,1,0,0,0],
        [0,0,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,0],
        [1,1,0,1,1,0,1,1],
        [1,1,1,1,1,1,1,1],
        [0,0,1,0,0,1,0,0],
        [0,1,0,1,1,0,1,0],
        [1,0,1,0,0,1,0,1],
        [0,1,0,1,1,0,1,0],
        [1,0,0,0,0,0,0,1],
        [0,1,1,0,0,1,1,0]
    ]
};

// --- GAME STATE ---
let score = 0;
let lives = 3;
let level = 1;
let gameOver = false;
let gameWon = false;
let frameCount = 0;

// Entities
const player = {
    x: GAME_WIDTH / 2 - 15,
    y: GAME_HEIGHT - 50,
    width: 30,
    height: 24, // Approximate based on sprite scale
    color: '#00ff00',
    bullet: null,
    cooldown: 0
};

let aliens = [];
let alienBullets = [];
let particles = [];
let ufo = null;

// Bunkers
const bunkers = [];

// Alien Movement State
let alienDirection = 1; // 1 = right, -1 = left
let alienMoveTimer = 0;
let alienMoveInterval = 60; // Frames between moves (decreases as they speed up)
let alienDropPending = false;

// --- CLASSES ---

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 3 + 1;
        this.speedX = (Math.random() - 0.5) * 4;
        this.speedY = (Math.random() - 0.5) * 4;
        this.life = PARTICLE_LIFE;
    }

    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life--;
        this.size *= 0.9; // Shrink
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

class Bullet {
    constructor(x, y, isPlayer) {
        this.x = x;
        this.y = y;
        this.width = 4;
        this.height = 10;
        this.isPlayer = isPlayer; // true if player fires, false if alien
        this.speed = isPlayer ? -BULLET_SPEED : ALIEN_BULLET_SPEED;
        this.active = true;
    }

    update() {
        this.y += this.speed;
        if (this.y < 0 || this.y > GAME_HEIGHT) this.active = false;
    }

    draw() {
        ctx.fillStyle = this.isPlayer ? '#fff' : '#ff0055'; // White for player, Red/Pink for aliens
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

class UFO {
    constructor() {
        this.width = 48;
        this.height = 21;
        this.y = 45;
        this.direction = Math.random() > 0.5 ? 1 : -1;
        this.x = this.direction === 1 ? -this.width : GAME_WIDTH;
        this.speed = 3;
        this.active = true;
        this.scoreValue = Math.floor(Math.random() * 3 + 1) * 50; // 50, 100, or 150
    }

    update() {
        this.x += this.speed * this.direction;
        if ((this.direction === 1 && this.x > GAME_WIDTH) || 
            (this.direction === -1 && this.x < -this.width)) {
            this.active = false;
        }
    }

    draw() {
        // Simple UFO Shape
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y + 10);
        ctx.lineTo(this.x + 12, this.y);
        ctx.lineTo(this.x + 36, this.y);
        ctx.lineTo(this.x + 48, this.y + 10);
        ctx.lineTo(this.x + 36, this.y + 21);
        ctx.lineTo(this.x + 12, this.y + 21);
        ctx.closePath();
        ctx.fill();

        // Engine lights
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(this.x + 15, this.y - 5, 4, 4);
        ctx.fillRect(this.x + 29, this.y - 5, 4, 4);
    }
}

class Bunker {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.blocks = [];
        // Create a grid of blocks for the bunker
        const rows = 10;
        const cols = 12;
        const blockSize = 6;
        
        // Create a "arch" shape logic or just a solid block that erodes
        // For faithful erosion, we create individual block objects
        for(let r=0; r<rows; r++) {
            for(let c=0; c<cols; c++) {
                // Create the arch shape
                if (r > 6 && (c > 3 && c < 8)) continue; 
                
                this.blocks.push({
                    x: x + c * blockSize,
                    y: y + r * blockSize,
                    width: blockSize,
                    height: blockSize,
                    active: true
                });
            }
        }
    }

    draw() {
        ctx.fillStyle = '#00ff00'; // Classic bunker green
        this.blocks.forEach(block => {
            if (block.active) {
                ctx.fillRect(block.x, block.y, block.width, block.height);
                // Add a little detail to make it look like blocks
                ctx.strokeStyle = '#003300';
                ctx.strokeRect(block.x, block.y, block.width, block.height);
            }
        });
    }

    checkCollision(bullet) {
        for (let block of this.blocks) {
            if (block.active && 
                bullet.x < block.x + block.width &&
                bullet.x + bullet.width > block.x &&
                bullet.y < block.y + block.height &&
                bullet.y + bullet.height > block.y) {
                
                block.active = false;
                createExplosion(block.x, block.y, '#00ff00', 2);
                return true; // Hit
            }
        }
        return false;
    }
}

// --- HELPER FUNCTIONS ---

function createExplosion(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function drawSprite(ctx, spriteMap, x, y, scale, color, frame) {
    ctx.fillStyle = color;
    const offset1 = (frame % 3 === 0) ? 1 : ((frame % 3 === 1) ? -1 : 0);
    
    for (let r = 0; r < spriteMap.length; r++) {
        for (let c = 0; c < spriteMap[r].length; c++) {
            if (spriteMap[r][c] === 1) {
                ctx.fillRect(x + (c * scale) + offset1, y + (r * scale), scale, scale);
            }
        }
    }
}

function initAliens() {
    aliens = [];
    const startX = 50;
    const startY = 80;
    const cols = 11;
    const rows = 5;
    const spacingX = 40;
    const spacingY = 35;
    const spriteScale = 3;

    for (let r = 0; r < rows; r++) {
        let spriteKey = 'squid';
        let color = '#ff00ff'; // Squid Color
        if (r >= 1 && r <= 2) { 
            spriteKey = 'bug'; 
            color = '#00ff00'; // Bug Color
        } else { 
            spriteKey = 'octopus'; 
            color = '#ffffff'; // Octopus Color
        }

        for (let c = 0; c < cols; c++) {
            aliens.push({
                x: startX + c * spacingX,
                y: startY + r * spacingY,
                width: 24, // 8 cols * 3 scale
                height: 33, // 11 rows * 3 scale
                spriteKey: spriteKey,
                color: color,
                active: true
            });
        }
    }
}

function initBunkers() {
    bunkers.length = 0;
    const bunkerXPositions = [75, 225, 375, 525];
    const bunkerY = 550;
    
    for (let x of bunkerXPositions) {
        bunkers.push(new Bunker(x, bunkerY));
    }
}

function resetGame() {
    score = 0;
    lives = 3;
    level = 1;
    gameOver = false;
    gameWon = false;
    alienMoveInterval = 60;
    initAliens();
    initBunkers();
    player.bullet = null;
    alienBullets = [];
    particles = [];
    ufo = null;
}

// --- INPUT HANDLING ---
const keys = {};
window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (gameOver || gameWon) {
        if (e.code === 'Space' || e.code === 'Enter') resetGame();
        return;
    }

    // Fire - Strict cooldown
    if (e.code === 'Space' && !player.bullet && player.cooldown <= 0) {
        player.bullet = new Bullet(player.x + player.width / 2 - 2, player.y, true);
        player.cooldown = 35; // Increased from 30 to reduce fire rate
    }
});
window.addEventListener('keyup', (e) => keys[e.code] = false);

// --- GAME LOGIC ---

function update() {
    if (gameOver || gameWon) return;

    frameCount++;

    // Player Movement
    if (keys['ArrowLeft'] && player.x > 10) {
        player.x -= PLAYER_SPEED;
    }
    if (keys['ArrowRight'] && player.x < GAME_WIDTH - player.width - 10) {
        player.x += PLAYER_SPEED;
    }

    // Player Cooldown
    if (player.cooldown > 0) player.cooldown--;

    // Update Player Bullet
    if (player.bullet && player.bullet.active) {
        player.bullet.update();
        
        // Check collision with Aliens
        let hit = false;
        for (let alien of aliens) {
            if (alien.active && 
                player.bullet.x < alien.x + alien.width &&
                player.bullet.x + player.bullet.width > alien.x &&
                player.bullet.y < alien.y + alien.height &&
                player.bullet.y + player.bullet.height > alien.y) {
                
                alien.active = false;
                player.bullet.active = false;
                score += (alien.spriteKey === 'squid' ? 30 : (alien.spriteKey === 'bug' ? 20 : 10));
                createExplosion(alien.x + alien.width/2, alien.y + alien.height/2, alien.color, 10);
                
                // Speed up game slightly as aliens decrease
                if (aliens.filter(a => a.active).length > 0) {
                    alienMoveInterval = Math.max(5, 60 - (55 - aliens.length) * 1.5);
                }

                // Check UFO
                if (ufo && ufo.active && 
                    player.bullet.x < ufo.x + ufo.width &&
                    player.bullet.x + player.bullet.width > ufo.x &&
                    player.bullet.y < ufo.y + ufo.height &&
                    player.bullet.y + player.bullet.height > ufo.y) {
                        ufo.active = false;
                        score += ufo.scoreValue;
                        createExplosion(ufo.x + ufo.width/2, ufo.y + ufo.height/2, '#ff0000', 15);
                }

                hit = true;
                break;
            }
        }

        // Check collision with Bunkers
        if (!hit && player.bullet.active) {
            for (let bunker of bunkers) {
                if (bunker.checkCollision(player.bullet)) {
                    hit = true;
                    break;
                }
            }
        }

    } else {
        player.bullet = null;
    }

    // Update Alien Bullets
    alienBullets.forEach(b => b.update());
    
    // Remove inactive bullets
    alienBullets = alienBullets.filter(b => b.active);
    if (player.bullet && !player.bullet.active) player.bullet = null;

    // UFO Logic
    if (!ufo || !ufo.active) {
        if (Math.random() < 0.001) { // Rare chance per frame
            ufo = new UFO();
        }
    } else {
        ufo.update();
        if (!ufo.active) ufo = null;
    }

    // Alien Movement Logic
    alienMoveTimer++;
    
    // Check if aliens should drop bombs
    // More aliens = less frequent bombs, fewer aliens = more frequent
    const activeAliens = aliens.filter(a => a.active);
    let bombChance = 0.01 + (55 - activeAliens.length) * 0.002;
    
    if (Math.random() < bombChance && activeAliens.length > 0) {
        // Pick a random alien from the bottom-most row of each column that has aliens
        let potentialShooters = [];
        
        // Simple logic: just pick random aliens, weighted towards bottom rows
        for(let i=0; i<5; i++) { // Try 5 times to find a shooter
            const randomAlien = activeAliens[Math.floor(Math.random() * activeAliens.length)];
            if (randomAlien) {
                alienBullets.push(new Bullet(randomAlien.x + randomAlien.width/2, randomAlien.y + randomAlien.height, false));
            }
        }
    }

    // Move Aliens
    if (alienMoveTimer >= alienMoveInterval) {
        alienMoveTimer = 0;
        
        let hitEdge = false;
        let lowestY = 0;

        // Check edges first
        for (let alien of aliens) {
            if (!alien.active) continue;
            if ((alien.x <= 10 && alienDirection === -1) || 
                (alien.x >= GAME_WIDTH - alien.width - 10 && alienDirection === 1)) {
                hitEdge = true;
            }
            lowestY = Math.max(lowestY, alien.y);
        }

        // Check Game Over conditions
        if (lowestY >= player.y - 20) {
            gameOver = true;
        }

        if (hitEdge) {
            alienDirection *= -1;
            for (let alien of aliens) {
                if (alien.active) alien.y += 20; // Drop down
            }
        } else {
            // Move horizontally
            for (let alien of aliens) {
                if (alien.active) alien.x += 15 * alienDirection;
            }
        }
    }

    // Check Alien Bullet collisions with Player
    for (let bullet of alienBullets) {
        if (bullet.active && 
            bullet.x < player.x + player.width &&
            bullet.x + bullet.width > player.x &&
            bullet.y < player.y + player.height &&
            bullet.y + bullet.height > player.y) {
            
            bullet.active = false;
            lives--;
            createExplosion(player.x + player.width/2, player.y + player.height/2, '#00ff00', 20);
            
            if (lives <= 0) {
                gameOver = true;
            } else {
                // Reset player position slightly or give invulnerability
                player.bullet = null;
                alienBullets = []; // Clear bullets to prevent cheap deaths
            }
        }

        // Check Alien Bullet vs Bunkers
        if (bullet.active) {
            for (let bunker of bunkers) {
                if (bunker.checkCollision(bullet)) break;
            }
        }
    }

    // Check Win Condition
    const remainingAliens = aliens.filter(a => a.active).length;
    if (remainingAliens === 0 && !gameWon) {
        gameWon = true;
        level++;
        alienMoveInterval = Math.max(5, alienMoveInterval - 10); // Start next level faster
        initAliens();
        initBunkers(); // Rebuild bunkers? Original game didn't always rebuild them perfectly, but let's keep it fair.
    }

    // Update Particles
    particles.forEach(p => p.update());
    particles = particles.filter(p => p.life > 0);
}

// --- DRAWING ---

function draw() {
    // Clear Screen
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    // Draw Stars (Background)
    ctx.fillStyle = '#555';
    for(let i=0; i<20; i++) {
        // Simple static stars based on frame to avoid array
        const x = (i * 37 + frameCount) % GAME_WIDTH;
        const y = (i * 13) % GAME_HEIGHT;
        ctx.fillRect(x, y, 2, 2);
    }

    if (gameOver || gameWon) {
        ctx.fillStyle = '#fff';
        ctx.font = '40px "Courier New"';
        ctx.textAlign = 'center';
        
        let text = gameOver ? "GAME OVER" : "YOU WIN!";
        if (gameOver) ctx.fillStyle = 'red';
        else ctx.fillStyle = '#00ff00';
        
        ctx.fillText(text, GAME_WIDTH/2, GAME_HEIGHT/2);
        ctx.fillStyle = '#aaa';
        ctx.font = '20px "Courier New"';
        ctx.fillText("Press SPACE to Restart", GAME_WIDTH/2, GAME_HEIGHT/2 + 50);
    } else {
        // Draw Player
        drawSprite(ctx, SPRITES.octopus, player.x, player.y, 3, player.color, frameCount);

        // Draw Aliens
        aliens.forEach(alien => {
            if (alien.active) {
                drawSprite(ctx, SPRITES[alien.spriteKey], alien.x, alien.y, 3, alien.color, frameCount);
            }
        });

        // Draw UFO
        if (ufo && ufo.active) ufo.draw();

        // Draw Bunkers
        bunkers.forEach(bunker => bunker.draw());

        // Draw Bullets
        if (player.bullet && player.bullet.active) player.bullet.draw();
        alienBullets.forEach(b => b.draw());

        // Draw Particles
        particles.forEach(p => p.draw());
    }

    // UI: Score & Lives
    ctx.fillStyle = '#fff';
    ctx.font = '20px "Courier New"';
    ctx.textAlign = 'left';
    ctx.fillText(`SCORE: ${score}`, 20, 30);
    
    ctx.textAlign = 'right';
    ctx.fillText(`LIVES: ${lives}`, GAME_WIDTH - 20, 30);

    // Level Indicator
    if (!gameOver && !gameWon) {
        ctx.font = '16px "Courier New"';
        ctx.fillStyle = '#aaa';
        ctx.textAlign = 'center';
        ctx.fillText(`LEVEL ${level}`, GAME_WIDTH/2, 50);
    }
}

// --- MAIN LOOP ---
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// Start
initAliens();
initBunkers();
loop();

</script>
</body>
</html>