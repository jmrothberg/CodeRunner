<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Voxel Engine (Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; user-select: none; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: white; transform: translate(-50%, -50%); border-radius: 50%;
        }
        #ui-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 10; }
        .slot {
            width: 50px; height: 50px; background: rgba(0, 0, 0, 0.5); border: 2px solid #555;
            display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; cursor: pointer;
        }
        .slot.active { border-color: gold; transform: scale(1.1); background: rgba(50, 50, 50, 0.8); }
        
        /* Changed from div to canvas styling */
        #minimap {
            position: absolute; top: 20px; right: 20px; width: 150px; height: 150px;
            border: 3px solid #333; background: #000; z-index: 10;
        }
        
        #info {
            position: absolute; top: 20px; left: 20px; color: white; text-shadow: 1px 1px 2px black; pointer-events: none; z-index: 10;
        }
        #blocker {
            position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);
            display: flex; justify-content: center; align-items: center; color: white; font-size: 24px; z-index: 20;
        }
    </style>
</head>
<body>

<div id="crosshair"></div>
<div id="info">
    <h2>Voxel Engine (Fixed)</h2>
    <p>WASD/Arrows: Move | Space: Jump/Fly</p>
    <p>Shift: Sneak/Crouch</p>
    <p>L-Click: Break | R-Click: Place</p>
    <p>1-9: Select Block | E: Toggle Creative Mode</p>
</div>

<!-- Changed div to canvas -->
<canvas id="minimap" width="150" height="150"></canvas>

<div id="ui-container">
    <!-- Generated by JS -->
</div>

<div id="blocker">
    <div>Click to Play</div>
</div>

<!-- Import Three.js and Simplex Noise from CDN -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { createNoise2D } from 'simplex-noise';

// --- CONFIGURATION ---
const WORLD_SIZE = 64; 
const CHUNK_HEIGHT = 64;
const BLOCK_SIZE = 1;

// Block IDs
const BEDROCK = 0, DIRT = 1, GRASS = 2, STONE = 3, WOOD = 4, LEAVES = 5, SAND = 6, WATER = 7, COBBLE = 8;
const AIR = 0;

// Block Properties
const BLOCKS = {
    [BEDROCK]: { name: 'Bedrock', color: 0x111111, solid: true },
    [DIRT]: { name: 'Dirt', color: 0x5d4037, solid: true },
    [GRASS]: { name: 'Grass', color: 0x4caf50, solid: true, topColor: 0x76ff03 },
    [STONE]: { name: 'Stone', color: 0x757575, solid: true },
    [WOOD]: { name: 'Wood', color: 0x795548, solid: true },
    [LEAVES]: { name: 'Leaves', color: 0x2e7d32, solid: true, transparent: true },
    [SAND]: { name: 'Sand', color: 0xffeb3b, solid: true },
    [WATER]: { name: 'Water', color: 0x29b6f6, solid: false, transparent: true },
    [COBBLE]: { name: 'Cobblestone', color: 0x616161, solid: true }
};

// --- GLOBALS ---
let camera, scene, renderer;
let worldData = {}; // Sparse voxel storage "x,y,z": type
let noise2D;
let player = { x: WORLD_SIZE/2, y: 30, z: WORLD_SIZE/2, vy: 0, onGround: false, creative: false, flying: false };
let keys = {};
let selectedBlock = GRASS;
let meshes = {}; 
let raycaster;
let particles = [];
let sunLight, ambientLight;
let time = 0;
let isGenerating = true; // Flag to prevent mesh rebuilding during generation

// --- TEXTURE GENERATION ---
function createTexture(color, type = 'solid') {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = '#' + new THREE.Color(color).getHexString();
    ctx.fillRect(0, 0, 64, 64);
    
    if(type !== 'flat') {
        for(let i=0; i<200; i++) {
            ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.1})`;
            ctx.fillRect(Math.random()*64, Math.random()*64, 4, 4);
            ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.1})`;
            ctx.fillRect(Math.random()*64, Math.random()*64, 4, 4);
        }
    }

    if (type === 'grass') {
        const grad = ctx.createLinearGradient(0,0,0,64);
        grad.addColorStop(0, '#76ff03');
        grad.addColorStop(1, '#5d4037');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 32, 64, 32); 
    }
    
    const tex = new THREE.CanvasTexture(canvas);
    tex.magFilter = THREE.NearestFilter;
    return tex;
}

function initTextures() {
    const mats = {};
    Object.keys(BLOCKS).forEach(id => {
        const b = BLOCKS[id];
        mats[id] = new THREE.MeshStandardMaterial({ 
            map: createTexture(b.color, b.name === 'Grass' ? 'grass' : 'solid'),
            transparent: b.transparent || false,
            opacity: b.transparent ? 0.8 : 1.0
        });
    });
    return mats;
}

const materials = initTextures();

// --- WORLD GENERATION ---
function getBlock(x, y, z) {
    if (x < 0 || x >= WORLD_SIZE || y < 0 || y >= CHUNK_HEIGHT || z < 0 || z >= WORLD_SIZE) return 0; 
    return worldData[`${x},${y},${z}`] || 0;
}

function setBlock(x, y, z, type) {
    if (x < 0 || x >= WORLD_SIZE || y < 0 || y >= CHUNK_HEIGHT || z < 0 || z >= WORLD_SIZE) return;
    
    // Update Data Only
    worldData[`${x},${y},${z}`] = type;

    // If not generating, rebuild meshes (User interaction)
    if (!isGenerating) {
        rebuildAllMeshes();
    }
}

function generateTree(x, y, z) {
    const height = 4 + Math.floor(Math.random() * 3);
    for (let i = 0; i < height; i++) setBlock(x, y + i, z, WOOD);
    for (let ly = y + height - 2; ly <= y + height; ly++) {
        for (let lx = x - 2; lx <= x + 2; lx++) {
            for (let lz = z - 2; lz <= z + 2; lz++) {
                if (Math.abs(lx-x) === 2 && Math.abs(lz-z) === 2 && Math.random() > 0.5) continue;
                if (getBlock(lx, ly, lz) === AIR) setBlock(lx, ly, lz, LEAVES);
            }
        }
    }
}

function generateWorld() {
    noise2D = createNoise2D();
    
    for (let x = 0; x < WORLD_SIZE; x++) {
        for (let z = 0; z < WORLD_SIZE; z++) {
            const scale = 0.05;
            let n = noise2D(x * scale, z * scale);
            
            let h = Math.floor((n + 1) * 15) + 10; 
            
            if (h < 12) { // Water
                for(let y=0; y<12; y++) setBlock(x, y, z, WATER);
                setBlock(x, 0, z, BEDROCK); 
            } else {
                let top = h;
                if (top >= CHUNK_HEIGHT - 1) top = CHUNK_HEIGHT - 2;

                for(let y=0; y<top; y++) {
                    if(y === 0) setBlock(x, y, z, BEDROCK);
                    else if (y > top - 4) setBlock(x, y, z, STONE); 
                    else setBlock(x, y, z, DIRT);
                }
                
                let surface = getBlock(x, top, z);
                if(surface === AIR || surface === WATER) {
                     if (h > 25) setBlock(x, top, z, STONE); 
                     else if (h > 18) setBlock(x, top, z, COBBLE); 
                     else if (h > 15) setBlock(x, top, z, SAND); 
                     else setBlock(x, top, z, GRASS);
                }

                if (h > 14 && h < 22 && Math.random() < 0.05) {
                    generateTree(x, top + 1, z);
                }
            }
        }
    }
    
    // Generation Complete - Build Meshes Once
    isGenerating = false;
    initWorldMeshes();
}

// --- RENDERING SYSTEM ---
function initWorldMeshes() {
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    
    Object.keys(BLOCKS).forEach(id => {
        if (meshes[id]) scene.remove(meshes[id]); // Cleanup old meshes if any
        
        const mesh = new THREE.InstancedMesh(geometry, materials[id], WORLD_SIZE * CHUNK_HEIGHT * WORLD_SIZE);
        mesh.count = 0;
        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        meshes[id] = mesh;
        scene.add(mesh);
    });

    rebuildAllMeshes();
}

function rebuildAllMeshes() {
    // Reset counts
    Object.keys(meshes).forEach(k => { meshes[k].count = 0; });
    
    const dummy = new THREE.Object3D();
    
    for (let key in worldData) {
        const type = parseInt(worldData[key]);
        if (!type || !meshes[type]) continue;
        
        const [x, y, z] = key.split(',').map(Number);
        
        dummy.position.set(x + 0.5, y + 0.5, z + 0.5);
        dummy.updateMatrix();
        
        meshes[type].setMatrixAt(meshes[type].count, dummy.matrix);
        meshes[type].count++;
    }
    
    Object.values(meshes).forEach(m => {
        m.instanceMatrix.needsUpdate = true;
        m.geometry.computeBoundingSphere(); 
    });
}

// --- INPUT & CONTROLS ---
function initControls() {
    document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        
        if (e.key >= '1' && e.key <= '9') {
            selectedBlock = parseInt(e.key);
            updateHotbar();
        }
        if (e.code === 'KeyE') {
            player.creative = !player.creative;
            player.flying = player.creative;
            document.getElementById('info').innerHTML += `<p style="color:gold">Creative Mode: ${player.creative ? 'ON' : 'OFF'}</p>`;
        }
    });
    
    document.addEventListener('keyup', (e) => keys[e.code] = false);
    
    const blocker = document.getElementById('blocker');
    const canvas = renderer.domElement;

    blocker.addEventListener('click', () => {
        canvas.requestPointerLock();
    });

    document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement === canvas) {
            blocker.style.display = 'none';
        } else {
            blocker.style.display = 'flex';
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement !== canvas) return;
        
        const sensitivity = 0.002;
        camera.rotation.y -= e.movementX * sensitivity;
        camera.rotation.x -= e.movementY * sensitivity;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    });

    document.addEventListener('mousedown', (e) => {
        if (document.pointerLockElement !== canvas) return;
        
        const isRightClick = e.button === 2;
        const isLeftClick = e.button === 0;

        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        performVoxelInteraction(isLeftClick, isRightClick);
    });

    window.addEventListener('contextmenu', e => e.preventDefault());
}

function performVoxelInteraction(destroy, place) {
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    
    // Simple raymarch
    const maxDist = 6;
    let hitBlock = null;

    for(let i=0; i<maxDist*10; i++) {
        const cx = Math.floor(player.x + dir.x * (i/10));
        const cy = Math.floor(player.y - 1.5 + dir.y * (i/10)); 
        const cz = Math.floor(player.z + dir.z * (i/10));
        
        const b = getBlock(cx, cy, cz);
        if(b !== AIR && b !== WATER) {
            hitBlock = {x: cx, y: cy, z: cz, type: b};
            break;
        }
    }

    if(destroy && hitBlock) {
        if(hitBlock.type === BEDROCK) return;
        
        spawnParticles(hitBlock.x + 0.5, hitBlock.y + 0.5, hitBlock.z + 0.5, BLOCKS[hitBlock.type].color);
        setBlock(hitBlock.x, hitBlock.y, hitBlock.z, AIR);
    }
    
    if(place && hitBlock) {
        const nx = hitBlock.x + Math.floor(dir.x);
        const ny = hitBlock.y + Math.floor(dir.y);
        const nz = hitBlock.z + Math.floor(dir.z);
        
        // Collision check
        if (Math.abs(nx - player.x) < 0.8 && Math.abs(ny - (player.y-1)) < 1.5 && Math.abs(nz - player.z) < 0.8) {
            return; 
        }

        setBlock(nx, ny, nz, selectedBlock);
    }
}

// --- PHYSICS ---
function updatePhysics(dt) {
    const speed = player.creative ? 10 : 5;
    let dx = 0, dz = 0;

    if (keys['ArrowUp'] || keys['KeyW']) dz -= 1;
    if (keys['ArrowDown'] || keys['KeyS']) dz += 1;
    if (keys['ArrowLeft'] || keys['KeyA']) dx -= 1;
    if (keys['ArrowRight'] || keys['KeyD']) dx += 1;

    const cos = Math.cos(camera.rotation.y);
    const sin = Math.sin(camera.rotation.y);
    
    let vx = (dx * cos - dz * sin) * speed * dt;
    let vz = (dx * sin + dz * cos) * speed * dt;

    if (player.flying) {
        if (keys['Space']) player.y += speed * dt;
        if (keys['ShiftLeft'] || keys['ShiftRight']) player.y -= speed * dt;
        
        player.x += vx;
        player.z += vz;
    } else {
        player.vy -= 25 * dt; 
        
        let nextX = player.x + vx;
        let nextZ = player.z + vz;
        let nextY = player.y + player.vy * dt;

        const padding = 0.3;
        const height = 1.8; 
        
        if (!checkCollision(nextX, player.y - height/2, player.z, padding)) player.x = nextX;
        else vx = 0;
        
        if (!checkCollision(player.x, player.y - height/2, nextZ, padding)) player.z = nextZ;
        else vz = 0;

        if (checkCollision(player.x, nextY - height/2, player.z, padding)) {
            if (player.vy < 0) {
                player.onGround = true;
                const by = Math.floor(nextY);
                player.y = by + 1 + height/2; 
            }
            player.vy = 0;
        } else {
            player.y = nextY;
            player.onGround = false;
        }

        if (keys['Space'] && player.onGround) {
            player.vy = 8; 
            player.onGround = false;
        }
        
        if(player.y < -10) { player.y = 50; player.vy = 0; } 
    }

    camera.position.set(player.x, player.y, player.z);
}

function checkCollision(x, y, z, padding) {
    const minX = Math.floor(x - padding);
    const maxX = Math.floor(x + padding);
    const minY = Math.floor(y);
    const maxY = Math.floor(y + 1.8); 
    const minZ = Math.floor(z - padding);
    const maxZ = Math.floor(z + padding);

    for (let bx = minX; bx <= maxX; bx++) {
        for (let by = minY; by <= maxY; by++) {
            for (let bz = minZ; bz <= maxZ; bz++) {
                const b = getBlock(bx, by, bz);
                if (b !== AIR && b !== WATER) return true;
            }
        }
    }
    return false;
}

// --- UI & MINIMAP ---
function initUI() {
    const container = document.getElementById('ui-container');
    Object.keys(BLOCKS).forEach((id, index) => {
        if(index > 8) return;
        const div = document.createElement('div');
        div.className = 'slot';
        div.innerText = index + 1;
        div.style.borderColor = '#' + new THREE.Color(BLOCKS[id].color).getHexString();
        div.onclick = () => { selectedBlock = parseInt(id); updateHotbar(); };
        container.appendChild(div);
    });
    updateHotbar();
}

function updateHotbar() {
    const slots = document.querySelectorAll('.slot');
    let blockIndex = Object.keys(BLOCKS).indexOf(String(selectedBlock));
    if(blockIndex > 8) blockIndex = 0;
    
    slots.forEach(s => s.classList.remove('active'));
    if(slots[blockIndex]) slots[blockIndex].classList.add('active');
}

function updateMinimap() {
    const cvs = document.getElementById('minimap');
    // Ensure it's a canvas
    if (!cvs || cvs.tagName !== 'CANVAS') return;

    const ctx = cvs.getContext('2d');
    
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 150, 150);
    
    const scale = 150 / WORLD_SIZE;
    
    for(let x=0; x<WORLD_SIZE; x+=2) {
        for(let z=0; z<WORLD_SIZE; z+=2) {
            const b = getBlock(x, 10, z); 
            if(b !== AIR && b !== WATER) {
                ctx.fillStyle = '#' + new THREE.Color(BLOCKS[b].color).getHexString();
                ctx.fillRect(x*scale, z*scale, scale*2, scale*2);
            } else {
                 ctx.fillStyle = '#000044'; 
                 ctx.fillRect(x*scale, z*scale, scale*2, scale*2);
            }
        }
    }
    
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(player.x * scale, player.z * scale, 3, 0, Math.PI*2);
    ctx.fill();
}

// --- PARTICLES ---
function spawnParticles(x, y, z, color) {
    for(let i=0; i<8; i++) {
        const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
        const mat = new THREE.MeshBasicMaterial({ color: color });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, y, z);
        
        mesh.userData.vel = new THREE.Vector3(
            (Math.random()-0.5)*0.2,
            Math.random()*0.2,
            (Math.random()-0.5)*0.2
        );
        mesh.userData.life = 1.0;
        
        scene.add(mesh);
        particles.push(mesh);
    }
}

function updateParticles(dt) {
    for(let i=particles.length-1; i>=0; i--) {
        const p = particles[i];
        p.position.add(p.userData.vel);
        p.userData.vel.y -= 9.8 * dt; 
        p.userData.life -= dt;
        
        if(p.userData.life <= 0) {
            scene.remove(p);
            particles.splice(i, 1);
        }
    }
}

// --- MAIN LOOP ---
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    sunLight = new THREE.DirectionalLight(0xffffff, 1);
    sunLight.position.set(50, 100, 50);
    sunLight.castShadow = true;
    sunLight.shadow.camera.left = -50;
    sunLight.shadow.camera.right = 50;
    sunLight.shadow.camera.top = 50;
    sunLight.shadow.camera.bottom = -50;
    scene.add(sunLight);

    // Generate World (Sets isGenerating=true, builds meshes at end)
    generateWorld();

    raycaster = new THREE.Raycaster();
    initControls();
    initUI();
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
}

function animate() {
    requestAnimationFrame(animate);

    const dt = 0.016; 
    time += dt;

    updatePhysics(dt);
    updateParticles(dt);
    
    // Day/Night Cycle
    const cycleSpeed = 0.1;
    sunLight.position.x = Math.sin(time * cycleSpeed) * 50;
    sunLight.position.y = Math.cos(time * cycleSpeed) * 50;
    
    const skyH = (Math.sin(time * cycleSpeed) + 1) / 2; 
    if(skyH > 0.5) {
        scene.background.setHSL(0.6, 0.5, 0.5 * skyH); 
        scene.fog.color.setHSL(0.6, 0.5, 0.5 * skyH);
    } else {
        scene.background.setHSL(0.7, 0.5, 0.1); 
        scene.fog.color.setHex(0x050510);
    }
    
    sunLight.intensity = Math.max(0, skyH);

    updateMinimap();
    renderer.render(scene, camera);
}

init();

</script>
</body>
</html>