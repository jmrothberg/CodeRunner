<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Asteroids (1979 Tribute)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            background-color: #000;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            pointer-events: none;
            font-size: 20px;
            text-shadow: 0 0 5px #fff;
        }
        #start-screen {
            position: absolute;
            color: white;
            text-align: center;
            text-shadow: 0 0 10px #fff;
            z-index: 10;
        }
        h1 { font-size: 60px; margin-bottom: 10px; letter-spacing: 5px; }
        p { font-size: 20px; margin-bottom: 30px; }
    </style>
</head>
<body>

<div id="start-screen">
    <h1>ASTEROIDS</h1>
    <p>Press SPACE to Start</p>
    <p style="font-size: 16px">Arrows/WASD to Move &bull; Space to Shoot</p>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * ASTEROIDS (1979 FAITHFUL RECREATION)
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Set Canvas Size
let WIDTH = 800;
let HEIGHT = 600;
function resize() {
    // Maintain aspect ratio or fill screen? Let's do fixed size for arcade feel
    WIDTH = window.innerWidth - 40;
    HEIGHT = window.innerHeight - 40;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
}
window.addEventListener('resize', resize);
resize();

// --- Game Constants ---
const FPS = 60;
const FRICTION = 0.98; // Space isn't perfect vacuum in this game (inertia dampening)
const SHIP_SIZE = 20; 
const TURN_SPEED = 360; // Degrees per second
const THRUST = 5; // Acceleration pixels per second per second
const BULLET_SPEED = 500;
const ASTEROID_NUM = 4; // Starting asteroids
const ASTEROID_SIZE = 100;
const ASTEROID_VERTICES = 12; // Jaggedness
const ASTEROID_JAG = 0.5; // Randomness of shape
const UFO_CHANCE = 0.001; // Chance per frame to spawn UFO
const LARGE_UFO_SPEED = 150;
const SMALL_UFO_SPEED = 350;

// --- Game State ---
// FIX: Initialize score and lives to prevent undefined errors in UI/Draw logic
let ship, asteroids, bullets, ufo, particles, level, score = 0, highScore = 0, lives = 3, textAlpha = 0, textFadeTime;
let gameRunning = false;
let keys = {
    ArrowUp: false,
    ArrowLeft: false,
    ArrowRight: false,
    w: false,
    a: false,
    d: false,
    Space: false
};

// --- Input Handling ---
document.addEventListener('keydown', keyDown);
document.addEventListener('keyup', keyUp);

function keyDown(ev) {
    if(ev.code === "Space" && !gameRunning) {
        startGame();
    }
    
    if (keys.hasOwnProperty(ev.key) || keys.hasOwnProperty(ev.code)) {
        keys[ev.key] = true;
        if(ev.code === 'Space') keys.Space = true;
    }
}

function keyUp(ev) {
    if (keys.hasOwnProperty(ev.key) || keys.hasOwnProperty(ev.code)) {
        keys[ev.key] = false;
        if(ev.code === 'Space') keys.Space = false;
        
        // Prevent machine gun firing
        if (ev.code === "Space" && ship) {
            ship.canShoot = true;
        }
    }
}

// --- Classes ---

class Ship {
    constructor() {
        this.x = WIDTH / 2;
        this.y = HEIGHT / 2;
        this.r = SHIP_SIZE / 2; // Radius
        this.a = 90 / 180 * Math.PI; // Angle (radians), pointing up
        this.rot = 0; // Rotation speed
        this.thrusting = false;
        this.canShoot = true;
        this.blinkNum = Math.ceil(FPS / 10);
        this.blinkTime = Math.ceil(FPS * 0.1);
        this.invulnerable = FPS * 3; // Invincibility frames on spawn
        this.dead = false;
        
        // Initialize velocity
        this.xv = 0;
        this.yv = 0;
    }

    update(dt) {
        if (this.dead) return;

        // Rotation
        if (keys.ArrowLeft || keys.a) this.rot = TURN_SPEED / 180 * Math.PI / FPS;
        else if (keys.ArrowRight || keys.d) this.rot = -TURN_SPEED / 180 * Math.PI / FPS;
        else this.rot = 0;

        this.a += this.rot;

        // Thrust
        this.thrusting = (keys.ArrowUp || keys.w);

        if (this.thrusting && !this.dead) {
            const thrustVector = {
                x: Math.cos(this.a) * THRUST / FPS,
                y: -Math.sin(this.a) * THRUST / FPS
            };
            this.xv += thrustVector.x;
            this.yv += thrustVector.y;
            
            // Add exhaust particles
            if(Math.random() < 0.5) {
                createParticles(
                    this.x - Math.cos(this.a) * this.r + (Math.random()-0.5)*5, 
                    this.y + Math.sin(this.a) * this.r + (Math.random()-0.5)*5, 
                    1, "#ffa500"
                );
            }
        }

        // Physics
        this.x += this.xv;
        this.y += this.yv;

        // Friction
        this.xv *= FRICTION;
        this.yv *= FRICTION;

        // Screen Wrap
        if (this.x < 0 - this.r) this.x = WIDTH + this.r;
        else if (this.x > WIDTH + this.r) this.x = 0 - this.r;
        if (this.y < 0 - this.r) this.y = HEIGHT + this.r;
        else if (this.y > HEIGHT + this.r) this.y = 0 - this.r;

        // Shooting
        if (keys.Space && this.canShoot) {
            shootBullet();
            this.canShoot = false; // Semi-automatic
        }
        
        if (!keys.Space) this.canShoot = true;
        
        if(this.invulnerable > 0) this.invulnerable--;
    }

    draw() {
        if (this.dead) return;
        
        // Blink if invulnerable
        if (this.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0) return;

        ctx.strokeStyle = "white";
        ctx.lineWidth = SHIP_SIZE / 20;
        ctx.beginPath();

        // Nose
        ctx.moveTo( 
            this.x + 4/3 * this.r * Math.cos(this.a),
            this.y - 4/3 * this.r * Math.sin(this.a)
        );
        // Rear Left
        ctx.lineTo( 
            this.x - this.r * (2/3 * Math.cos(this.a) + Math.sin(this.a)),
            this.y + this.r * (2/3 * Math.sin(this.a) - Math.cos(this.a))
        );
        // Rear Right
        ctx.lineTo( 
            this.x - this.r * (2/3 * Math.cos(this.a) - Math.sin(this.a)),
            this.y + this.r * (2/3 * Math.sin(this.a) + Math.cos(this.a))
        );
        ctx.closePath();
        ctx.stroke();

        // Thrust Flame
        if (this.thrusting) {
            ctx.strokeStyle = "orange";
            ctx.fillStyle = "white"; // Core of flame
            ctx.beginPath();
            
            // Randomize flame length for animation
            const flicker = Math.random() * 10 + 15;
            
            // Rear Center
            let tx = this.x - this.r * (2/3 * Math.cos(this.a));
            let ty = this.y + this.r * (2/3 * Math.sin(this.a));

            ctx.moveTo(
                tx - this.r/2 * Math.cos(this.a), 
                ty + this.r/2 * Math.sin(this.a)
            );
            
            // Tip of flame
            ctx.lineTo(
                this.x - this.r * flicker/1.5 * Math.cos(this.a),
                this.y + this.r * flicker/1.5 * Math.sin(this.a)
            );
             ctx.stroke();
        }
    }
}

class Bullet {
    constructor(x, y, a) {
        this.x = x;
        this.y = y;
        this.xv = BULLET_SPEED * Math.cos(a) / FPS;
        this.yv = -BULLET_SPEED * Math.sin(a) / FPS;
        this.distTraveled = 0;
        this.maxDist = WIDTH * 0.8; // Range
    }

    update() {
        this.x += this.xv;
        this.y += this.yv;

        // Handle Screen Wrap for bullets
        if (this.x < 0) this.x = WIDTH;
        else if (this.x > WIDTH) this.x = 0;
        if (this.y < 0) this.y = HEIGHT;
        else if (this.y > HEIGHT) this.y = 0;

        this.distTraveled += Math.hypot(this.xv, this.yv);
    }

    draw() {
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2, false);
        ctx.fill();
    }
}

class Asteroid {
    constructor(x, y, r) {
        this.x = x;
        this.y = y;
        this.r = r || Math.ceil(Math.random() * ASTEROID_SIZE / 2 + ASTEROID_SIZE / 2);
        
        // Random velocity
        const lvlMult = 1 + 0.1 * level;
        this.xv = Math.random() * this.r * lvlMult / FPS * (Math.random() < 0.5 ? 1 : -1);
        this.yv = Math.random() * this.r * lvlMult / FPS * (Math.random() < 0.5 ? 1 : -1);
        
        this.a = Math.random() * Math.PI * 2; // Angle
        this.vert = Math.floor(Math.random() * (ASTEROID_VERTICES + 1) + ASTEROID_VERTICES / 2); // Vertices count
        this.offs = []; // Vertex offsets for jagged shape
        
        // Create Jagged Shape
        for (let i = 0; i < this.vert; i++) {
            this.offs.push(Math.random() * ASTEROID_JAG * 2 + 1 - ASTEROID_JAG);
        }
        
        this.rotSpeed = Math.random() * 30 / FPS * (Math.random() < 0.5 ? 1 : -1); // Rotation speed
    }

    update() {
        this.x += this.xv;
        this.y += this.yv;
        this.a += this.rotSpeed;

        // Screen Wrap
        if (this.x < 0 - this.r) this.x = WIDTH + this.r;
        else if (this.x > WIDTH + this.r) this.x = 0 - this.r;
        if (this.y < 0 - this.r) this.y = HEIGHT + this.r;
        else if (this.y > HEIGHT + this.r) this.y = 0 - this.r;
    }

    draw() {
        ctx.strokeStyle = "white";
        ctx.lineWidth = SHIP_SIZE / 20;
        ctx.beginPath();
        for (let i = 0; i < this.vert; i++) {
            const angle = (Math.PI * 2) / this.vert * i + this.a;
            const r = this.r * this.offs[i];
            const x = this.x + r * Math.cos(angle);
            const y = this.y + r * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
    }
}

class UFO {
    constructor(type) {
        this.type = type; // 'large' or 'small'
        
        // Pick random side to spawn
        if (Math.random() < 0.5) {
            this.x = -50;
            this.xv = (type === 'large' ? LARGE_UFO_SPEED : SMALL_UFO_SPEED) / FPS;
        } else {
            this.x = WIDTH + 50;
            this.xv = (type === 'large' ? -LARGE_UFO_SPEED : -SMALL_UFO_SPEED) / FPS;
        }
        
        this.y = Math.random() * HEIGHT * 0.8 + HEIGHT * 0.1; // Random height
        this.r = type === 'large' ? 40 : 20;
        this.dead = false;
        this.shootTimer = 0;
    }

    update(dt) {
        if (this.dead) return;

        this.x += this.xv;
        
        // Despawn if off screen
        if ((this.xv > 0 && this.x > WIDTH + 100) || (this.xv < 0 && this.x < -100)) {
            ufo = null; 
            return;
        }

        // Shooting Logic
        this.shootTimer++;
        
        let fireRate = this.type === 'large' ? 120 : 40; // Frames between shots
        
        if (this.shootTimer > fireRate) {
            this.shoot();
            this.shootTimer = 0;
        }
    }

    shoot() {
        // Large UFO fires randomly or vaguely towards center
        // Small UFO aims precisely at player
        
        let tx = ship.x;
        let ty = ship.y;
        
        if (this.type === 'large') {
             // Add some randomness to large UFO shots
             tx += (Math.random() - 0.5) * WIDTH/2;
             ty += (Math.random() - 0.5) * HEIGHT/2;
        }

        const angle = Math.atan2(-(ty - this.y), tx - this.x); // Canvas Y is inverted
        const speed = this.type === 'large' ? BULLET_SPEED * 0.6 : BULLET_SPEED * 0.8;
        
        bullets.push(new Bullet(this.x, this.y + (this.type==='large'?10:5), angle));
        bullets[bullets.length-1].xv *= 0.5; // Slower bullets for balance
        bullets[bullets.length-1].color = "white"; 
    }

    draw() {
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        
        if (this.type === 'large') {
            // Draw Ellipse + Dome
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, this.r, this.r/2.5, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Dome
            ctx.beginPath();
            ctx.arc(this.x, this.y - 10, this.r/3, Math.PI, 0); 
            ctx.stroke();
        } else {
            // Small saucer
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, this.r, this.r/2, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Dome
            ctx.beginPath();
            ctx.arc(this.x, this.y - 5, this.r/2, Math.PI, 0); 
            ctx.stroke();
        }
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.xv = (Math.random() - 0.5) * (Math.random() * 10);
        this.yv = (Math.random() - 0.5) * (Math.random() * 10);
        this.life = Math.random() * FPS + 20; // Frames to live
        this.color = color || "white";
    }
    
    update() {
        this.x += this.xv;
        this.y += this.yv;
        this.life--;
    }
    
    draw() {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 50;
        if(ctx.globalAlpha > 1) ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.rect(this.x, this.y, 2, 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

// --- Game Functions ---

function createParticles(x, y, count, color="white") {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function shootBullet() {
    if (ship.dead) return;
    
    // Shoot from nose
    const bx = ship.x + 4/3 * ship.r * Math.cos(ship.a);
    const by = ship.y - 4/3 * ship.r * Math.sin(ship.a);
    bullets.push(new Bullet(bx, by, ship.a));
}

function distBetweenPoints(x1, y1, x2, y2) {
    return Math.hypot(x2 - x1, y2 - y1);
}

function explodeAsteroid(index) {
    const x = asteroids[index].x;
    const y = asteroids[index].y;
    const r = asteroids[index].r;

    // Split asteroid
    if (r > Math.ceil(ASTEROID_SIZE / 3)) { 
        // Was Large -> becomes Medium
        asteroids.push(new Asteroid(x, y, Math.ceil(ASTEROID_SIZE / 2)));
        asteroids.push(new Asteroid(x, y, Math.ceil(ASTEROID_SIZE / 2)));
        score += 20;
    } else if (r > Math.ceil(ASTEROID_SIZE / 5)) {
        // Was Medium -> becomes Small
        asteroids.push(new Asteroid(x, y, Math.ceil(ASTEROID_SIZE / 3.5)));
        asteroids.push(new Asteroid(x, y, Math.ceil(ASTEROID_SIZE / 3.5)));
        score += 50;
    } else {
        // Was Small -> Dust
        score += 100;
    }

    createParticles(x, y, 10);
    asteroids.splice(index, 1);

    // Level Clear
    if (asteroids.length === 0) {
        level++;
        spawnAsteroids();
    }
}

function destroyUFO() {
    createParticles(ufo.x, ufo.y, 30, "#fff");
    score += ufo.type === 'large' ? 200 : 1000;
    
    // Check Extra Life
    if (score >= 10000 && lives < 7) { 
        lives++;
        showMessage("EXTRA SHIP");
    }
    
    ufo = null;
}

function spawnAsteroids() {
    asteroids = [];
    let x, y;
    for (let i = 0; i < ASTEROID_NUM + level; i++) {
        // Ensure we don't spawn on top of player
        do {
            x = Math.floor(Math.random() * WIDTH);
            y = Math.floor(Math.random() * HEIGHT);
        } while (distBetweenPoints(ship.x, ship.y, x, y) < ASTEROID_SIZE * 2 + ship.r);
        
        asteroids.push(new Asteroid(x, y));
    }
}

function gameOver() {
    gameRunning = false;
    document.getElementById('start-screen').style.display = 'block';
    document.querySelector('#start-screen h1').innerText = "GAME OVER";
    document.querySelector('#start-screen p').innerText = `Score: ${score} - Press SPACE`;
}

function showMessage(msg) {
    textAlpha = 1.0;
    textFadeTime = FPS * 2;
    // We could draw this in the loop
}

function startGame() {
    score = 0;
    level = 0;
    lives = 3;
    ship = new Ship();
    bullets = [];
    particles = [];
    ufo = null;
    
    spawnAsteroids();
    gameRunning = true;
    document.getElementById('start-screen').style.display = 'none';
    
    // Check for extra life immediately at 0? No, usually starts below.
}

// --- Main Loop ---

function update() {
    if (!gameRunning) return;

    ship.update();

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].update();
        
        // Remove if traveled too far
        if (bullets[i].distTraveled > bullets[i].maxDist) {
            bullets.splice(i, 1);
            continue;
        }
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        if(particles[i].life <= 0) particles.splice(i, 1);
    }

    // Asteroids
    for (let i = asteroids.length - 1; i >= 0; i--) {
        const a = asteroids[i];
        a.update();

        // Collision: Bullet vs Asteroid
        for (let j = bullets.length - 1; j >= 0; j--) {
            if (distBetweenPoints(a.x, a.y, bullets[j].x, bullets[j].y) < a.r) {
                bullets.splice(j, 1); // Remove bullet
                explodeAsteroid(i);
                break; // Asteroid is gone, stop checking bullets for this one
            }
        }

        // Collision: Ship vs Asteroid
        if (!ship.dead && ship.invulnerable === 0) {
            if (distBetweenPoints(ship.x, ship.y, a.x, a.y) < ship.r + a.r) {
                createParticles(ship.x, ship.y, 50, "white");
                lives--;
                ship = new Ship(); // Reset ship position
                
                if (lives <= 0) {
                    gameOver();
                }
            }
        }
    }

    // UFO Logic
    if (!ufo && Math.random() < UFO_CHANCE * (1 + level/5)) {
        const type = Math.random() > 0.8 ? 'small' : 'large'; // Small is rarer
        ufo = new UFO(type);
    } else if (ufo) {
        ufo.update();
        
        // Collision: Bullet vs UFO
        for(let j=bullets.length-1; j>=0; j--) {
            if(!ufo.dead && distBetweenPoints(ufo.x, ufo.y, bullets[j].x, bullets[j].y) < ufo.r + 5) {
                destroyUFO();
                bullets.splice(j, 1);
                break;
            }
        }
        
        // Collision: Ship vs UFO
        if(!ship.dead && ship.invulnerable === 0 && distBetweenPoints(ship.x, ship.y, ufo.x, ufo.y) < ship.r + ufo.r) {
             createParticles(ship.x, ship.y, 50, "white");
             lives--;
             ship = new Ship();
             if(lives <= 0) gameOver();
        }
    }
}

function draw() {
    // Background
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // FIX: Check if game is running AND ship exists before drawing entities
    if (!gameRunning || !ship) return; 

    // Draw Entities
    ship.draw();
    
    bullets.forEach(b => b.draw());
    asteroids.forEach(a => a.draw());
    particles.forEach(p => p.draw());
    
    if(ufo && !ufo.dead) ufo.draw();

    // UI / HUD
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "white";
    ctx.font = "20px Courier New";
    
    // Score Top Left
    ctx.textAlign = "left";
    ctx.fillText(`SCORE: ${score}`, 20, 30);
    
    // Lives Bottom Left (Draw mini ships)
    for(let i=0; i<lives-1; i++) { // -1 because current life is on screen
        ctx.save();
        ctx.translate(40 + i * 25, HEIGHT - 30);
        ctx.scale(0.6, 0.6);
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-10, 7);
        ctx.lineTo(-10, -7);
        ctx.closePath();
        ctx.strokeStyle = "white";
        ctx.stroke();
        ctx.restore();
    }

    // Level Text Center
    if (textAlpha > 0) {
        ctx.textAlign = "center";
        ctx.fillStyle = `rgba(255, 255, 255, ${textAlpha})`;
        ctx.font = "40px Courier New"; // Placeholder text
        // In a real implementation, we'd pass the message string to draw
    }
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// Start Loop
requestAnimationFrame(loop);

</script>
</body>
</html>