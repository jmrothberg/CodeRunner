<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"> -->
    <title>3D Space Invaders - Three. js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }        
        #ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }
        .hud-text { color: #00ffcc; font-size: 24px; text-shadow: 0 0 10px #00ffcc; font-weight: bold; }        
        #center-screen {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center; pointer-events: auto;
        }
        h1 { color: white; font-size: 48px; margin-bottom: 10px; text-shadow: 0 0 20px #ff00aa; }        
        p { color: #aaa; font-size: 18px; }        
        button {
            background: transparent; border: 2px solid #00ffcc;
            color: #00ffcc; padding: 15px 30px; font-size: 20px;
            cursor: pointer; text-transform: uppercase;
            transition: 0.3s; font-family: inherit; margin-top: 20px;
        }
        button:hover { background: #00ffcc; color: black; box-shadow: 0 0 20px #00ffcc; }
        .hidden { display: none !important; }
    </style>
</head>
<body> 
<!-- UI Layer -->
<div id="ui-layer">
    <div class="hud-text">SCORE: <span id="score">0</span></div>
    <div class="hud-text" style="text-align: right;">LIVES: <span id="lives">3</span> | LEVEL: <span id="level">1</span></div>
</div>

<!-- Start / Game Over Screen -->
<div id="center-screen">
    <h1 id="title-text">SPACE INVADERS 3D</h1>
    <p>Use ARROW KEYS to move X and Y.</p>
    <p>SPACEBAR to shoot (Hold for rapid fire).</p>
    <button id="start-btn">START MISSION</button>
</div>

<!-- Three. js Library -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/**
 * AUDIO ENGINE
 */
class SoundManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3;
        this.masterGain.connect(this.ctx.destination);
    }

    playShoot() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();        
        osc.type = 'square';
        osc.frequency.setValueAtTime(880, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(110, this.ctx.currentTime + 0.1);        
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
        osc.connect(gain); gain.connect(this.masterGain);
        osc.start(); osc.stop(this.ctx.currentTime + 0.15);
    }

    playExplosion() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
        osc.connect(gain); gain.connect(this.masterGain);
        osc.start(); osc.stop(this.ctx.currentTime + 0.3);
    }

    playPlayerHit() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.5);        
        gain.gain.setValueAtTime(1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
        osc.connect(gain); gain.connect(this.masterGain);
        osc.start(); osc.stop(this.ctx.currentTime + 0.5);
    }
    
    playBunkerHit() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.05);        
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
        osc.connect(gain); gain.connect(this.masterGain);
        osc.start(); osc.stop(this.ctx.currentTime + 0.05);
    }
}

/**
 * GAME CONFIGURATION & STATE
 */
const config = {
    playerSpeed: 0.4,
    bulletSpeed: 1.2,
    enemyStepX: 0.15,      // Movement speed in X
    enemyStepZ: 2.0,       // How far down they move when hitting edge
    enemyMoveDelay: 5,     // Frames between steps (higher = slower)
};

let state = { score: 0, lives: 3, isPlaying: false, frameCount: 0, level: 1 };

// Three. js Globals
let scene, camera, renderer;
let player, enemies = [], bullets = [], particles = [], bunkerBlocks = [];
let gridHelper, starField;

// Formation state
let formationDirection = 1; // 1 = right, -1 = left
let formationMoveTimer = 0;
let formationEdgeHit = false;

// Input State
const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, " ": false };
let lastShotTime = 0;

let audio;

/**
 * INITIALIZATION
 */
function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x00aa00, 0.015); // Greenish fog for retro feel

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window. innerHeight, 0.1, 1000);
    camera.position.set(0, 12, 18);
    camera.lookAt(0, 0, -5);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Green accent light
    const pointLight = new THREE.PointLight(0x00ff00, 0.5, 50);
    pointLight.position.set(0, 5, -10);
    scene.add(pointLight);

    createEnvironment();    
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = true; });
    document.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.key)) keys[e. key] = false; });
    document.getElementById('start-btn').addEventListener('click', startGame);

    animate();
}

function createEnvironment() {
    // Retro grid floor
    gridHelper = new THREE.GridHelper(100, 50, 0x00ff00, 0x004400);
    scene.add(gridHelper);

    // Starfield
    const starGeo = new THREE.BufferGeometry();
    const starCount = 15000;
    const posArray = new Float32Array(starCount * 3);    
    for(let i=0; i<starCount*3; i++) {
        posArray[i] = (Math.random() - 0.5) * 400;
    }    
    starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const starMat = new THREE.PointsMaterial({size: 0.1, color: 0xffffff});
    starField = new THREE.Points(starGeo, starMat);
    scene.add(starField);
}

function createPlayer() {
    const group = new THREE.Group();

    // Main Body - sleek fighter shape
    const bodyGeo = new THREE.ConeGeometry(1, 3.5, 8);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00aaff, roughness: 0.2, metalness: 0.9 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.rotation.x = Math.PI / 2;
    body.castShadow = true;
    group.add(body);

    // Wings
    const wingGeo = new THREE.BoxGeometry(4, 0.1, 1.5);
    const wingMat = new THREE.MeshStandardMaterial({ color: 0x0088cc });
    const wings = new THREE.Mesh(wingGeo, wingMat);
    wings.position.z = 0.8;
    group.add(wings);

    // Engine Glow
    const engineGeo = new THREE.CylinderGeometry(0.4, 0.2, 0.8, 8);
    const engineMat = new THREE.MeshBasicMaterial({ color: 0xff6600 });
    const engine = new THREE.Mesh(engineGeo, engineMat);
    engine.rotation.x = Math.PI / 2;
    engine.position.z = 1.8;
    
    // Engine light
    const engineLight = new THREE.PointLight(0xff6600, 1, 5);
    engineLight.position.z = 2;
    group.add(engineLight);
    group.add(engine);

    scene.add(group);
    return group;
}

// Different enemy types based on row
function createEnemy(x, z, type) {
    const group = new THREE.Group();
    
    let geo, mat, eyeColor;

    if (type === 0) { // Top rows - Squid-like
        geo = new THREE.SphereGeometry(1.2, 8, 6);
        mat = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0x440044 });
        eyeColor = 0xffff00;
    } else if (type === 1) { // Middle rows - Crab-like
        geo = new THREE.BoxGeometry(2, 1.5, 1);
        mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x004444 });
        eyeColor = 0xff0000;
    } else { // Bottom rows - Octopus-like
        geo = new THREE.ConeGeometry(1.3, 2, 8);
        mat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x004400 });
        eyeColor = 0xffffff;
    }

    const mesh = new THREE.Mesh(geo, mat);
    group.add(mesh);

    // Eyes
    const eyeGeo = new THREE.SphereGeometry(0.2, 8, 8);
    const eyeMat = new THREE.MeshBasicMaterial({ color: eyeColor });
    
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.5, type === 1 ? 0 : 0.3, 0.6);
    group.add(leftEye);

    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
    rightEye.position.set(0.5, type === 1 ? 0 : 0.3, 0.6);
    group.add(rightEye);

    // Tentacles / Arms for bottom rows
    if (type >= 2) {
        const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
        const leftArm = new THREE.Mesh(armGeo, mat);
        leftArm.position.set(-1, -0.5, 0);
        group.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeo, mat);
        rightArm.position.set(1, -0.5, 0);
        group.add(rightArm);
    }

    group.position.set(x, 0, z);    
    group.userData = { alive: true, type: type };
    scene.add(group);
    enemies.push(group);
}

// Create destructible bunkers
function createBunkers() {
    const bunkerPositions = [-12, -4, 4, 12]; // X positions for 4 bunkers
    
    bunkerPositions.forEach(bx => {
        createSingleBunker(bx, 0); // Y position
    });
}

function createSingleBunker(x, y) {
    const blockSize = 0.6;
    const rows = 5;
    const cols = 8;
    
    // Bunker shape pattern (arch)
    const pattern = [
        [0,0,1,1,1,1,0,0],
        [0,1,1,1,1,1,1,0],
        [1,1,0,1,1,0,1,1], // Arch opening
        [1,1,1,1,1,1,1,1],
        [1,1,1,1,1,1,1,1]
    ];

    for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
            if(pattern[r][c]) {
                const geo = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: 0x00aa44, 
                    roughness: 0.8,
                    transparent: true,
                    opacity: 1
                });
                const mesh = new THREE.Mesh(geo, mat);
                
                // Position relative to bunker center
                mesh.position.set(
                    x + (c - cols/2) * blockSize,
                    y + (rows - r) * blockSize - 2.5, // Offset down
                    0 // Player line is at z=10, enemies at negative Z
                );
                
                mesh.userData = { 
                    isBunker: true, 
                    health: 3 // Takes 3 hits
                };
                
                scene.add(mesh);
                bunkerBlocks.push(mesh);
            }
        }
    }
}

function createBullet(position, isEnemy = false) {
    const geo = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 8);
    const color = isEnemy ? 0xff0000 : 0x00ffff;
    const mat = new THREE.MeshBasicMaterial({ color: color });
    const mesh = new THREE.Mesh(geo, mat);    
    mesh.rotation.x = Math.PI / 2;
    mesh.position.copy(position);

    scene.add(mesh);

    // Player shoots toward negative Z (forward), Enemy shoots positive Z (back)
    bullets.push({
        mesh: mesh,
        velocity: new THREE.Vector3(0, 0, isEnemy ? config.bulletSpeed : -config.bulletSpeed),
        isEnemy: isEnemy
    });

    if(!isEnemy) audio.playShoot();
}

function createExplosion(position, color = 0xffaa00, count = 15) {
    for(let i=0; i<count; i++) {
        const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const mat = new THREE.MeshBasicMaterial({ color: color });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(position);        
        const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 0.6,
            (Math.random() - 0.5) * 0.6,
            (Math.random() - 0.5) * 0.6
        );
        scene.add(mesh);
        particles.push({ mesh: mesh, velocity: vel, life: 40 + Math.random()*20 });
    }
}

/**
 * GAME LOGIC
 */
function startGame() {
    audio = new SoundManager();    
    state.score = 0;
    state.lives = 3;
    state.level = 1;
    updateHUD();

    document.getElementById('center-screen').classList.add('hidden');    
    if(player) scene.remove(player);
    player = createPlayer();
    player.position.set(0, 0, 10);

    // Clear entities
    enemies.forEach(e => scene.remove(e));
    bullets.forEach(b => scene.remove(b.mesh));
    bunkerBlocks.forEach(b => scene.remove(b));
    
    enemies = [];
    bullets = [];
    particles = [];
    bunkerBlocks = [];

    createBunkers();
    spawnWave();

    formationDirection = 1;
    formationMoveTimer = 0;
    state.isPlaying = true;
}

function spawnWave() {
    const rows = 5; // Classic space invaders has 5 rows
    const cols = 11; // And 11 columns
    
    // Start enemies further back (more negative Z)
    const startZ = -40; 
    
    for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
            createEnemy(
                (c - cols/2) * 3, 
                startZ + (r * 2.5), // Spaced out in Z
                Math.floor(r / 2) // Type based on row
            );
        }
    }
}

function updatePlayer() {
    if(keys.ArrowUp && player.position.y < 8) player.position.y += config.playerSpeed;
    if(keys.ArrowDown && player.position.y > -5) player.position.y -= config.playerSpeed; // Can't go too low (bunkers)
    if(keys.ArrowLeft && player.position.x > -18) player.position.x -= config.playerSpeed;
    if(keys.ArrowRight && player.position.x < 18) player.position.x += config.playerSpeed;

    // Tilt effect
    player.rotation.z = (keys.ArrowLeft ? 0.3 : (keys.ArrowRight ? -0.3 : 0)) + 
                       (keys.ArrowUp ? -0.2 : (keys.ArrowDown ? 0.2 : 0));

    if(keys[" "] && state.isPlaying) {
        const now = Date.now();
        if(now - lastShotTime > 200) { // Fire rate
            createBullet(player.position);
            lastShotTime = now;
        }
    }
}

function updateEnemies() {
    formationMoveTimer++;
    
    // Classic space invaders movement: move, pause, move, pause...
    const moveDelay = Math.max(2, config.enemyMoveDelay - state.level); // Gets faster each level
    
    if (formationMoveTimer >= moveDelay) {
        formationMoveTimer = 0;
        
        let hitEdge = false;
        let lowestZ = -100; // Track how close enemies are getting
        
        // Check if any alive enemy hits the edge
        enemies.forEach(enemy => {
            if(!enemy.userData.alive) return;
            
            if (enemy.position.x > 18 || enemy.position.x < -18) {
                hitEdge = true;
            }
            if (enemy.position.z > lowestZ) lowestZ = enemy.position.z;
        });

       if (hitEdge) {
            // FIX: Push them away from edge BEFORE flipping direction
            const pushBack = 0.5; 
            enemies.forEach(enemy => {
                if(enemy.userData.alive) {
                    enemy.position.x -= formationDirection * pushBack;
                }
            });
            
            formationDirection *= -1;
            enemies.forEach(enemy => {
                if(enemy.userData.alive) {
                    enemy. position.z += config.enemyStepZ;
                }
            });
        } else {
            // Move horizontally
            const step = config.enemyStepX * formationDirection;
            enemies.forEach(enemy => {
                if(enemy.userData.alive) {
                    enemy.position.x += step;
                    
                    // Classic animation: bob up and down while moving
                    enemy.position.y = Math.sin(state.frameCount * 0.1 + enemy.id) * 0.3;
                }
            });
        }
        
        // Check game over (enemies reached player line)
        if (lowestZ > 8) {
            gameOver();
        }
    }

    // Enemy shooting
    enemies.forEach(enemy => {
        if(!enemy.userData.alive) return;
        
        enemy.userData.shootTimer = (enemy.userData.shootTimer || 0) + 1;
        
        // Shooting rate increases with level and fewer enemies
        const aliveCount = enemies.filter(e => e.userData.alive).length;
        const shootThreshold = Math.max(60, 200 - (state.level * 10) - ((55 - aliveCount) * 2));
        
        if(enemy.userData.shootTimer >= shootThreshold && Math.random() < 0.03) {
            createBullet(enemy.position, true);
            enemy.userData.shootTimer = 0;
        }
    });
}

function updateBullets() {
    for(let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.add(b.velocity);

        // Bounds check
        if(b.mesh.position.z < -60 || b.mesh.position.z > 30) {
            scene.remove(b.mesh);
            bullets.splice(i, 1);
            continue;
        }

        let hit = false;

        if(!b.isEnemy) {
            const bulletBox = new THREE.Box3().setFromObject(b.mesh);

            // Check enemy collisions
            for(let j=0; j<enemies.length; j++) {
                const e = enemies[j];
                if(e.userData.alive) {
                    const enemyBox = new THREE.Box3().setFromObject(e);
                    if(enemyBox.intersectsBox(bulletBox)) {
                        createExplosion(e.position, 0xff00ff, 20);
                        scene.remove(e);
                        e.userData.alive = false;
                        
                        state.score += (5 - Math.floor(e.userData.type)) * 10; // Higher points for harder enemies
                        updateHUD();
                        audio.playExplosion();                        
                        hit = true;
                        break; 
                    }
                }
            }
            
            // Check bunker collisions if no enemy hit
            if(!hit) {
                for(let k=bunkerBlocks.length-1; k>=0; k--) {
                    const block = bunkerBlocks[k];
                    const blockBox = new THREE.Box3().setFromObject(block);
                    
                    if(blockBox.intersectsBox(bulletBox)) {
                        scene.remove(b.mesh); // Remove bullet
                        bullets.splice(i, 1);
                        
                        // Damage bunker block
                        block.userData.health--;
                        audio.playBunkerHit();
                        
                        // Darken the block to show damage
                        const healthRatio = block.userData.health / 3;
                        block.material.opacity = healthRatio;
                        block.material.color.setHex(healthRatio < 0.5 ? 0x004400 : 0x00aa44);
                        
                        if(block.userData.health <= 0) {
                            scene.remove(block);
                            bunkerBlocks.splice(k, 1);
                        }
                        
                        hit = true; // Bullet is gone
                        break;
                    }
                }
            }
        } else {
            // Enemy bullet vs player and bunkers
            const bulletBox = new THREE.Box3().setFromObject(b.mesh);

            // Player collision
            const playerBox = new THREE.Box3().setFromObject(player);
            if(playerBox.intersectsBox(bulletBox)) {
                createExplosion(player.position, 0x00aaff, 30);
                state.lives--;
                updateHUD();
                audio.playPlayerHit();                
                player.position.set(0,0,10);
                bullets = bullets.filter(b => !b.isEnemy); // Clear enemy bullets on death   
                hit = true;
                if(state.lives <= 0) gameOver();
            }
            
            // Bunker collision for enemy bullets
            if(!hit) {
                for(let k=bunkerBlocks.length-1; k>=0; k--) {
                    const block = bunkerBlocks[k];
                    const blockBox = new THREE.Box3().setFromObject(block);
                    
                    if(blockBox.intersectsBox(bulletBox)) {
                        scene.remove(b.mesh); // Remove bullet
                        bullets.splice(i, 1);
                        
                        block.userData.health--;
                        audio.playBunkerHit();
                        
                        const healthRatio = block.userData.health / 3;
                        block.material.opacity = healthRatio;
                        block.material.color.setHex(healthRatio < 0.5 ? 0x004400 : 0x00aa44);
                        
                        if(block.userData.health <= 0) {
                            scene.remove(block);
                            bunkerBlocks.splice(k, 1);
                        }
                        
                        hit = true; // Bullet is gone
                        break;
                    }
                }
            }
        }

        if(hit && !bullets[i]) continue; // Already removed
        
        if(hit) {
            scene.remove(b.mesh);
            bullets.splice(i, 1);
        }
    }

    const aliveEnemies = enemies.filter(e => e.userData.alive).length;
    if(aliveEnemies === 0 && state.isPlaying) {
        state.level++;
        updateHUD();
        
        // Bonus for clearing wave
        state.score += 500 * (state.level - 1);
        
        spawnWave();
        audio.playShoot(); 
    }
}

function updateParticles() {
    for(let i=particles.length-1; i>=0; i--) {
        const p = particles[i];
        p.mesh.position.add(p.velocity);
        p.mesh.rotation.x += 0.2;
        p.life--;        
        p.mesh.scale.multiplyScalar(0.92);

        if(p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }
}

function updateHUD() {
    document.getElementById('score').innerText = state.score;
    document.getElementById('lives').innerText = state.lives;
    document.getElementById('level').innerText = state.level;
}

function gameOver() {
    state.isPlaying = false;
    document.getElementById('title-text').innerText = "GAME OVER";
    document.getElementById('start-btn').innerText = "TRY AGAIN";
    document.getElementById('center-screen').classList.remove('hidden');
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/**
 * MAIN LOOP
 */
function animate() {
    requestAnimationFrame(animate);

    if(state.isPlaying) {
        state.frameCount++;        
        gridHelper.position.z = (state.frameCount * 0.2) % 10; // Faster floor movement
        
        updatePlayer();
        updateEnemies();
        updateBullets();
        updateParticles();
    }

    renderer.render(scene, camera);
}

init();

</script>
</body>
</html>