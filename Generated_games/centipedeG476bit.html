<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centipede Arcade</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #050505;
            --text-color: #ffffff;
            --accent-green: #39ff14;
            --accent-red: #ff003c;
            --ui-font: 'Press Start 2P', monospace;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--ui-font);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.2);
            border: 4px solid #333;
        }

        canvas {
            display: block;
            background-color: #000;
        }

        /* Scanline effect for retro feel */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            text-shadow: 2px 2px #000;
        }

        .score-box span { color: var(--accent-green); }
        .high-score-box span { color: #fff; }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border: 2px solid var(--accent-green);
            z-index: 20;
            pointer-events: auto;
        }

        h1 {
            color: var(--accent-red);
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 4px 4px #000;
            line-height: 1.5;
        }

        p { font-size: 12px; line-height: 2; color: #ccc; }
        
        .btn {
            background: var(--accent-green);
            color: #000;
            border: none;
            padding: 15px 30px;
            font-family: var(--ui-font);
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            transition: transform 0.1s;
        }

        .btn:hover { transform: scale(1.05); background: #fff; }
        .btn:active { transform: scale(0.95); }

        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="600" height="720"></canvas>
    <div class="scanlines"></div>
    
    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">SCORE: <span id="scoreEl">0</span></div>
            <div class="high-score-box">HI-SCORE: <span id="hiScoreEl">20000</span></div>
        </div>
        <!-- Lives could be visualized as small icons or text -->
        <div style="text-align: left; font-size: 12px;">LIVES: <span id="livesEl" style="color:var(--accent-red)">3</span></div>
    </div>

    <div id="start-screen">
        <h1>CENTIPEDE</h1>
        <p>ARROWS / WASD to Move</p>
        <p>SPACE to Shoot</p>
        <p>Destroy Mushrooms & Centipedes</p>
        <button class="btn" onclick="game.start()">INSERT COIN</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>GAME OVER</h1>
        <p>FINAL SCORE: <span id="finalScore">0</span></p>
        <button class="btn" onclick="game.reset()">PLAY AGAIN</button>
    </div>
</div>

<script>
/**
 * CENTIPEDE ARCADE CLONE
 * 
 * Architecture:
 * - Game Loop: Handles update and draw cycles.
 * - Entities: Player, Bullet, Mushroom, Centipede (Segment), Flea, Spider, Scorpion.
 * - Grid System: 30 columns x 36 rows. Tile size = 20px.
 */

// --- CONSTANTS ---
const CANVAS_WIDTH = 600;
const CANVAS_HEIGHT = 720;
const TILE_SIZE = 20;
const COLS = CANVAS_WIDTH / TILE_SIZE; // 30
const ROWS = CANVAS_HEIGHT / TILE_SIZE; // 36
const PLAYER_ZONE_ROW = 28; // Row where player is restricted to

// Colors
const C_BLACK = '#000000';
const C_WHITE = '#FFFFFF';
const C_PLAYER = '#00FFFF'; // Cyan
const C_MUSHROOM_FULL = '#FF3333'; // Red
const C_MUSHROOM_POISON = '#9932CC'; // Purple
const C_CENTIPEDE_HEAD = '#39FF14'; // Neon Green
const C_CENTIPEDE_BODY = '#FFFF00'; // Yellow
const C_FLEA = '#00FFFF';
const C_SPIDER = '#FFFFFF';
const C_SCORPION = '#FF8C00';

// Scoring
const SCORE_MUSHROOM = 10;
const SCORE_FLEA = 200;
const SCORE_SPIDER = 300;
const SCORE_SCORPION = 1000;
const SCORE_HEAD = 100;
const SCORE_BODY = 10;

// --- UTILS ---
function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || 
             r2.x + r2.w < r1.x || 
             r2.y > r1.y + r1.h || 
             r2.y + r2.h < r1.y);
}

function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// --- CLASSES ---

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = randomInt(2, 5);
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 0.5) * 6;
        this.life = 1.0; // Opacity
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.05;
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

class Mushroom {
    constructor(c, r) {
        this.c = c; // Grid Column
        this.r = r; // Grid Row
        this.x = c * TILE_SIZE;
        this.y = r * TILE_SIZE;
        this.health = 4;
        this.poisoned = false;
    }

    draw(ctx) {
        const cx = this.x + TILE_SIZE / 2;
        const cy = this.y + TILE_SIZE / 2;

        // Color based on state
        if (this.poisoned) ctx.fillStyle = C_MUSHROOM_POISON;
        else if (this.health === 4) ctx.fillStyle = C_MUSHROOM_FULL;
        else if (this.health === 3) ctx.fillStyle = '#FF9933';
        else if (this.health === 2) ctx.fillStyle = '#FFCC00';
        else ctx.fillStyle = '#888888'; // Almost dead

        // Draw Cap
        ctx.beginPath();
        ctx.arc(cx, cy - 2, TILE_SIZE / 2 - 2, Math.PI, 0);
        ctx.fill();

        // Draw Stem
        ctx.fillRect(cx - 3, cy, 6, TILE_SIZE / 2);

        // Damage details (holes)
        if (this.health < 4) {
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 5, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        if (this.health < 2) {
            ctx.beginPath();
            ctx.arc(cx + 3, cy - 5, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    hit() {
        this.health--;
        return this.health <= 0;
    }
}

class Bullet {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 4;
        this.h = 10;
        this.speed = 12;
        this.active = true;
    }

    update() {
        this.y -= this.speed;
        if (this.y < -20) this.active = false;
    }

    draw(ctx) {
        ctx.fillStyle = '#FFF';
        ctx.fillRect(this.x, this.y, this.w, this.h);
    }
}

class Player {
    constructor(game) {
        this.game = game;
        this.w = TILE_SIZE; // 20
        this.h = TILE_SIZE;
        this.reset();
    }

    reset() {
        this.x = CANVAS_WIDTH / 2 - this.w / 2;
        this.y = (ROWS - 2) * TILE_SIZE;
        this.speed = 4;
        this.dead = false;
        this.cooldown = 0;
    }

    update(input) {
        if (this.dead) return;

        // Movement
        if (input.keys['ArrowLeft'] || input.keys['a']) this.x -= this.speed;
        if (input.keys['ArrowRight'] || input.keys['d']) this.x += this.speed;
        if (input.keys['ArrowUp'] || input.keys['w']) this.y -= this.speed;
        if (input.keys['ArrowDown'] || input.keys['s']) this.y += this.speed;

        // Boundaries
        if (this.x < 0) this.x = 0;
        if (this.x > CANVAS_WIDTH - this.w) this.x = CANVAS_WIDTH - this.w;
        
        // Restrict to bottom area (Player Zone)
        const minY = PLAYER_ZONE_ROW * TILE_SIZE;
        if (this.y < minY) this.y = minY;
        if (this.y > CANVAS_HEIGHT - this.h) this.y = CANVAS_HEIGHT - this.h;

        // Shooting
        if (this.cooldown > 0) this.cooldown--;
        if ((input.keys[' '] || input.keys['ArrowUp']) && this.cooldown <= 0) {
            this.shoot();
        }
    }

    shoot() {
        // Limit bullets on screen for classic feel, or just cooldown?
        // Let's allow rapid fire but with small delay
        this.game.bullets.push(new Bullet(this.x + this.w/2 - 2, this.y));
        this.cooldown = 10; // Frames between shots
        
        // Sound effect placeholder: console.log("PEW");
    }

    draw(ctx) {
        if (this.dead) return;

        ctx.fillStyle = C_PLAYER;
        
        // Draw a little ship shape
        const cx = this.x + this.w/2;
        const cy = this.y + this.h/2;

        // Base
        ctx.fillRect(this.x, this.y + 8, this.w, 12);
        // Turret
        ctx.fillRect(cx - 3, this.y, 6, 10);
        // Tip
        ctx.fillStyle = '#FFF';
        ctx.fillRect(cx - 1, this.y, 2, 4);
    }
}

// --- ENEMIES ---

class Flea {
    constructor(game) {
        this.game = game;
        this.w = TILE_SIZE;
        this.h = TILE_SIZE;
        this.x = randomInt(0, COLS-1) * TILE_SIZE;
        this.y = -TILE_SIZE;
        this.speedY = 2; // Moves down
        this.active = true;
        this.dropTimer = 0;
    }

    update() {
        this.y += this.speedY;

        // Drop mushrooms occasionally
        if (this.y > 0 && this.y < CANVAS_HEIGHT - TILE_SIZE * 5) {
            this.dropTimer++;
            if (this.dropTimer > 15) { // Every ~15 frames
                const c = Math.floor(this.x / TILE_SIZE);
                const r = Math.floor(this.y / TILE_SIZE);
                this.game.addMushroom(c, r);
                this.dropTimer = 0;
            }
        }

        if (this.y > CANVAS_HEIGHT) this.active = false;
    }

    draw(ctx) {
        ctx.fillStyle = C_FLEA;
        // Draw pixel art flea
        const x = this.x + 4; 
        const y = this.y + 4;
        ctx.fillRect(x, y, 12, 12);
        ctx.fillStyle = '#000'; // Eyes
        ctx.fillRect(x+2, y+2, 2, 2);
        ctx.fillRect(x+8, y+2, 2, 2);
        // Legs
        ctx.strokeStyle = C_FLEA;
        ctx.beginPath();
        ctx.moveTo(x, y+6); ctx.lineTo(x-4, y+10);
        ctx.moveTo(x+12, y+6); ctx.lineTo(x+16, y+10);
        ctx.stroke();
    }
}

class Spider {
    constructor(game) {
        this.game = game;
        this.w = TILE_SIZE * 2; // Bigger
        this.h = TILE_SIZE * 2;
        this.y = (ROWS - 4) * TILE_SIZE;
        
        // Start from left or right
        if (Math.random() > 0.5) {
            this.x = -this.w;
            this.dx = 2 + Math.random();
        } else {
            this.x = CANVAS_WIDTH;
            this.dx = -(2 + Math.random());
        }
        
        this.dy = 0;
        this.active = true;
        this.timer = 0;
    }

    update() {
        this.x += this.dx;
        this.y += this.dy;

        // Zigzag logic
        this.timer++;
        if (this.timer > randomInt(10, 30)) {
            this.dy = (Math.random() - 0.5) * 6; // Random vertical change
            this.timer = 0;
        }

        // Constrain to player zone roughly
        const minY = PLAYER_ZONE_ROW * TILE_SIZE;
        if (this.y < minY) { this.y = minY; this.dy *= -1; }
        if (this.y > CANVAS_HEIGHT - this.h) { this.y = CANVAS_HEIGHT - this.h; this.dy *= -1; }

        // Despawn
        if ((this.dx > 0 && this.x > CANVAS_WIDTH) || (this.dx < 0 && this.x < -this.w)) {
            this.active = false;
        }
    }

    draw(ctx) {
        ctx.fillStyle = C_SPIDER;
        // Bloated body
        const cx = this.x + this.w/2;
        const cy = this.y + this.h/2;
        
        ctx.beginPath();
        ctx.arc(cx, cy, 14, 0, Math.PI*2);
        ctx.fill();

        // Legs (animated)
        const offset = Math.sin(Date.now() / 50) * 5;
        ctx.strokeStyle = '#FFF';
        ctx.lineWidth = 2;
        for(let i=0; i<4; i++) {
            // Left legs
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy - 8 + (i*6));
            ctx.lineTo(cx - 20 - offset, cy - 12 + (i*6));
            ctx.stroke();
            // Right legs
            ctx.beginPath();
            ctx.moveTo(cx + 10, cy - 8 + (i*6));
            ctx.lineTo(cx + 20 + offset, cy - 12 + (i*6));
            ctx.stroke();
        }
        
        // Eyes
        ctx.fillStyle = '#000';
        ctx.fillRect(cx-4, cy-2, 2, 2);
        ctx.fillRect(cx+2, cy-2, 2, 2);
    }
}

class Scorpion {
    constructor(game) {
        this.game = game;
        this.w = TILE_SIZE * 2;
        this.h = TILE_SIZE;
        this.y = randomInt(5, PLAYER_ZONE_ROW - 5) * TILE_SIZE; // Middle area
        
        if (Math.random() > 0.5) {
            this.x = -this.w;
            this.dx = 3;
        } else {
            this.x = CANVAS_WIDTH;
            this.dx = -3;
        }
        
        this.active = true;
    }

    update() {
        this.x += this.dx;

        // Poison mushrooms
        const c = Math.floor((this.x + this.w/2) / TILE_SIZE);
        const r = Math.floor(this.y / TILE_SIZE);
        
        // Check grid for mushroom to poison
        if (c >= 0 && c < COLS) {
            const mush = this.game.getMushroom(c, r);
            if (mush && !mush.poisoned) {
                mush.poisoned = true;
            }
        }

        if ((this.dx > 0 && this.x > CANVAS_WIDTH) || (this.dx < 0 && this.x < -this.w)) {
            this.active = false;
        }
    }

    draw(ctx) {
        ctx.fillStyle = C_SCORPION;
        // Long body
        ctx.fillRect(this.x, this.y + 6, this.w, 8);
        
        // Pincers
        const dir = this.dx > 0 ? 1 : -1;
        ctx.fillRect(this.x + (dir>0?this.w:0) - 4, this.y, 4, 6);

        // Tail curl
        ctx.strokeStyle = C_SCORPION;
        ctx.lineWidth = 3;
        ctx.beginPath();
        const tailStart = this.x + (dir<0?this.w:0);
        ctx.moveTo(tailStart, this.y+10);
        ctx.quadraticCurveTo(tailStart - (10*dir), this.y-5, tailStart - (15*dir), this.y+5);
        ctx.stroke();
        
        // Stinger
        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.arc(tailStart - (15*dir), this.y+5, 3, 0, Math.PI*2);
        ctx.fill();
    }
}

// --- CENTIPEDE LOGIC ---

class CentipedeSegment {
    constructor(c, r, isHead) {
        this.c = c;
        this.r = r;
        this.x = c * TILE_SIZE;
        this.y = r * TILE_SIZE;
        this.isHead = isHead;
        
        // Movement direction: 1 right, -1 left
        this.dx = 1; 
    }

    draw(ctx) {
        if (this.isHead) {
            ctx.fillStyle = C_CENTIPEDE_HEAD;
            // Head shape
            const cx = this.x + TILE_SIZE/2;
            const cy = this.y + TILE_SIZE/2;
            ctx.beginPath();
            ctx.arc(cx, cy, TILE_SIZE/2 - 1, 0, Math.PI*2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#000';
            const eyeOff = this.dx > 0 ? 4 : -4;
            ctx.fillRect(cx + eyeOff - 2, cy - 4, 4, 4);
        } else {
            ctx.fillStyle = C_CENTIPEDE_BODY;
            // Body segment (round)
            ctx.beginPath();
            ctx.arc(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2, TILE_SIZE/2 - 2, 0, Math.PI*2);
            ctx.fill();
        }
    }
}

class Centipede {
    constructor(game, startLength, startRow) {
        this.game = game;
        this.segments = [];
        
        // Create chain
        for (let i = 0; i < startLength; i++) {
            // Head is at index 0 initially
            this.segments.push(new CentipedeSegment(COLS/2 - i, startRow, i === 0));
        }
        
        this.moveTimer = 0;
        this.moveInterval = 5; // Speed (lower is faster)
    }

    update() {
        // Move entire centipede based on timer
        this.moveTimer++;
        if (this.moveTimer < this.moveInterval) return;
        this.moveTimer = 0;

        // Process segments from Head to Tail
        // We need to store previous positions for the body to follow
        
        const oldPositions = this.segments.map(s => ({c: s.c, r: s.r}));

        for (let i = 0; i < this.segments.length; i++) {
            let seg = this.segments[i];
            
            if (seg.isHead) {
                // HEAD LOGIC
                let nextC = seg.c + seg.dx;
                let nextR = seg.r;

                // Check collision with walls or mushrooms
                let hitObstacle = false;
                
                // Wall check
                if (nextC < 0 || nextC >= COLS) {
                    hitObstacle = true;
                } else {
                    // Mushroom check
                    if (this.game.getMushroom(nextC, nextR)) {
                        hitObstacle = true;
                    }
                }

                if (hitObstacle) {
                    // Move down and reverse direction
                    seg.r++;
                    seg.dx *= -1; 
                    
                    // If in player zone, sometimes move up? No, classic is just bounce.
                    // But if it hits bottom, it goes back up to top area eventually?
                    // Classic: In player zone, it moves freely. Let's keep it simple:
                    // If hit obstacle -> Down + Reverse.
                } else {
                    seg.c = nextC;
                }

                // Check Poisoned Mushroom interaction
                const currentMush = this.game.getMushroom(seg.c, seg.r);
                if (currentMush && currentMush.poisoned) {
                    // Dive straight down towards player zone immediately
                    seg.r++; 
                    // Don't reverse X, just dive
                }

            } else {
                // BODY LOGIC: Follow the segment ahead (i-1)
                const leader = this.segments[i-1];
                // Actually, body follows where the leader WAS.
                // But since we update in place, we use oldPositions of the leader.
                
                seg.c = oldPositions[i-1].c;
                seg.r = oldPositions[i-1].r;
            }

            // Update pixel coordinates
            seg.x = seg.c * TILE_SIZE;
            seg.y = seg.r * TILE_SIZE;

            // Bounds check (bottom of screen)
            if (seg.r >= ROWS) {
                seg.r = 0; // Wrap to top? Or just stay at bottom?
                // Classic: It stays in player zone bouncing around.
                // Let's clamp it.
                seg.r = ROWS - 1;
            }
        }
    }

    draw(ctx) {
        this.segments.forEach(seg => seg.draw(ctx));
    }

    // Returns two new Centipedes if split, or null
    split(hitIndex) {
        // hitIndex is the segment that was hit.
        
        // Part 1: The head part (0 to hitIndex - 1)
        const part1 = this.segments.slice(0, hitIndex);
        
        // Part 2: The tail part (hitIndex + 1 to end)
        const part2 = this.segments.slice(hitIndex + 1);

        let newCentipede = null;

        if (part1.length > 0) {
            this.segments = part1;
            // Ensure the last segment of part1 is still a body
            this.segments[this.segments.length-1].isHead = false; 
            // The first one is already head
        } else {
            // Head was shot, this centipede is dead
            this.segments = []; 
        }

        if (part2.length > 0) {
            newCentipede = new Centipede(this.game, 0, 0); // Dummy init
            newCentipede.segments = part2;
            // The first segment of the tail becomes a HEAD
            newCentipede.segments[0].isHead = true;
            // It inherits direction from where it was going? 
            // In classic, it continues the direction of the segment that was ahead.
            // We need to infer direction. For simplicity, let's keep current dx or reverse?
            // Let's set it to opposite of the previous head to simulate "breaking off"
            newCentipede.segments[0].dx = this.segments.length > 0 ? -this.segments[0].dx : 1;
        }

        return newCentipede;
    }
}

// --- MAIN GAME CLASS ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // UI Elements
        this.scoreEl = document.getElementById('scoreEl');
        this.hiScoreEl = document.getElementById('hiScoreEl');
        this.livesEl = document.getElementById('livesEl');
        this.startScreen = document.getElementById('start-screen');
        this.gameOverScreen = document.getElementById('game-over-screen');
        this.finalScoreEl = document.getElementById('finalScore');

        // Input
        this.input = { keys: {} };
        window.addEventListener('keydown', e => this.input.keys[e.key] = true);
        window.addEventListener('keyup', e => this.input.keys[e.key] = false);

        // Game State
        this.state = 'MENU'; // MENU, PLAYING, GAMEOVER
        this.score = 0;
        this.highScore = 20000;
        this.lives = 3;
        this.wave = 1;

        // Entities
        this.player = new Player(this);
        this.bullets = [];
        this.mushrooms = []; // Grid based lookup: key "c,r"
        this.centipedes = [];
        this.fleas = [];
        this.spiders = [];
        this.scorpions = [];
        this.particles = [];

        // Spawning timers
        this.enemyTimer = 0;

        // Bind loop
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    start() {
        this.score = 0;
        this.lives = 3;
        this.wave = 1;
        this.updateUI();
        this.startWave();
        
        this.state = 'PLAYING';
        this.startScreen.classList.add('hidden');
        this.gameOverScreen.classList.add('hidden');
    }

    reset() {
        this.start();
    }

    startWave() {
        // Clear entities
        this.bullets = [];
        this.fleas = [];
        this.spiders = [];
        this.scorpions = [];
        this.centipedes = [];
        
        // Reset Player
        this.player.reset();

        // Generate Mushrooms (Randomly, but less in player area)
        this.mushrooms = [];
        for (let r = 0; r < ROWS - 2; r++) {
            if (Math.random() < 0.15) { // 15% chance per tile
                const c = randomInt(0, COLS-1);
                // Don't spawn too close to start column for centipede
                if (Math.abs(c - COLS/2) > 2 || r > 5) {
                    this.addMushroom(c, r);
                }
            }
        }

        // Spawn Centipede
        // Length increases with wave? Max 12.
        const length = Math.min(8 + Math.floor(this.wave / 2), 12);
        this.centipedes.push(new Centipede(this, length, 0));
    }

    addMushroom(c, r) {
        const key = `${c},${r}`;
        if (!this.mushrooms[key]) {
            this.mushrooms[key] = new Mushroom(c, r);
        }
    }

    getMushroom(c, r) {
        return this.mushrooms[`${c},${r}`];
    }

    spawnParticles(x, y, color, count=10) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    update() {
        if (this.state !== 'PLAYING') return;

        // Player
        this.player.update(this.input);

        // Bullets
        this.bullets.forEach(b => b.update());
        this.bullets = this.bullets.filter(b => b.active);

        // Centipedes
        this.centipedes.forEach(c => c.update());

        // Enemies Spawning Logic
        this.enemyTimer++;
        
        // Flea: If mushrooms are sparse in top area
        if (this.enemyTimer % 600 === 0 && Object.keys(this.mushrooms).length < 20) {
            this.fleas.push(new Flea(this));
        }

        // Spider: Randomly enters player zone
        if (this.enemyTimer % 800 === 0) {
            this.spiders.push(new Spider(this));
        }

        // Scorpion: Rarely appears
        if (this.wave > 1 && this.enemyTimer % 1200 === 0) {
            this.scorpions.push(new Scorpion(this));
        }

        // Update Enemies
        this.fleas.forEach(e => e.update());
        this.spiders.forEach(e => e.update());
        this.scorpions.forEach(e => e.update());

        // Cleanup inactive enemies
        this.fleas = this.fleas.filter(e => e.active);
        this.spiders = this.spiders.filter(e => e.active);
        this.scorpions = this.scorpions.filter(e => e.active);

        // Particles
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => p.life > 0);

        // --- COLLISIONS ---

        // 1. Bullet vs Mushrooms
        for (let b of this.bullets) {
            const c = Math.floor((b.x + b.w/2) / TILE_SIZE);
            const r = Math.floor((b.y + b.h/2) / TILE_SIZE);
            const mush = this.getMushroom(c, r);
            
            if (mush && rectIntersect({x:b.x, y:b.y, w:b.w, h:b.h}, {x:mush.x, y:mush.y, w:TILE_SIZE, h:TILE_SIZE})) {
                b.active = false;
                if (mush.hit()) {
                    delete this.mushrooms[`${c},${r}`];
                    this.spawnParticles(mush.x + TILE_SIZE/2, mush.y + TILE_SIZE/2, C_MUSHROOM_FULL);
                }
                this.addScore(SCORE_MUSHROOM);
            }
        }

        // 2. Bullet vs Centipede (FIXED SECTION)
        for (let i = this.centipedes.length - 1; i >= 0; i--) {
            const cent = this.centipedes[i];
            
            // Iterate through bullets to find a collision
            for (let k = this.bullets.length - 1; k >= 0; k--) {
                const b = this.bullets[k];
                if (!b.active) continue;

                for (let j = 0; j < cent.segments.length; j++) {
                    const seg = cent.segments[j];
                    
                    // Check collision between bullet 'b' and segment 'seg'
                    if (rectIntersect({x:seg.x, y:seg.y, w:TILE_SIZE, h:TILE_SIZE}, {x:b.x, y:b.y, w:b.w, h:b.h})) {
                        b.active = false;
                        
                        // Spawn Mushroom at death location
                        this.addMushroom(seg.c, seg.r);
                        this.spawnParticles(seg.x + TILE_SIZE/2, seg.y + TILE_SIZE/2, C_CENTIPEDE_HEAD);

                        // Score
                        this.addScore(seg.isHead ? SCORE_HEAD : SCORE_BODY);

                        // Split logic
                        const newCent = cent.split(j);
                        
                        if (newCent) {
                            this.centipedes.push(newCent);
                        }

                        if (cent.segments.length === 0) {
                            this.centipedes.splice(i, 1);
                        }
                        
                        // Break segment loop since bullet hit something
                        break; 
                    }
                }
            }
        }

        // 3. Bullet vs Flea/Spider/Scorpion
        [this.fleas, this.spiders, this.scorpions].forEach((list, idx) => {
            for (let e of list) {
                for (let b of this.bullets) {
                    if (b.active && rectIntersect({x:e.x, y:e.y, w:e.w, h:e.h}, {x:b.x, y:b.y, w:b.w, h:b.h})) {
                        b.active = false;
                        e.active = false;
                        this.spawnParticles(e.x + e.w/2, e.y + e.h/2, '#FFF');
                        
                        if (idx === 0) this.addScore(SCORE_FLEA);
                        if (idx === 1) this.addScore(SCORE_SPIDER);
                        if (idx === 2) this.addScore(SCORE_SCORPION);
                    }
                }
            }
        });

        // 4. Player Collisions
        const pRect = {x: this.player.x + 4, y: this.player.y + 4, w: this.player.w - 8, h: this.player.h - 8};
        
        // vs Centipede
        let playerHit = false;
        for (let cent of this.centipedes) {
            for (let seg of cent.segments) {
                if (rectIntersect(pRect, {x:seg.x, y:seg.y, w:TILE_SIZE, h:TILE_SIZE})) {
                    playerHit = true; break;
                }
            }
        }
        
        // vs Enemies
        if (!playerHit) {
            [...this.fleas, ...this.spiders, ...this.scorpions].forEach(e => {
                if (rectIntersect(pRect, {x:e.x, y:e.y, w:e.w, h:e.h})) playerHit = true;
            });
        }

        if (playerHit) {
            this.handlePlayerDeath();
        }

        // Wave Clear Check
        if (this.centipedes.length === 0 && this.fleas.length === 0) {
            this.wave++;
            this.startWave();
        }
    }

    handlePlayerDeath() {
        this.spawnParticles(this.player.x + TILE_SIZE/2, this.player.y + TILE_SIZE/2, C_PLAYER, 30);
        this.lives--;
        this.updateUI();
        
        if (this.lives <= 0) {
            this.state = 'GAMEOVER';
            this.finalScoreEl.innerText = this.score;
            this.gameOverScreen.classList.remove('hidden');
        } else {
            // Reset positions but keep mushrooms
            this.player.reset();
            this.bullets = [];
            this.fleas = [];
            this.spiders = [];
            this.scorpions = [];
            
            // Optional: Reset centipede position to top? 
            // Classic arcade resets the wave if you die, or just respawns player?
            // Usually, if you die, the board resets (mushrooms stay) but enemies respawn.
            // Let's just restart the wave logic for simplicity and fairness.
            this.startWave();
        }
    }

    addScore(points) {
        this.score += points;
        if (this.score > this.highScore) this.highScore = this.score;
        
        // Extra life
        if (Math.floor(this.score / 12000) > Math.floor((this.score - points) / 12000)) {
            this.lives++;
        }
        
        this.updateUI();
    }

    updateUI() {
        this.scoreEl.innerText = this.score.toString().padStart(6, '0');
        this.hiScoreEl.innerText = this.highScore.toString().padStart(6, '0');
        this.livesEl.innerText = this.lives;
    }

    draw() {
        // Clear Background
        this.ctx.fillStyle = C_BLACK;
        this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw Player Zone Line (Subtle)
        this.ctx.strokeStyle = '#222';
        this.ctx.beginPath();
        this.ctx.moveTo(0, PLAYER_ZONE_ROW * TILE_SIZE);
        this.ctx.lineTo(CANVAS_WIDTH, PLAYER_ZONE_ROW * TILE_SIZE);
        this.ctx.stroke();

        // Draw Mushrooms
        for (let key in this.mushrooms) {
            this.mushrooms[key].draw(this.ctx);
        }

        // Draw Entities
        this.player.draw(this.ctx);
        this.bullets.forEach(b => b.draw(this.ctx));
        this.centipedes.forEach(c => c.draw(this.ctx));
        this.fleas.forEach(e => e.draw(this.ctx));
        this.spiders.forEach(e => e.draw(this.ctx));
        this.scorpions.forEach(e => e.draw(this.ctx));
        
        // Draw Particles
        this.particles.forEach(p => p.draw(this.ctx));
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

// Start Game Instance
const game = new Game();

</script>
</body>
</html>