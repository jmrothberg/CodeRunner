<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Frogger - Arcade Edition</title>
    <style>
        :root {
            --bg-color: #222;
            --frame-color: #444;
            --accent-color: #ffeb3b;
            --font-main: 'Courier New', Courier, monospace;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: var(--font-main);
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            border: 10px solid var(--frame-color);
            border-radius: 4px;
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated; /* Retro crispness */
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            color: var(--accent-color);
        }

        /* Start / Game Over Screens */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border: 2px solid white;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 40px;
            color: #76ff03;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 4px 4px 0 #33691e;
        }

        p {
            font-size: 18px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        button {
            background: #d32f2f;
            color: white;
            border: none;
            padding: 15px 30px;
            font-family: var(--font-main);
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #8e0000;
            transition: transform 0.1s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        .hidden {
            display: none !important;
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Hidden on desktop via JS detection ideally, but keeping simple */
            margin-top: 10px;
            gap: 10px;
        }
        
        @media (max-width: 800px) {
             #mobile-controls { display: flex; }
             canvas { max-width: 100%; height: auto; }
        }

        .d-pad-btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 24px;
            display: flex; 
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            touch-action: manipulation;
        }
        .d-pad-btn:active { background: rgba(255,255,255,0.3); }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="560" height="650"></canvas>
        
        <!-- HUD -->
        <div id="ui-layer">
            <div class="hud-top">
                <span id="score-display">SCORE: 00000</span>
                <span id="lives-display">LIVES: 3</span>
            </div>
            <!-- Timer bar is drawn on canvas, but could be DOM. We will draw it for sync. -->
        </div>

        <!-- Message Overlay -->
        <div id="message-overlay">
            <h1>FROGGER</h1>
            <p>Use Arrow Keys or WASD to move.<br>Avoid cars. Ride logs.<br>Fill all 5 slots to win!</p>
            <button id="start-btn">INSERT COIN / START</button>
        </div>
    </div>

    <!-- Simple Mobile Controls -->
    <div id="mobile-controls">
        <button class="d-pad-btn" id="btn-left">←</button>
        <button class="d-pad-btn" id="btn-up">↑</button>
        <button class="d-pad-btn" id="btn-down">↓</button>
        <button class="d-pad-btn" id="btn-right">→</button>
    </div>

<script>
/**
 * FROGGER ARCADE EDITION
 * Expert HTML5/JS Implementation
 */

// --- CONFIGURATION ---
const CANVAS_WIDTH = 560;
const CANVAS_HEIGHT = 650;
const GRID_SIZE = 40; // Size of one grid cell
const ROWS = Math.floor(CANVAS_HEIGHT / GRID_SIZE); 
const COLS = Math.floor(CANVAS_WIDTH / GRID_SIZE);

// Colors
const COLOR_GRASS_LIGHT = '#4caf50';
const COLOR_GRASS_DARK = '#388e3c';
const COLOR_ROAD = '#311b92'; // Purple road as requested
const COLOR_WATER = '#0288d1';
const COLOR_WATER_DEEP = '#01579b';
const COLOR_FROG = '#76ff03';
const COLOR_FROG_DARK = '#64dd17';

// Game State Enums
const STATE_MENU = 0;
const STATE_PLAYING = 1;
const STATE_GAMEOVER = 2;
const STATE_LEVEL_TRANSITION = 3;

// --- AUDIO HANDLER (Placeholders) ---
const AudioSys = {
    playJump: () => { console.log("Audio: Jump"); /* synth beep */ },
    playDie: () => { console.log("Audio: Die"); /* noise crash */ },
   playHome: () => { console.log("Audio: Home"); /* high score sound */ },
    playDive: () => { console.log("Audio: Dive"); /* splash */ }
};

// --- CLASSES ---

class Sprite {
    constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.markedForDeletion = false;
    }

    draw(ctx) {
        // Base draw
        ctx.fillStyle = 'white';
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.size = Math.random() * 5 + 2;
        this.speedX = (Math.random() - 0.5) * 4;
        this.speedY = (Math.random() - 0.5) * 4;
        this.life = 1.0; // Opacity
    }
    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= 0.05;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

class FloatingText {
    constructor(text, x, y, color='white') {
        this.text = text;
        this.x = x;
        this.y = y;
        this.color = color;
        this.life = 60; // frames
        this.dy = -1;
    }
    update() {
        this.y += this.dy;
        this.life--;
    }
    draw(ctx) {
        ctx.font = "bold 20px 'Courier New'";
        ctx.fillStyle = this.color;
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
    }
}

// The Player
class Frog {
    constructor() {
        this.reset();
        this.spriteW = GRID_SIZE - 8;
        this.spriteH = GRID_SIZE - 8;
        
        // Animation states: 0 = neutral, 1 = jump extended
        this.animFrame = 0; 
        this.facing = 'up'; 
    }

    reset() {
        this.gridX = 6; // Middle column
        this.gridY = 13; // Bottom row (Start)
        this.x = this.gridX * GRID_SIZE + 4;
        this.y = this.gridY * GRID_SIZE + 4;
        this.width = this.spriteW;
        this.height = this.spriteH;
        this.isDead = false;
        this.onLog = false;
        this.logSpeed = 0;
        this.facing = 'up';
    }

    update() {
        // Smooth follow if on log
        if (this.onLog && !this.isDead) {
            this.x += this.logSpeed;
            
            // Update gridX based on actual X to prevent snapping issues
            this.gridX = Math.round((this.x - 4) / GRID_SIZE);
        }

        // Boundaries
        if (this.x < 0) this.x = 0;
        if (this.x > CANVAS_WIDTH - this.width) this.x = CANVAS_WIDTH - this.width;
    }

    move(dir) {
        if (this.isDead) return;

        let nextX = this.gridX;
        let nextY = this.gridY;

        switch(dir) {
            case 'up': 
                nextY--; 
                this.facing = 'up';
                break;
            case 'down': 
                nextY++; 
                this.facing = 'down';
                break;
            case 'left': 
                nextX--; 
                this.facing = 'left';
                break;
            case 'right': 
                nextX++; 
                this.facing = 'right';
                break;
        }

        // Constrain to grid
        if (nextX >= 0 && nextX < COLS && nextY >= 0 && nextY < ROWS) {
            this.gridX = nextX;
            this.gridY = nextY;
            
            // Snap visual position immediately for tight controls, 
            // but we could lerp here. For arcade feel, snap is fine.
            this.x = this.gridX * GRID_SIZE + 4;
            this.y = this.gridY * GRID_SIZE + 4;
            
            this.animFrame = 5; // Trigger animation frames
            AudioSys.playJump();
        }
    }

    draw(ctx) {
        if (this.isDead) return;

        const cx = this.x + this.width/2;
        const cy = this.y + this.height/2;

        ctx.save();
        
        // Death animation handled elsewhere, here is live frog
        
        // Body
        ctx.fillStyle = COLOR_FROG;
        ctx.beginPath();
        if (this.facing === 'left' || this.facing === 'right') {
            ctx.ellipse(cx, cy, this.width/2 - 4, this.height/2 - 2, 0, 0, Math.PI*2);
        } else {
            ctx.ellipse(cx, cy, this.width/2 - 2, this.height/2 - 4, 0, 0, Math.PI*2);
        }
        ctx.fill();
        
        // Legs (Animated)
        ctx.strokeStyle = COLOR_FROG_DARK;
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';

        const legOffset = (this.animFrame > 0) ? 6 : 0; // Jump extension
        if (this.animFrame > 0) this.animFrame--;

        const drawLeg = (lx, ly, angle) => {
            ctx.beginPath();
            ctx.moveTo(cx + lx, cy + ly);
            ctx.lineTo(cx + lx + Math.cos(angle)*12 - legOffset, cy + ly + Math.sin(angle)*12 - legOffset);
            // Foot
            ctx.fillStyle = COLOR_FROG;
            ctx.fillRect(cx + lx + Math.cos(angle)*14 - legOffset, cy + ly + Math.sin(angle)*14 - legOffset, 6, 6); 
            ctx.stroke();
        };

        if (this.facing === 'up') {
            drawLeg(-8, -5, -Math.PI/4); // Back L
            drawLeg(8, -5, -3*Math.PI/4); // Back R
            drawLeg(-8, 5, Math.PI/4);    // Front L
            drawLeg(8, 5, 3*Math.PI/4);   // Front R
        } else if (this.facing === 'down') {
            drawLeg(-8, -5, Math.PI/4);
            drawLeg(8, -5, 3*Math.PI/4);
            drawLeg(-8, 5, -Math.PI/4);
            drawLeg(8, 5, -3*Math.PI/4);
        } else if (this.facing === 'left') {
            drawLeg(5, -8, -Math.PI/2 + 0.5);
            drawLeg(5, 8, Math.PI/2 - 0.5);
            drawLeg(-5, -8, -Math.PI/2 - 0.5);
            drawLeg(-5, 8, Math.PI/2 + 0.5);
        } else { // right
             drawLeg(5, -8, -Math.PI/2 - 0.5);
            drawLeg(5, 8, Math.PI/2 + 0.5);
            drawLeg(-5, -8, -Math.PI/2 + 0.5);
            drawLeg(-5, 8, Math.PI/2 - 0.5);
        }

        // Eyes
        ctx.fillStyle = 'white';
        const eyeOffX = (this.facing === 'left') ? -6 : (this.facing === 'right' ? 6 : 4);
        const eyeOffY = (this.facing === 'up') ? -8 : (this.facing === 'down' ? 8 : -6);
        
        ctx.beginPath();
        ctx.arc(cx + eyeOffX, cy + eyeOffY, 5, 0, Math.PI*2); // Right Eye
        ctx.arc(cx - eyeOffX, cy + eyeOffY, 5, 0, Math.PI*2); // Left Eye
        ctx.fill();

        ctx.fillStyle = 'black';
        const pupilOffX = (this.facing === 'left') ? -2 : (this.facing === 'right' ? 2 : 0);
        const pupilOffY = (this.facing === 'up') ? -2 : (this.facing === 'down' ? 2 : 0);

        ctx.beginPath();
        ctx.arc(cx + eyeOffX + pupilOffX, cy + eyeOffY + pupilOffY, 2, 0, Math.PI*2);
        ctx.arc(cx - eyeOffX + pupilOffX, cy + eyeOffY + pupilOffY, 2, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}

// Obstacles (Cars, Logs, Turtles)
class Obstacle extends Sprite {
    constructor(x, y, width, speed, type) {
        super(x, y, width, GRID_SIZE);
        this.speed = speed;
        this.type = type; // 'car', 'truck', 'log', 'turtle', 'gator'
        
        // Animation timers
        this.frameCount = 0;
        this.diveState = 0; // 0: surface, 1: diving down, 2: underwater, 3: surfacing
        this.mouthOpen = false;
    }

    update() {
        this.x += this.speed;
        
        // Wrap around logic
        if (this.speed > 0 && this.x > CANVAS_WIDTH) {
            this.x = -this.width;
        } else if (this.speed < 0 && this.x + this.width < 0) {
            this.x = CANVAS_WIDTH;
        }

        this.frameCount++;

        // Turtle Diving Logic
        if (this.type === 'turtle') {
            if (this.frameCount % 300 === 0) this.diveState = 1; // Start dive
            
            if (this.diveState === 1 && this.frameCount % 10 === 0) {
                 // Visual shrink handled in draw
                 if(Math.random() > 0.5) this.diveState = 2; // Underwater
            }
            if (this.frameCount % 450 === 0 && this.diveState === 2) {
                this.diveState = 3; // Surface
            }
            if (this.diveState === 3 && this.frameCount % 10 === 0) {
                this.diveState = 0;
            }
        }

        // Alligator Snapping Logic
        if (this.type === 'gator') {
             if (this.frameCount % 120 === 0) this.mouthOpen = !this.mouthOpen;
        }
    }

    draw(ctx) {
        ctx.save();
        
        if (this.type === 'car' || this.type === 'truck') {
            // Vehicle Body
            let color = '#d32f2f'; // default red car
            if (this.width > GRID_SIZE * 1.5) color = '#fbc02d'; // Truck
            if (Math.abs(this.speed) > 3) color = '#e0e0e0'; // Racer
            
            // Car Body
            ctx.fillStyle = color;
            this.roundRect(ctx, this.x + 2, this.y + 6, this.width - 4, this.height - 12, 5);
            ctx.fill();

            // Roof / Details
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(this.x + 10, this.y + 8, this.width - 20, this.height - 16);

            // Headlights
            ctx.fillStyle = '#fff176';
            if (this.speed > 0) {
                ctx.beginPath(); ctx.arc(this.x + this.width - 5, this.y + 12, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(this.x + this.width - 5, this.y + 28, 3, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.beginPath(); ctx.arc(this.x + 5, this.y + 12, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(this.x + 5, this.y + 28, 3, 0, Math.PI*2); ctx.fill();
            }

            // Wheels
            ctx.fillStyle = '#212121';
            ctx.fillRect(this.x + 8, this.y + 2, 8, 4);
            ctx.fillRect(this.x + this.width - 16, this.y + 2, 8, 4);
            ctx.fillRect(this.x + 8, this.y + 34, 8, 4);
            ctx.fillRect(this.x + this.width - 16, this.y + 34, 8, 4);

        } else if (this.type === 'log') {
            // Log
            const grad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + GRID_SIZE);
            grad.addColorStop(0, '#5d4037');
            grad.addColorStop(0.5, '#8d6e63');
            grad.addColorStop(1, '#5d4037');
            
            ctx.fillStyle = grad;
            this.roundRect(ctx, this.x, this.y + 4, this.width, GRID_SIZE - 8, 10);
            ctx.fill();

            // Wood grain
            ctx.strokeStyle = 'rgba(62, 39, 35, 0.5)';
            ctx.lineWidth = 2;
            for(let i=10; i<this.width; i+=20) {
                ctx.beginPath();
                ctx.moveTo(this.x + i, this.y + 8);
                ctx.lineTo(this.x + i - 5, this.y + GRID_SIZE - 8);
                ctx.stroke();
            }

        } else if (this.type === 'turtle') {
            // Turtles
            const count = Math.floor(this.width / GRID_SIZE);
            
            for(let i=0; i<count; i++) {
                let tx = this.x + i * GRID_SIZE;
                
                if (this.diveState === 2) {
                    // Underwater - barely visible outline
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(tx + GRID_SIZE/2, this.y + GRID_SIZE/2, 14, 0, Math.PI*2);
                    ctx.stroke();
                } else {
                    // Surfacing or Diving animation
                    let scale = (this.diveState === 3) ? 0.5 : 1; // simplistic pop up
                    
                    if(this.diveState === 1) scale = 0.7; // Shrinking

                    ctx.fillStyle = '#2e7d32';
                    ctx.beginPath();
                    ctx.arc(tx + GRID_SIZE/2, this.y + GRID_SIZE/2, 14 * scale, 0, Math.PI*2);
                    ctx.fill();

                    // Shell pattern
                    ctx.strokeStyle = '#a5d6a7';
                    ctx.lineWidth = 1;
                    ctx.beginPath(); 
                    ctx.moveTo(tx + GRID_SIZE/2, this.y + GRID_SIZE/2 - 10*scale);
                    ctx.lineTo(tx + GRID_SIZE/2, this.y + GRID_SIZE/2 + 10*scale);
                    ctx.stroke();

                    // Legs
                    ctx.fillStyle = '#1b5e20';
                    ctx.beginPath(); ctx.arc(tx + 10, this.y + 10, 4 * scale, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(tx + GRID_SIZE - 10, this.y + 10, 4 * scale, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(tx + 10, this.y + GRID_SIZE - 10, 4 * scale, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(tx + GRID_SIZE - 10, this.y + GRID_SIZE - 10, 4 * scale, 0, Math.PI*2); ctx.fill();
                }
            }

        } else if (this.type === 'gator') {
             // Alligator
             const count = Math.floor(this.width / GRID_SIZE);
             
             for(let i=0; i<count; i++) {
                 let gx = this.x + i * GRID_SIZE;
                 
                 // Body
                 ctx.fillStyle = '#388e3c';
                 ctx.beginPath();
                 // Simple elongated shape
                 if (this.speed > 0) {
                     // Facing Right
                     ctx.ellipse(gx + 10, this.y + GRID_SIZE/2, 16, 12, 0, 0, Math.PI*2);
                     ctx.fill();
                     
                     // Head
                     ctx.beginPath();
                     ctx.arc(gx + 24, this.y + GRID_SIZE/2, 8, 0, Math.PI*2); 
                     ctx.fill();

                     // Mouth
                     if (this.mouthOpen) {
                         ctx.fillStyle = '#e57373'; // Red mouth
                         ctx.fillRect(gx + 22, this.y + GRID_SIZE/2 - 2, 8, 4);
                         
                         // Teeth danger zone logic: Visual only here
                         ctx.fillStyle = 'white';
                         ctx.beginPath(); ctx.arc(gx+28, this.y+GRID_SIZE/2-1, 2, 0, Math.PI*2); ctx.fill();
                     } else {
                        ctx.strokeStyle = '#1b5e20'; // Snout line
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(gx + 24, this.y + GRID_SIZE/2);
                        ctx.lineTo(gx + 32, this.y + GRID_SIZE/2);
                        ctx.stroke();
                     }

                 } else {
                     // Facing Left
                     ctx.ellipse(gx + GRID_SIZE - 10, this.y + GRID_SIZE/2, 16, 12, 0, 0, Math.PI*2);
                     ctx.fill();

                     // Head
                     ctx.beginPath();
                     ctx.arc(gx + GRID_SIZE - 24, this.y + GRID_SIZE/2, 8, 0, Math.PI*2); 
                     ctx.fill();
                     
                      if (this.mouthOpen) {
                         ctx.fillStyle = '#e57373';
                         ctx.fillRect(gx + GRID_SIZE - 30, this.y + GRID_SIZE/2 - 2, 8, 4);
                          // Teeth
                         ctx.fillStyle = 'white';
                         ctx.beginPath(); ctx.arc(gx+GRID_SIZE-28, this.y+GRID_SIZE/2-1, 2, 0, Math.PI*2); ctx.fill();
                     } else {
                        ctx.strokeStyle = '#1b5e20';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(gx + GRID_SIZE - 24, this.y + GRID_SIZE/2);
                        ctx.lineTo(gx + GRID_SIZE - 32, this.y + GRID_SIZE/2);
                        ctx.stroke();
                     }
                 }

                 // Eye
                 ctx.fillStyle = '#ffeb3b';
                 let eyeX = (this.speed > 0) ? gx + 26 : gx + GRID_SIZE - 26;
                 ctx.beginPath(); ctx.arc(eyeX, this.y + GRID_SIZE/2 - 6, 2, 0, Math.PI*2); ctx.fill();
             }
        }

        ctx.restore();
    }

    roundRect(ctx, x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
    }
}

// --- MAIN GAME CLASS ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.scoreDisplay = document.getElementById('score-display');
        this.livesDisplay = document.getElementById('lives-display');
        this.msgOverlay = document.getElementById('message-overlay');
        this.startBtn = document.getElementById('start-btn');

        this.frog = new Frog();
        this.obstacles = [];
        this.particles = [];
        this.texts = [];

        // Game State
        this.state = STATE_MENU;
        this.lives = 3;
        this.score = 0;
        this.timeLeft = 60; // Seconds for a run
        this.lastTime = 0;
        this.timerInterval = null;

        // Home Slots (5 slots)
        // Grid X: 1, 4, 7, 10, 13 approx based on width
        // Let's calculate centers. Width 560 / 14 cols = 40px.
        // Slots usually at cols 1, 4, 7, 10, 13 (0-indexed)
        this.homeSlots = [
            {x: 1, filled: false},
            {x: 4, filled: false},
            {x: 7, filled: false}, // Center
            {x: 10, filled: false},
            {x: 13, filled: false}
        ];
        
        this.level = 1;

        // Bind Input
        window.addEventListener('keydown', (e) => this.handleInput(e));
        this.startBtn.addEventListener('click', () => this.startGame());

        // Mobile buttons
        document.getElementById('btn-up').addEventListener('touchstart', (e)=>{ e.preventDefault(); this.frog.move('up'); });
        document.getElementById('btn-down').addEventListener('touchstart', (e)=>{ e.preventDefault(); this.frog.move('down'); });
        document.getElementById('btn-left').addEventListener('touchstart', (e)=>{ e.preventDefault(); this.frog.move('left'); });
        document.getElementById('btn-right').addEventListener('touchstart', (e)=>{ e.preventDefault(); this.frog.move('right'); });

        // Initial Draw
        this.drawBackground();
    }

    initLevel() {
        this.obstacles = [];
        const speedMult = 1 + (this.level - 1) * 0.15;

        // --- ROAD LANES (Rows 9 to 13) ---
        // Row 13 (Start) is empty.
        
        // Lane 12: Slow Trucks Left
        this.addLane(12, 'truck', -2 * speedMult, 3, 180);
        // Lane 11: Fast Cars Right
        this.addLane(11, 'car', 4.5 * speedMult, 3, 40);
        // Lane 10: Slow cars Left
        this.addLane(10, 'car', -2.5 * speedMult, 3, 50);
        // Lane 9: Racers Right (Very fast)
        this.addLane(9, 'car', 6 * speedMult, 1, 60); // Sparse

        // --- RIVER LANES (Rows 2 to 7) ---
        
        // Lane 7: Turtles Left
        this.addLane(7, 'turtle', -3.5 * speedMult, 4, 100);
        // Lane 6: Logs Medium Right
        this.addLane(6, 'log', 2.5 * speedMult, 3, 150); // Long logs
        // Lane 5: Turtles Left (Diving)
        this.addLane(5, 'turtle', -2.8 * speedMult, 4, 100);
        // Lane 4: Gators Right
        this.addLane(4, 'gator', 3 * speedMult, 3, 130); 
        // Lane 3: Logs Long Left
        this.addLane(3, 'log', -2 * speedMult, 2, 220);
        
        // Row 8 is median (Grass)
        // Rows 0-1 are Home area.
    }

    addLane(row, type, speed, count, spacingBase) {
        const y = row * GRID_SIZE;
        for(let i=0; i<count; i++) {
            let x = i * spacingBase + Math.random() * 50;
            
            // Adjust width based on type
            let w = GRID_SIZE;
            if(type === 'truck') w = GRID_SIZE * 2;
            if(type === 'log') w = (Math.random() > 0.5) ? GRID_SIZE * 3 : GRID_SIZE * 4;
            if(type === 'turtle') w = GRID_SIZE * 2;
            if(type === 'gator') w = GRID_SIZE * 3;

            this.obstacles.push(new Obstacle(x, y, w, speed, type));
        }
    }

    startGame() {
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.resetRound();
        this.msgOverlay.classList.add('hidden');
        this.state = STATE_PLAYING;
        this.startTimer();
        this.gameLoop(0);
    }

    resetRound() {
        this.frog.reset();
        this.timeLeft = 60; // Reset time
        this.initLevel();
        
        // Reset home slots visually but keep score logic if needed (Usually full reset on death, but level clear persists)
        // If all filled, we go to next level.
        let allFilled = true;
        for(let s of this.homeSlots) {
            if(!s.filled) allFilled = false;
        }
        
        if(allFilled) {
            this.level++;
            this.homeSlots.forEach(s => s.filled = false);
            // Bonus points
            this.score += 1000;
            this.showFloatingText("LEVEL UP!", CANVAS_WIDTH/2 - 50, CANVAS_HEIGHT/2, '#ffeb3b');
        }

        this.updateUI();
    }

    startTimer() {
        if(this.timerInterval) clearInterval(this.timerInterval);
        this.timerInterval = setInterval(() => {
            if (this.state === STATE_PLAYING) {
                this.timeLeft--;
                if(this.timeLeft <= 0) {
                    this.handleDeath("Time's Up!");
                }
            }
        }, 1000);
    }

    handleInput(e) {
        if (this.state !== STATE_PLAYING) return;
        
        switch(e.key) {
            case 'ArrowUp': 
            case 'w':
            case 'W':
                this.frog.move('up'); break;
            case 'ArrowDown': 
            case 's':
            case 'S':
                this.frog.move('down'); break;
            case 'ArrowLeft': 
            case 'a':
            case 'A':
                this.frog.move('left'); break;
            case 'ArrowRight': 
            case 'd':
            case 'D':
                this.frog.move('right'); break;
        }
    }

    createExplosion(x, y, color) {
        for(let i=0; i<15; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    showFloatingText(text, x, y, color='white') {
        this.texts.push(new FloatingText(text, x, y, color));
    }

    handleDeath(reason) {
        if(this.frog.isDead) return;
        
        this.frog.isDead = true;
        AudioSys.playDie();
        this.createExplosion(this.frog.x + this.frog.width/2, this.frog.y + this.frog.height/2, COLOR_FROG);
        
        this.showFloatingText(reason, this.frog.x, this.frog.y - 20, 'red');

        this.lives--;
        this.updateUI();

        if (this.lives <= 0) {
            setTimeout(() => this.gameOver(), 1500);
        } else {
            setTimeout(() => {
                // If died in river, reset position. If filled a home slot, don't clear it.
                // Check if we just filled a slot? Logic handled in update loop. 
                // Here we just respawn frog at bottom.
                this.frog.reset();
                
                // Clear the specific slot death effect if any (not implemented to keep simple)
            }, 1500);
        }
    }

    gameOver() {
        this.state = STATE_GAMEOVER;
        clearInterval(this.timerInterval);
        
        const h1 = this.msgOverlay.querySelector('h1');
        const p = this.msgOverlay.querySelector('p');
        const btn = this.msgOverlay.querySelector('button');

        h1.innerText = "GAME OVER";
        h1.style.color = "#d32f2f";
        p.innerHTML = `Final Score: ${this.score}<br>Level Reached: ${this.level}`;
        btn.innerText = "TRY AGAIN";

        this.msgOverlay.classList.remove('hidden');
    }

    checkCollisions() {
        const f = this.frog;
        if(f.isDead) return;

        // 1. Check Bounds
        if (f.x < 0 || f.x + f.width > CANVAS_WIDTH) {
            // If carried off screen by log, death
            if (f.onLog) this.handleDeath("Swept Away!");
            return;
        }

        const row = Math.floor((f.y + f.height/2) / GRID_SIZE);

        // 2. Home Zone (Row 0)
        if (row === 0 || row === 1) {
            // Check specific slots
            let landed = false;
            for(let slot of this.homeSlots) {
                // Slot is a grid column
                // Slot width approx 40px, centered in col.
                const slotCenterX = slot.x * GRID_SIZE + GRID_SIZE/2;
                const frogCenterX = f.x + f.width/2;
                
                if (Math.abs(slotCenterX - frogCenterX) < 20 && !slot.filled) {
                    // Success!
                    AudioSys.playHome();
                    this.score += 200 + (this.timeLeft * 10);
                    slot.filled = true;
                    landed = true;
                    
                    // Visual feedback
                    this.showFloatingText("HOME!", slot.x*GRID_SIZE, f.y, '#76ff03');
                    
                    // Reset frog
                    f.reset();
                    return; 
                } else if (Math.abs(slotCenterX - frogCenterX) < 20 && slot.filled) {
                    // Already filled -> Die
                    this.handleDeath("Occupied!");
                    return;
                }
            }

            // If in home row but didn't hit a slot center, or hit wall between slots
            if (!landed) {
                 this.handleDeath("Missed!");
            }
            return;
        }

        // 3. River Zone (Rows 2 to 7)
        if (row >= 2 && row <= 7) {
            let safe = false;
            f.onLog = false;

            for(let obs of this.obstacles) {
                // Simple AABB
                if (f.x < obs.x + obs.width &&
                    f.x + f.width > obs.x &&
                    f.y < obs.y + obs.height &&
                    f.y + f.height > obs.y) {
                    
                    // Collision with object
                    if (obs.type === 'turtle') {
                        if(obs.diveState !== 2) { // Not submerged
                            safe = true;
                            f.onLog = true;
                            f.logSpeed = obs.speed;
                        }
                    } else if (obs.type === 'gator') {
                        // Check mouth collision? 
                        // Simplified: Gators are safe, except maybe front part?
                        // Let's just make them safe for now as per "logs/turtles" prompt text
                        safe = true;
                        f.onLog = true;
                        f.logSpeed = obs.speed;
                    } else {
                        // Log
                        safe = true;
                        f.onLog = true;
                        f.logSpeed = obs.speed;
                    }
                }
            }

            if (!safe) {
                this.handleDeath("Drowned!");
            } else {
                // Update score slightly for forward progress in river?
            }
        } 
        // 4. Road Zone (Rows 9 to 13)
        else if (row >= 9 && row <= 13) {
            f.onLog = false;
            for(let obs of this.obstacles) {
                 if (f.x < obs.x + obs.width &&
                    f.x + f.width > obs.x &&
                    f.y < obs.y + obs.height &&
                    f.y + f.height > obs.y) {
                        
                        // Hit a car/truck
                        this.handleDeath("Squashed!");
                }
            }
        } 
        // 5. Safe Zones (Row 8 - Median, Row 14 Start)
        else {
            f.onLog = false;
        }
    }

    updateUI() {
        this.scoreDisplay.innerText = `SCORE: ${this.score.toString().padStart(5, '0')}`;
        this.livesDisplay.innerText = `LIVES: ${this.lives}`;
    }

    drawBackground() {
        const ctx = this.ctx;
        
        // 1. Water (Top Half)
        const waterHeight = 8 * GRID_SIZE; 
        ctx.fillStyle = COLOR_WATER;
        ctx.fillRect(0, 2*GRID_SIZE, CANVAS_WIDTH, waterHeight);
        
        // Animated Waves
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        const time = Date.now() / 500;
        for(let y=2; y<9; y++) {
            let yOffset = y * GRID_SIZE + GRID_SIZE/2;
            ctx.beginPath();
            for(let x=0; x<CANVAS_WIDTH; x+=20) {
                ctx.lineTo(x, yOffset + Math.sin(x/30 + time + y)*5);
            }
            ctx.stroke();
        }

        // 2. Purple Road
        const roadY = 9 * GRID_SIZE;
        const roadH = 5 * GRID_SIZE;
        ctx.fillStyle = COLOR_ROAD;
        ctx.fillRect(0, roadY, CANVAS_WIDTH, roadH);

        // Lane Markers
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.setLineDash([15, 15]);
        for(let y=10; y<14; y++) {
            ctx.beginPath();
            ctx.moveTo(0, y*GRID_SIZE);
            ctx.lineTo(CANVAS_WIDTH, y*GRID_SIZE);
            ctx.stroke();
        }
        ctx.setLineDash([]);

        // 3. Grass (Start, Median, Home)
        const drawGrass = (startRow, rows) => {
            ctx.fillStyle = COLOR_GRASS_LIGHT;
            ctx.fillRect(0, startRow * GRID_SIZE, CANVAS_WIDTH, rows * GRID_SIZE);
            
            // Texture detail
            ctx.fillStyle = COLOR_GRASS_DARK;
            for(let i=0; i<100; i++) {
                let gx = (Math.sin(i*132) * 2000 + 2000) % CANVAS_WIDTH;
                let gy = startRow * GRID_SIZE + (Math.cos(i*54)*2000 + 2000) % (rows * GRID_SIZE);
                ctx.fillRect(gx, gy, 4, 4);
            }
        };

        drawGrass(14, 1); // Start
        drawGrass(8, 1);  // Median
        
        // Home Area Background
        ctx.fillStyle = '#1b5e20'; // Darker bank
        ctx.fillRect(0, 0, CANVAS_WIDTH, 2*GRID_SIZE);

        // Draw Bays/Slots
        this.homeSlots.forEach(slot => {
            const x = slot.x * GRID_SIZE;
            
            if (slot.filled) {
                // Draw Frog in slot
                ctx.fillStyle = COLOR_FROG;
                // Simple static frog shape for slot
                ctx.beginPath();
                ctx.arc(x + GRID_SIZE/2, GRID_SIZE + 10, 12, 0, Math.PI*2);
                ctx.fill();
            } else {
                // Draw Water Bay
                ctx.fillStyle = COLOR_WATER_DEEP;
                ctx.fillRect(x + 5, GRID_SIZE/2, GRID_SIZE - 10, GRID_SIZE * 1.5 - 5);
                
                // Blue Lilies
                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.arc(x+GRID_SIZE/2, GRID_SIZE+15, 8, 0, Math.PI*2);
                ctx.fill();
            }
        });
    }

    drawHUD() {
        // Timer Bar
        const pct = this.timeLeft / 60;
        const barW = CANVAS_WIDTH * pct;
        
        this.ctx.fillStyle = (pct < 0.3) ? 'red' : '#ffeb3b';
        this.ctx.fillRect(0, CANVAS_HEIGHT - 10, barW, 10);
    }

    gameLoop(timestamp) {
        if(this.state !== STATE_PLAYING) return;

        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;

        // Clear
        this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw Static BG
        this.drawBackground();

        // Update & Draw Obstacles
        this.obstacles.forEach(obs => {
            obs.update();
            obs.draw(this.ctx);
        });

        // Frog Logic
        this.frog.update();
        this.checkCollisions(); // Collision before draw so death anim overrides
        this.frog.draw(this.ctx);

        // Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.update();
            p.draw(this.ctx);
            if(p.life <= 0) this.particles.splice(i, 1);
        }

        // Floating Texts
        for (let i = this.texts.length - 1; i >= 0; i--) {
            let t = this.texts[i];
            t.update();
            t.draw(this.ctx);
            if(t.life <= 0) this.texts.splice(i, 1);
        }

        // HUD
        this.drawHUD();

        requestAnimationFrame((t) => this.gameLoop(t));
    }
}

// Start Game Instance
window.onload = () => {
    const game = new Game();
};

</script>
</body>
</html>