```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Mario Bros - JS Clone</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #5c94fc; /* NES Sky Blue */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #202020;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            color: white;
        }

        #game-container {
            position: relative;
            width: 800px; /* Base resolution */
            height: 600px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: var(--bg-color);
            overflow: hidden;
        }

        canvas {
            display: block;
            image-rendering: pixelated; /* Essential for crisp 8-bit look */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-row {
            display: flex;
            justify-content: space-between;
            text-transform: uppercase;
            font-size: 16px;
            text-shadow: 2px 2px #000;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
        }

        .hidden {
            display: none !important;
        }

        h1 { font-size: 40px; color: #ffce00; text-shadow: 4px 4px #b33a00; margin-bottom: 20px; }
        p { font-size: 14px; line-height: 1.5; text-align: center; max-width: 600px; }
        
        .blink {
            animation: blinker 1s linear infinite;
        }

        @keyframes blinker {
            50% { opacity: 0; }
        }

        /* Controls hint */
        .controls-hint {
            margin-top: 30px;
            font-size: 10px;
            color: #aaa;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div class="hud-row">
            <div>MARIO<br><span id="score">000000</span></div>
            <div>COINS<br><span id="coins">x00</span></div>
            <div>WORLD<br>1-1</div>
            <div>TIME<br><span id="time">300</span></div>
            <div>LIVES<br><span id="lives">3</span></div>
        </div>
    </div>

    <div id="start-screen">
        <h1>SUPER JS BROS</h1>
        <p>A faithful recreation using HTML5 Canvas.</p>
        <button class="blink" style="font-family: 'Press Start 2P'; padding: 15px; cursor: pointer; background: #e52521; border: 4px solid white; color: white; margin-top:20px;" onclick="startGame()">START GAME</button>
        <div class="controls-hint">
            ARROWS to Move • Z to Jump • X to Run/Fire
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 id="go-title">GAME OVER</h1>
        <p id="go-score"></p>
        <button class="blink" style="font-family: 'Press Start 2P'; padding: 15px; cursor: pointer; background: #e52521; border: 4px solid white; color: white; margin-top:20px;" onclick="resetGame()">TRY AGAIN</button>
    </div>
</div>

<script>
/**
 * ENGINE CONFIGURATION & CONSTANTS
 */
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const TILE_SIZE = 32;
const GRAVITY = 0.5; // Standard gravity
const UNDERWATER_GRAVITY = 0.2;
const FRICTION = 0.8;
const ACCELERATION = 0.4;
const MAX_SPEED = 6;
const JUMP_FORCE = -11;
const BOUNCE_FORCE = -6;

// Colors for procedural generation
const PALETTE = {
    SKY: '#5c94fc',
    GROUND: '#c84c0c', // Brick brownish
    BRICK: '#b83400',
    BLOCK: '#fb9f2c', // Question block gold
    PIPE: '#00aa00',
    MARIO_RED: '#d70000',
    MARIO_SKIN: '#fc9838',
    GOOMBA_BROWN: '#ab6239'
};

/**
 * AUDIO SYSTEM (Stubs)
 */
const AudioSys = {
    play: (name) => {
        // console.log(`[Audio] Playing: ${name}`);
        // In a real implementation, use AudioContext with oscillators here.
    }
};

/**
 * INPUT HANDLER
 */
class InputHandler {
    constructor() {
        this.keys = {};
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);
    }
    isDown(code) { return !!this.keys[code]; }
}

/**
 * SPRITE GENERATOR
 * Creates off-screen canvases for pixel art to avoid external assets.
 */
const SpriteGen = {
    createCanvas: (w, h) => {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        return c;
    },
    
    // Helper to draw a pixel grid
    drawGrid: (ctx, map, colors, scale = 1) => {
        for(let y=0; y<map.length; y++) {
            for(let x=0; x<map[y].length; x++) {
                const colorCode = map[y][x];
                if(colors[colorCode]) {
                    ctx.fillStyle = colors[colorCode];
                    ctx.fillRect(x*scale, y*scale, scale, scale);
                }
            }
        }
    },

    generate: () => {
        const sprites = {};

        // 1. Mario (Small - Idle)
        const mIdle = SpriteGen.createCanvas(16, 16);
        const midCtx = mIdle.getContext('2d');
        // Simple pixel art representation
        const mMap = [
            "....RRRR....",
            "...RRRRRR...",
            "..RRSSSSRR..",
            "..RSSSSSSR..",
            ".RRSSBBSSRR.",
            ".RRSSBBSSRR.",
            ".RRSSSSSSRR.",
            "..RRRRRRRR..",
            ".BBBB.BBBB.",
            "B.BB...BB.B",
            "B.B.....B.B",
            "............"
        ];
        const mColors = { 'R': PALETTE.MARIO_RED, 'S': PALETTE.MARIO_SKIN, 'B': '#3300aa' }; // B is blue overalls
        SpriteGen.drawGrid(midCtx, mMap, mColors, 1); // Scale up later in draw
        sprites.mario_small = mIdle;

        // 2. Goomba
        const gMap = [
            ".GGGGGGG.",
            "GGGGGGGGG",
            "GGBBBBGGG",
            "GGGGGGGGG",
            "GGWGWGWGG",
            "GWGWGWGWG",
            "GWWWWWWWG",
            ".GGGGGGG."
        ];
        const gColors = { 'G': PALETTE.GOOMBA_BROWN, 'B': '#000', 'W': '#fff' };
        const goomba = SpriteGen.createCanvas(16, 16);
        SpriteGen.drawGrid(goomba.getContext('2d'), gMap, gColors, 1);
        sprites.goomba = goomba;

        // 3. Brick
        const brick = SpriteGen.createCanvas(32, 32);
        const bCtx = brick.getContext('2d');
        bCtx.fillStyle = PALETTE.BRICK;
        bCtx.fillRect(0,0,32,32);
        bCtx.fillStyle = '#000'; // Mortar
        bCtx.fillRect(0,15,32,2);
        bCtx.fillRect(15,0,2,15);
        bCtx.fillRect(7,17,2,15);
        sprites.brick = brick;

        // 4. Question Block
        const qBlock = SpriteGen.createCanvas(32, 32);
        const qCtx = qBlock.getContext('2d');
        qCtx.fillStyle = PALETTE.BLOCK;
        qCtx.fillRect(0,0,32,32);
        qCtx.fillStyle = '#b86800'; // Shadow/Border
        qCtx.strokeRect(0,0,32,32);
        qCtx.fillStyle = '#6e3100';
        qCtx.font = 'bold 20px monospace';
        qCtx.fillText('?', 9, 24);
        sprites.qblock = qBlock;

        // 5. Ground
        const ground = SpriteGen.createCanvas(32, 32);
        const gndCtx = ground.getContext('2d');
        gndCtx.fillStyle = PALETTE.GROUND;
        gndCtx.fillRect(0,0,32,32);
        gndCtx.fillStyle = '#000'; // Detail
        gndCtx.fillRect(4,4,4,4);
        gndCtx.fillRect(20,10,6,6);
        sprites.ground = ground;

        // 6. Pipe Top Left
        const pTL = SpriteGen.createCanvas(32, 32);
        const ptCtx = pTL.getContext('2d');
        ptCtx.fillStyle = PALETTE.PIPE;
        ptCtx.fillRect(4,0,28,32); // Main body
        ptCtx.fillStyle = '#006600'; // Darker shade
        ptCtx.fillRect(4,0,4,32);
        sprites.pipe_tl = pTL;

        return sprites;
    }
};

const Sprites = SpriteGen.generate();

/**
 * GAME CLASSES
 */

class Camera {
    constructor(width, height) {
        this.x = 0;
        this.y = 0;
        this.width = width;
        this.height = height;
    }
    
    update(targetX, levelWidth) {
        // Center target horizontally
        this.x = targetX - this.width / 2;
        
        // Clamp to level bounds
        if (this.x < 0) this.x = 0;
        if (this.x + this.width > levelWidth) this.x = levelWidth - this.width;
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 0.5) * 6;
        this.life = 1.0;
        this.color = color;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += GRAVITY; // Gravity affects particles
        this.life -= 0.05;
    }
    draw(ctx, camX) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camX, this.y, 6, 6);
        ctx.globalAlpha = 1.0;
    }
}

class Entity {
    constructor(x, y, w, h) {
        this.x = x; this.y = y;
        this.w = w; this.h = h;
        this.vx = 0; this.vy = 0;
        this.dead = false;
    }
    
    // AABB Collision
    collides(other) {
        return (this.x < other.x + other.w &&
                this.x + this.w > other.x &&
                this.y < other.y + other.h &&
                this.y + this.h > other.y);
    }

    resolveMapCollision(map, tileSize) {
        // Check corners
        const startX = Math.floor(this.x / tileSize);
        const endX = Math.floor((this.x + this.w - 0.1) / tileSize);
        const startY = Math.floor(this.y / tileSize);
        const endY = Math.floor((this.y + this.h - 0.1) / tileSize);

        // X Collision
        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                if (map[y] && map[y][x] === '#') { // Solid tile
                    if (this.vx > 0) this.x = x * tileSize - this.w;
                    else if (this.vx < 0) this.x = (x + 1) * tileSize;
                    this.vx = 0;
                }
            }
        }

        // Y Collision
        const startY2 = Math.floor(this.y / tileSize);
        const endY2 = Math.floor((this.y + this.h - 0.1) / tileSize);
        
        for (let y = startY2; y <= endY2; y++) {
            for (let x = startX; x <= endX; x++) {
                if (map[y] && map[y][x] === '#') {
                    if (this.vy > 0) { // Landing
                        this.y = y * tileSize - this.h;
                        this.grounded = true;
                    } else if (this.vy < 0) { // Hitting head
                        this.y = (y + 1) * tileSize;
                    }
                    this.vy = 0;
                }
            }
        }
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 28, 28); // Slightly smaller than tile for better feel
        this.speed = MAX_SPEED;
        this.grounded = false;
        this.facingRight = true;
        this.state = 'small'; // small, big, fire
        this.invincible = 0;
    }

    update(input, map, tileSize) {
        if (this.dead) return;

        // Horizontal Movement
        if (input.isDown('ArrowRight')) {
            this.vx += ACCELERATION;
            this.facingRight = true;
        } else if (input.isDown('ArrowLeft')) {
            this.vx -= ACCELERATION;
            this.facingRight = false;
        } else {
            this.vx *= FRICTION; // Slide to stop
        }

        // Clamp speed
        const runMult = input.isDown('KeyX') ? 1.5 : 1.0;
        if (Math.abs(this.vx) > this.speed * runMult) {
            this.vx = Math.sign(this.vx) * this.speed * runMult;
        }
        
        // Stop completely if very slow
        if (Math.abs(this.vx) < 0.1) this.vx = 0;

        // Apply Gravity
        const g = (map.type === 'underwater') ? UNDERWATER_GRAVITY : GRAVITY;
        this.vy += g;

        // Jump
        if (input.isDown('KeyZ') && this.grounded) {
            this.vy = JUMP_FORCE;
            this.grounded = false;
            AudioSys.play('jump');
        }

        // Variable jump height
        if (!input.isDown('KeyZ') && this.vy < -3) {
            this.vy = -3; 
        }

        // Move X
        this.x += this.vx;
        this.resolveMapCollision(map, tileSize);

        // Move Y
        this.y += this.vy;
        this.grounded = false; // Assume falling until collision proves otherwise
        this.resolveMapCollision(map, tileSize);

        // Fall off map
        if (this.y > CANVAS_HEIGHT + 100) {
            die();
        }

        if (this.invincible > 0) this.invincible--;
    }

    draw(ctx, camX) {
        if (this.dead) return;
        
        // Blinking if invincible
        if (this.invincible > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;

        ctx.save();
        const screenX = this.x - camX;
        
        // Flip sprite if facing left
        if (!this.facingRight) {
            ctx.translate(screenX + this.w, this.y);
            ctx.scale(-1, 1);
            ctx.drawImage(Sprites.mario_small, 0, 0, this.w, this.h);
        } else {
            ctx.drawImage(Sprites.mario_small, screenX, this.y, this.w, this.h);
        }
        
        ctx.restore();
    }

    grow() {
        if (this.state === 'small') {
            this.state = 'big';
            this.y -= 16;
            this.h = 44; // Grow hitbox
            AudioSys.play('powerup');
            // Add particle effect here in full version
        }
    }

    shrink() {
        if (this.state !== 'small') {
            this.state = 'small';
            this.h = 28;
            this.invincible = 120; // 2 seconds at 60fps
            AudioSys.play('pipe'); // reuse sound
        } else {
            die();
        }
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, 32, 32);
        this.type = type; // 'goomba', 'koopa'
        this.vx = -1;
        this.active = false; // Only move when on screen
    }

    update(map, tileSize, camX) {
        if (this.dead) return;

        // Activate only when near camera
        if (Math.abs(this.x - camX) < CANVAS_WIDTH + 100) this.active = true;
        if (!this.active) return;

        this.vy += GRAVITY;
        
        // Simple AI: Walk left, turn on wall
        this.x += this.vx;
        let hitWall = false;
        
        // Basic collision check for walls (simplified)
        const gridX = Math.floor((this.x + (this.vx > 0 ? this.w : 0)) / tileSize);
        const gridY = Math.floor(this.y / tileSize);
        
        if (map[gridY] && map[gridY][gridX] === '#') {
            hitWall = true;
        }

        if (hitWall) {
            this.vx *= -1;
            this.x += this.vx * 2; // Bounce back
        }

        this.y += this.vy;
        
        // Ground check
        const groundY = Math.floor((this.y + this.h) / tileSize);
        const centerX = Math.floor((this.x + this.w/2) / tileSize);
        
        if (map[groundY] && map[groundY][centerX] === '#') {
            this.y = groundY * tileSize - this.h;
            this.vy = 0;
        }
    }

    draw(ctx, camX) {
        if (this.dead || !this.active) return;
        ctx.drawImage(Sprites.goomba, this.x - camX, this.y, 32, 32);
    }
}

class Item extends Entity {
    constructor(x, y, type) {
        super(x, y, 32, 32);
        this.type = type; // 'mushroom', 'coin'
        this.vx = 2;
        this.vy = 0;
        this.emerging = true; // Animation for coming out of block
        this.targetY = y - 32;
    }

    update(map, tileSize) {
        if (this.type === 'coin') {
            this.dead = true; // Instant collect in this simple version
            return;
        }

        if (this.emerging) {
            this.y -= 1;
            if (this.y <= this.targetY) {
                this.emerging = false;
            }
            return;
        }

        this.vy += GRAVITY;
        this.x += this.vx;
        
        // Simple collision
        const gridX = Math.floor((this.x + (this.vx > 0 ? this.w : 0)) / tileSize);
        const gridY = Math.floor(this.y / tileSize);
        if (map[gridY] && map[gridY][gridX] === '#') {
            this.vx *= -1;
        }

        this.y += this.vy;
        
        // Ground
        const groundY = Math.floor((this.y + this.h) / tileSize);
        const centerX = Math.floor((this.x + this.w/2) / tileSize);
        if (map[groundY] && map[groundY][centerX] === '#') {
            this.y = groundY * tileSize - this.h;
            this.vy = 0;
        }
    }

    draw(ctx, camX) {
        if (this.dead) return;
        
        // Draw Mushroom
        ctx.fillStyle = '#d70000'; // Red cap
        ctx.beginPath();
        ctx.arc(this.x - camX + 16, this.y + 10, 14, Math.PI, 0);
        ctx.fill();
        
        ctx.fillStyle = '#fff'; // Spots
        ctx.beginPath();
        ctx.arc(this.x - camX + 10, this.y + 5, 4, 0, Math.PI*2);
        ctx.arc(this.x - camX + 22, this.y + 8, 3, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = '#fc9838'; // Stem
        ctx.fillRect(this.x - camX + 10, this.y + 10, 12, 20);
    }
}

/**
 * LEVEL DATA (String Map)
 * . = Empty
 * # = Ground/Brick
 * B = Breakable Brick
 * ? = Question Block
 * P = Pipe Body
 * T = Pipe Top
 * G = Goomba
 */
const LEVEL_MAP = [
    "....................................................................................................",
    "....................................................................................................",
    "....................................................................................................",
    "....................................................................................................",
    "....................................................................................................",
    "....................................................................................................",
    "....................................................................................................",
    "....................................................................................................",
    ".....................???...........................................................................",
    "....................................................................................................",
    ".......?...........................B.B.B..........................................................",
    "...................................B...B..........................................................",
    "......................G............B...B..........................................................",
    "....................#####.........B...B..........................................................",
    "..................................B...B..........................................................",
    ".....................P.......G....B...B..........................................................",
    ".....................P.....#####.B...B..........................................................",
    "........?............P..............B.B...........................................................",
    "....................................................................................................",
    "#######################################...#########################################################################"
];

/**
 * MAIN GAME LOGIC
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const input = new InputHandler();
const camera = new Camera(CANVAS_WIDTH, CANVAS_HEIGHT);

let gameState = 'start'; // start, playing, gameover
let player;
let enemies = [];
let items = [];
let particles = [];
let score = 0;
let coins = 0;
let lives = 3;
let timeLeft = 300;
let lastTime = 0;

function initGame() {
    player = new Player(100, 300);
    enemies = [];
    items = [];
    particles = [];
    
    // Parse Level
    // We scan the map to create entities. 
    // Note: In a full engine, we'd separate static collision grid from dynamic entities.
    // Here, we treat LEVEL_MAP as the source of truth for static tiles and spawn points.
}

function spawnEntities() {
    enemies = [];
    items = [];
    for(let y=0; y<LEVEL_MAP.length; y++) {
        for(let x=0; x<LEVEL_MAP[y].length; x++) {
            const char = LEVEL_MAP[y][x];
            if (char === 'G') {
                enemies.push(new Enemy(x*TILE_SIZE, y*TILE_SIZE, 'goomba'));
            }
        }
    }
}

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    gameState = 'playing';
    score = 0;
    coins = 0;
    lives = 3;
    timeLeft = 300;
    initGame();
    spawnEntities();
    updateHUD();
    requestAnimationFrame(gameLoop);
}

function die() {
    if (player.dead) return;
    player.dead = true;
    AudioSys.play('die');
    lives--;
    updateHUD();
    
    // Death animation logic could go here
    setTimeout(() => {
        if (lives > 0) {
            initGame(); // Reset position
            spawnEntities(); // Reset enemies
        } else {
            gameOver();
        }
    }, 2000);
}

function gameOver() {
    gameState = 'gameover';
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('go-score').innerText = `Final Score: ${score}`;
}

function resetGame() {
    startGame();
}

function updateHUD() {
    document.getElementById('score').innerText = score.toString().padStart(6, '0');
    document.getElementById('coins').innerText = 'x' + coins.toString().padStart(2, '0');
    document.getElementById('lives').innerText = lives;
    document.getElementById('time').innerText = Math.floor(timeLeft);
}

function createParticles(x, y, color) {
    for(let i=0; i<5; i++) {
        particles.push(new Particle(x, y, color));
    }
}

/**
 * MAIN LOOP
 */
function gameLoop(timestamp) {
    if (gameState !== 'playing') return;

    const dt = timestamp - lastTime;
    lastTime = timestamp;

    // Timer Logic
    timeLeft -= 1/60;
    if (timeLeft <= 0) die();
    if (Math.floor(timeLeft) % 1 === 0) updateHUD(); // Optimize DOM updates

    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // --- UPDATE ---
    
    player.update(input, LEVEL_MAP, TILE_SIZE);
    camera.update(player.x, LEVEL_MAP[0].length * TILE_SIZE);

    // Update Enemies
    enemies.forEach(e => e.update(LEVEL_MAP, TILE_SIZE, camera.x));

    // Update Items
    items.forEach(i => i.update(LEVEL_MAP, TILE_SIZE));

    // Update Particles
    particles.forEach(p => p.update());
    particles = particles.filter(p => p.life > 0);

    // --- COLLISION LOGIC ---

    // Player vs Enemies
    enemies.forEach(e => {
        if (!e.dead && player.collides(e)) {
            // Check if jumping on top
            const hitFromTop = (player.vy > 0) && (player.y + player.h - player.vy <= e.y + e.h * 0.5);
            
            if (hitFromTop) {
                e.dead = true;
                player.vy = BOUNCE_FORCE; // Bounce off enemy
                score += 100;
                createParticles(e.x, e.y, '#fff');
                AudioSys.play('stomp');
            } else if (player.invincible === 0) {
                player.shrink();
            }
        }
    });

    // Player vs Items
    items.forEach(i => {
        if (!i.dead && !i.emerging && player.collides(i)) {
            i.dead = true;
            if (i.type === 'mushroom') {
                player.grow();
                score += 1000;
            } else if (i.type === 'coin') {
                coins++;
                score += 200;
            }
        }
    });

    // Player vs Blocks (Interaction)
    const centerX = Math.floor((player.x + player.w/2) / TILE_SIZE);
    const centerY = Math.floor((player.y + player.h/2) / TILE_SIZE);
    
    // Head bonk check
    if (player.vy < 0) { // Moving up
        const headY = Math.floor(player.y / TILE_SIZE);
        const headX = Math.floor((player.x + player.w/2) / TILE_SIZE);
        
        if (LEVEL_MAP[headY] && LEVEL_MAP[headY][headX] === '?') {
            // Hit Question Block
            LEVEL_MAP[headY] = setCharAt(LEVEL_MAP[headY], headX, 'B'); // Turn to empty block
            player.vy = 0;
            
            // Spawn Mushroom or Coin
            if (player.state === 'small') {
                items.push(new Item(headX*TILE_SIZE, headY*TILE_SIZE, 'mushroom'));
            } else {
                items.push(new Item(headX*TILE_SIZE, headY*TILE_SIZE, 'coin')); // Simplified: coin if big
                coins++;
                score += 200;
            }
            AudioSys.play('bump');
        } else if (LEVEL_MAP[headY] && LEVEL_MAP[headY][headX] === 'B') {
             // Hit Brick
             if (player.state === 'big') {
                 LEVEL_MAP[headY] = setCharAt(LEVEL_MAP[headY], headX, '.'); // Destroy
                 createParticles(headX*TILE_SIZE, headY*TILE_SIZE, PALETTE.BRICK);
                 score += 50;
                 AudioSys.play('break');
             } else {
                 AudioSys.play('bump');
             }
        }
    }

    // --- DRAW ---

    // Draw Background (Parallax Clouds)
    ctx.fillStyle = '#fff';
    const cloudOffset = camera.x * 0.5;
    for(let i=0; i<10; i++) {
        let cx = (i * 300 - cloudOffset) % (LEVEL_MAP[0].length * TILE_SIZE);
        if (cx < -100) cx += LEVEL_MAP[0].length * TILE_SIZE;
        ctx.beginPath();
        ctx.arc(cx, 150, 30, 0, Math.PI*2);
        ctx.arc(cx+40, 160, 40, 0, Math.PI*2);
        ctx.arc(cx+80, 150, 30, 0, Math.PI*2);
        ctx.fill();
    }

    // Draw Map
    const startCol = Math.floor(camera.x / TILE_SIZE);
    const endCol = startCol + (CANVAS_WIDTH / TILE_SIZE) + 1;

    for (let y = 0; y < LEVEL_MAP.length; y++) {
        for (let x = startCol; x <= endCol; x++) {
            if (!LEVEL_MAP[y] || !LEVEL_MAP[y][x]) continue;
            
            const tile = LEVEL_MAP[y][x];
            const drawX = Math.floor(x * TILE_SIZE - camera.x);
            const drawY = y * TILE_SIZE;

            if (tile === '#') ctx.drawImage(Sprites.ground, drawX, drawY);
            else if (tile === 'B') ctx.drawImage(Sprites.brick, drawX, drawY);
            else if (tile === '?') ctx.drawImage(Sprites.qblock, drawX, drawY);
            else if (tile === 'P' || tile === 'T') {
                // Simple pipe drawing
                ctx.fillStyle = PALETTE.PIPE;
                ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                ctx.strokeStyle = '#004400';
                ctx.strokeRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    // Draw Entities
    items.forEach(i => i.draw(ctx, camera.x));
    enemies.forEach(e => e.draw(ctx, camera.x));
    player.draw(ctx, camera.x);
    particles.forEach(p => p.draw(ctx, camera.x));

    requestAnimationFrame(gameLoop);
}

// Helper for string manipulation since strings are immutable
function setCharAt(str, index, chr) {
    if(index > str.length-1) return str;
    return str.substring(0,index) + chr + str.substring(index+1);
}

</script>
</body>
</html>