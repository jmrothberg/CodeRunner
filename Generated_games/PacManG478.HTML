<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man 1980 Arcade Tribute</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #111;
            --wall-color: #1919A6; /* Classic Arcade Blue */
            --pacman-color: #FFFF00;
            --text-color: #FFF;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(25, 25, 166, 0.4);
            border: 4px solid #333;
            border-radius: 4px;
        }

        canvas {
            display: block;
            background-color: black;
        }

        /* UI Overlay for Score and Lives */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            font-size: 14px;
            text-transform: uppercase;
        }

        .score-box div, .lives-box div {
            margin-bottom: 5px;
        }

        /* Message Overlay (Start, Game Over) */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 8px;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            color: var(--pacman-color);
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 2px 2px #c00;
        }

        p {
            font-size: 12px;
            line-height: 1.8;
            color: #ddd;
        }

        button {
            background: var(--wall-color);
            color: white;
            border: none;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.1s, background 0.2s;
        }

        button:hover {
            background: #2a2abf;
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        .controls-hint {
            margin-top: 20px;
            font-size: 10px;
            color: #888;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Hidden on desktop by default, shown via JS if touch detected */
            margin-top: 15px;
            gap: 10px;
        }
        
        .d-pad-btn {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 600px) {
            #mobile-controls { display: grid; grid-template-columns: repeat(3, 1fr); }
            .d-pad-btn:nth-child(1) { grid-column: 2; } /* Up */
            .d-pad-btn:nth-child(2) { grid-column: 1; grid-row: 2; } /* Left */
            .d-pad-btn:nth-child(3) { grid-column: 2; grid-row: 2; } /* Down */
            .d-pad-btn:nth-child(4) { grid-column: 3; grid-row: 2; } /* Right */
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-layer">
            <div class="hud-top">
                <div class="score-box">
                    <div>SCORE</div>
                    <div id="score-val">0</div>
                </div>
                <div class="high-score-box">
                    <div>HIGH SCORE</div>
                    <div id="high-score-val">0</div>
                </div>
            </div>
            <!-- Lives are usually drawn at bottom left, but we can put them in HUD or draw on canvas -->
        </div>

        <div id="message-overlay">
            <h1>PAC-MAN</h1>
            <p>Use Arrow Keys to Move</p>
            <p>Eat dots & fruits<br>Avoid ghosts<br>Eat power pellets to hunt!</p>
            <button id="start-btn">INSERT COIN (START)</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="d-pad-btn" data-dir="UP">▲</div>
        <div class="d-pad-btn" data-dir="LEFT">◀</div>
        <div class="d-pad-btn" data-dir="DOWN">▼</div>
        <div class="d-pad-btn" data-dir="RIGHT">▶</div>
    </div>

<script>
/**
 * PAC-MAN ARCADE TRIBUTE
 * 
 * Architecture:
 * 1. Game Loop: Handles update() and draw() cycles.
 * 2. Map System: 2D Array representing walls, pellets, empty space.
 * 3. Entities: Base class for Pacman and Ghosts.
 * 4. AI: Target-based pathfinding for ghosts.
 */

// --- CONFIGURATION ---
const TILE_SIZE = 20; // Base size of one grid square
const FPS = 60;
const PACMAN_SPEED = 2.5; // Pixels per frame (must divide evenly into TILE_SIZE logic or handle interpolation)
const GHOST_SPEED = 2.3; 
const GHOST_FRIGHTENED_SPEED = 1.5;

// Colors
const COLOR_WALL = '#1919A6';
const COLOR_DOT = '#ffb8ae';
const COLOR_PELLET = '#ffb8ae';
const COLOR_PACMAN = '#FFFF00';

// Ghost Colors & Personalities
const GHOST_DATA = [
    { name: 'blinky', color: '#FF0000', type: 'chase' }, // Red
    { name: 'pinky',  color: '#FFB8FF', type: 'ambush' }, // Pink
    { name: 'inky',   color: '#00FFFF', type: 'flank' },  // Cyan
    { name: 'clyde',  color: '#FFB852', type: 'erratic' } // Orange
];

// --- MAP DEFINITION ---
// 1=Wall, 0=Empty, 2=Dot, 3=Power Pellet, 4=Ghost House Door, 5=Ghost House Interior
// This is a simplified representation of the classic map layout (28 columns x 31 rows)
const RAW_MAP = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
    [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
    [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
    [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
    [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
    [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
    [0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,0,0,0,0,0],
    [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
    [0,0,0,0,0,1,2,1,1,0,1,1,1,4,4,1,1,1,0,1,1,2,1,0,0,0,0,0],
    [1,1,1,1,1,1,2,1,1,0,1,5,5,5,5,5,5,1,0,1,1,2,1,1,1,1,1,1],
    [0,0,0,0,0,0,2,0,0,0,1,5,5,5,5,5,5,1,0,0,0,2,0,0,0,0,0,0], // Tunnel row
    [1,1,1,1,1,1,2,1,1,0,1,5,5,5,5,5,5,1,0,1,1,2,1,1,1,1,1,1],
    [0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
    [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
    [0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
    [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
    [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
    [1,3,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,3,1],
    [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
    [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
    [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// --- GAME ENGINE ---

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score-val');
const highScoreEl = document.getElementById('high-score-val');
const overlay = document.getElementById('message-overlay');
const startBtn = document.getElementById('start-btn');

// Set Canvas Size
const COLS = RAW_MAP[0].length;
const ROWS = RAW_MAP.length;
canvas.width = COLS * TILE_SIZE;
canvas.height = ROWS * TILE_SIZE;

// Game State
let gameState = {
    running: false,
    score: 0,
    highScore: localStorage.getItem('pacman_highscore') || 0,
    lives: 3,
    level: 1,
    dotsLeft: 0,
    map: [], // Deep copy of raw map
    fruitTimer: 0,
    activeFruit: null
};

// Directions
const DIR = {
    UP: { x: 0, y: -1 },
    DOWN: { x: 0, y: 1 },
    LEFT: { x: -1, y: 0 },
    RIGHT: { x: 1, y: 0 },
    NONE: { x: 0, y: 0 }
};

// --- CLASSES ---

class Entity {
    constructor(x, y, speed) {
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.dir = DIR.NONE;
        this.nextDir = DIR.NONE;
        this.radius = TILE_SIZE * 0.4;
    }

    // Get grid coordinates
    get gridX() { return Math.floor((this.x + TILE_SIZE / 2) / TILE_SIZE); }
    get gridY() { return Math.floor((this.y + TILE_SIZE / 2) / TILE_SIZE); }

    // Check if perfectly centered on a tile (allowing for small margin of error)
    isCentered() {
        const centerX = this.gridX * TILE_SIZE + TILE_SIZE / 2;
        const centerY = this.gridY * TILE_SIZE + TILE_SIZE / 2;
        return Math.abs(this.x + TILE_SIZE/2 - centerX) < this.speed && 
               Math.abs(this.y + TILE_SIZE/2 - centerY) < this.speed;
    }

    // Snap to center of tile
    snapToCenter() {
        this.x = this.gridX * TILE_SIZE;
        this.y = this.gridY * TILE_SIZE;
    }

    canMove(direction) {
        const nextGridX = this.gridX + direction.x;
        const nextGridY = this.gridY + direction.y;

        // Tunnel wrapping check
        if (nextGridX < 0 || nextGridX >= COLS) return true;

        if (gameState.map[nextGridY] && gameState.map[nextGridY][nextGridX] === 1) {
            return false; // Wall
        }
        
        // Ghost House Door Logic
        const tile = gameState.map[nextGridY][nextGridX];
        if (tile === 4) return false; // Can't walk on door unless special logic
        
        return true;
    }

    move() {
        // Try to change direction if queued and centered
        if (this.nextDir !== DIR.NONE && this.isCentered()) {
            if (this.canMove(this.nextDir)) {
                this.snapToCenter();
                this.dir = this.nextDir;
                this.nextDir = DIR.NONE;
            }
        }

        // Stop if hitting wall
        if (!this.canMove(this.dir) && this.isCentered()) {
            this.dir = DIR.NONE;
            this.snapToCenter();
            return;
        }

        this.x += this.dir.x * this.speed;
        this.y += this.dir.y * this.speed;

        // Screen Wrapping (Tunnel)
        if (this.x < -TILE_SIZE/2) this.x = canvas.width + TILE_SIZE/2;
        if (this.x > canvas.width + TILE_SIZE/2) this.x = -TILE_SIZE/2;
    }
}

class Pacman extends Entity {
    constructor() {
        super(TILE_SIZE * 14, TILE_SIZE * 23, PACMAN_SPEED); // Start position
        this.mouthOpen = 0;
        this.mouthSpeed = 0.2;
        this.rotation = 0;
    }

    update() {
        this.move();
        
        // Mouth Animation
        if (this.dir !== DIR.NONE) {
            this.mouthOpen += this.mouthSpeed;
            if (this.mouthOpen > 0.25 || this.mouthOpen < 0) this.mouthSpeed = -this.mouthSpeed;
            
            // Rotation based on direction
            if (this.dir === DIR.RIGHT) this.rotation = 0;
            if (this.dir === DIR.DOWN) this.rotation = Math.PI / 2;
            if (this.dir === DIR.LEFT) this.rotation = Math.PI;
            if (this.dir === DIR.UP) this.rotation = -Math.PI / 2;
        }

        // Eat Dots
        const gx = this.gridX;
        const gy = this.gridY;
        
        // Bounds check for array access
        if (gy >= 0 && gy < ROWS && gx >= 0 && gx < COLS) {
            const tile = gameState.map[gy][gx];
            
            if (tile === 2) { // Dot
                gameState.map[gy][gx] = 0;
                gameState.score += 10;
                gameState.dotsLeft--;
                checkWin();
            } else if (tile === 3) { // Power Pellet
                gameState.map[gy][gx] = 0;
                gameState.score += 50;
                gameState.dotsLeft--;
                activatePowerMode();
                checkWin();
            }
        }

        // Eat Fruit
        if (gameState.activeFruit) {
            const dx = this.x - gameState.activeFruit.x;
            const dy = this.y - gameState.activeFruit.y;
            if (Math.sqrt(dx*dx + dy*dy) < TILE_SIZE) {
                gameState.score += gameState.activeFruit.points;
                showFloatingText(gameState.activeFruit.points, gameState.activeFruit.x, gameState.activeFruit.y);
                gameState.activeFruit = null;
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2);
        ctx.rotate(this.rotation);
        
        ctx.beginPath();
        // Draw Pacman shape
        const startAngle = 0.2 * Math.PI * (Math.sin(Date.now()/50) + 1); // Oscillate mouth
        const endAngle = 2 * Math.PI - startAngle;
        
        ctx.arc(0, 0, this.radius, startAngle, endAngle);
        ctx.lineTo(0, 0);
        ctx.fillStyle = COLOR_PACMAN;
        ctx.fill();
        ctx.closePath();
        ctx.restore();
    }
}

class Ghost extends Entity {
    constructor(config) {
        // Start in ghost house
        super(TILE_SIZE * 14, TILE_SIZE * 11.5, GHOST_SPEED); 
        this.color = config.color;
        this.name = config.name;
        this.type = config.type;
        
        this.mode = 'scatter'; // scatter, chase, frightened, eaten, house
        this.modeTimer = 0;
        this.frightenedTimer = 0;
        
        // Initial release delay (stagger ghosts)
        this.releaseDelay = (config.name === 'blinky' ? 0 : config.name === 'pinky' ? 200 : config.name === 'inky' ? 400 : 600);
        this.inHouse = true;
    }

    update(pacman) {
        if (this.releaseDelay > 0) {
            this.releaseDelay--;
            return; // Don't move yet
        }
        
        if (this.inHouse) {
            // Simple logic to exit house: move up until out
            this.y -= this.speed;
            if (this.y < TILE_SIZE * 8.5) { // Just above door
                this.inHouse = false;
                this.snapToCenter();
                this.dir = DIR.LEFT; // Start moving left
            }
            return;
        }

        // Handle Frightened Timer
        if (this.mode === 'frightened') {
            this.frightenedTimer--;
            if (this.frightenedTimer <= 0) {
                this.mode = 'chase'; // Return to normal
                this.speed = GHOST_SPEED;
            }
        }

        // Handle Eaten Mode (Return to house)
        if (this.mode === 'eaten') {
            const speed = 4; // Fast return
            // Simple homing to center of map (14, 11.5)
            const targetX = TILE_SIZE * 14;
            const targetY = TILE_SIZE * 11.5;
            
            // Very basic movement for returning home
            if (this.x < targetX) this.x += speed;
            else if (this.x > targetX) this.x -= speed;
            if (this.y < targetY) this.y += speed;
            else if (this.y > targetY) this.y -= speed;

            // Check if arrived
            if (Math.abs(this.x - targetX) < 5 && Math.abs(this.y - targetY) < 5) {
                this.mode = 'chase';
                this.inHouse = true; // Reset logic handled in next frame
                this.releaseDelay = 100; // Wait a bit before leaving again
            }
            return;
        }

        // Normal Movement Logic (Grid Based)
        if (this.isCentered()) {
            this.snapToCenter();
            
            // Determine target tile based on AI mode and personality
            let target = this.getTarget(pacman);
            
            // Get available moves (excluding reverse direction unless dead end)
            const possibleDirs = [];
            [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT].forEach(d => {
                // Don't reverse immediately
                if (d.x === -this.dir.x && d.y === -this.dir.y) return;
                
                if (this.canMove(d)) {
                    possibleDirs.push(d);
                }
            });

            if (possibleDirs.length === 0) {
                // Dead end, must reverse
                this.dir = { x: -this.dir.x, y: -this.dir.y };
            } else {
                // Choose direction that minimizes distance to target
                let bestDir = possibleDirs[0];
                let minDist = Infinity;

                possibleDirs.forEach(d => {
                    const nextX = this.gridX + d.x;
                    const nextY = this.gridY + d.y;
                    const dist = Math.hypot(nextX - target.x, nextY - target.y);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        bestDir = d;
                    }
                });
                
                // Add randomness for frightened mode
                if (this.mode === 'frightened') {
                     bestDir = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                }

                this.dir = bestDir;
            }
        }

        this.x += this.dir.x * (this.mode === 'frightened' ? GHOST_FRIGHTENED_SPEED : this.speed);
        this.y += this.dir.y * (this.mode === 'frightened' ? GHOST_FRIGHTENED_SPEED : this.speed);

        // Wrap
        if (this.x < -TILE_SIZE/2) this.x = canvas.width + TILE_SIZE/2;
        if (this.x > canvas.width + TILE_SIZE/2) this.x = -TILE_SIZE/2;
    }

    getTarget(pacman) {
        // Default fallback
        let tx = 1, ty = 1; 

        if (this.mode === 'frightened') {
            // Random target or just wander? 
            // For simplicity in this implementation, we randomize direction choice in update()
            return { x: Math.random() * COLS, y: Math.random() * ROWS }; 
        }

        if (this.mode === 'eaten') {
             return { x: 14, y: 11.5 };
        }

        // Scatter Targets (Corners)
        const scatterTargets = {
            blinky: { x: COLS - 2, y: 1 },
            pinky: { x: 1, y: 1 },
            inky: { x: COLS - 2, y: ROWS - 2 },
            clyde: { x: 1, y: ROWS - 2 }
        };

        // Switch between Chase and Scatter periodically
        const time = Date.now();
        const cycleTime = 10000; // 10 seconds per mode roughly
        
        if (Math.floor(time / cycleTime) % 2 === 0 && this.mode !== 'frightened') {
            this.mode = 'scatter';
        } else if (this.mode !== 'frightened') {
            this.mode = 'chase';
        }

        if (this.mode === 'scatter') {
            return scatterTargets[this.name];
        }

        // Chase Logic
        switch(this.type) {
            case 'chase': // Blinky: Directly target Pacman
                tx = pacman.gridX;
                ty = pacman.gridY;
                break;
            case 'ambush': // Pinky: Target 4 tiles in front of Pacman
                tx = pacman.gridX + (pacman.dir.x * 4);
                ty = pacman.gridY + (pacman.dir.y * 4);
                break;
            case 'flank': // Inky: Vector based on Blinky and Pacman (Simplified)
                // Targeting tile that is symmetric to Blinky relative to Pacman
                tx = pacman.gridX + (pacman.dir.x * 2) + (pacman.gridX - ghosts[0].gridX);
                ty = pacman.gridY + (pacman.dir.y * 2) + (pacman.gridY - ghosts[0].gridY);
                break;
            case 'erratic': // Clyde: Chase Pacman, but scatter if close
                const dist = Math.hypot(this.gridX - pacman.gridX, this.gridY - pacman.gridY);
                if (dist > 8) {
                    tx = pacman.gridX;
                    ty = pacman.gridY;
                } else {
                    return scatterTargets.clyde; // Run away to corner
                }
                break;
        }

        return { x: tx, y: ty };
    }

    draw() {
        const cx = this.x + TILE_SIZE/2;
        const cy = this.y + TILE_SIZE/2;

        ctx.fillStyle = (this.mode === 'frightened') 
            ? (Math.floor(Date.now() / 200) % 2 === 0 ? '#FFF' : '#00F') // Flash white/blue near end
            : this.color;
        
        if (this.mode === 'eaten') {
            // Draw just eyes when eaten
            this.drawEyes(cx, cy);
            return;
        }

        // Ghost Body (Dome top, wavy bottom)
        ctx.beginPath();
        ctx.arc(cx, cy - 2, this.radius, Math.PI, 0);
        ctx.lineTo(cx + this.radius, cy + this.radius);
        // Wavy feet
        for(let i=1; i<=3; i++) {
            ctx.lineTo(cx + this.radius - (2*this.radius/3)*i, cy + this.radius - (i%2==0 ? 0 : 3));
        }
        ctx.lineTo(cx - this.radius, cy + this.radius);
        ctx.fill();
        ctx.closePath();

        // Eyes
        this.drawEyes(cx, cy);
    }

    drawEyes(cx, cy) {
        ctx.fillStyle = 'white';
        const eyeOffsetX = this.dir.x * 2;
        const eyeOffsetY = this.dir.y * 2;
        
        ctx.beginPath();
        ctx.arc(cx - 4 + eyeOffsetX, cy - 4 + eyeOffsetY, 3, 0, Math.PI*2);
        ctx.arc(cx + 4 + eyeOffsetX, cy - 4 + eyeOffsetY, 3, 0, Math.PI*2);
        ctx.fill();
        
        // Pupils
        ctx.fillStyle = 'blue';
        ctx.beginPath();
        ctx.arc(cx - 4 + eyeOffsetX*1.5, cy - 4 + eyeOffsetY*1.5, 1.5, 0, Math.PI*2);
        ctx.arc(cx + 4 + eyeOffsetX*1.5, cy - 4 + eyeOffsetY*1.5, 1.5, 0, Math.PI*2);
        ctx.fill();
    }
}

// --- GLOBAL VARIABLES ---
let pacman;
let ghosts = [];
let animationId;
let floatingTexts = [];

// --- GAME FUNCTIONS ---

function initGame() {
    // Reset Map
    gameState.map = JSON.parse(JSON.stringify(RAW_MAP));
    
    // Count dots
    gameState.dotsLeft = 0;
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if (gameState.map[r][c] === 2 || gameState.map[r][c] === 3) gameState.dotsLeft++;
        }
    }

    // Reset Entities
    pacman = new Pacman();
    ghosts = GHOST_DATA.map(data => new Ghost(data));
    
    gameState.score = 0;
    gameState.lives = 3;
    gameState.level = 1;
    gameState.activeFruit = null;
    
    updateUI();
}

function startGame() {
    initGame();
    overlay.style.display = 'none';
    gameState.running = true;
    gameLoop();
}

function activatePowerMode() {
    ghosts.forEach(g => {
        if (g.mode !== 'eaten' && !g.inHouse) {
            g.mode = 'frightened';
            g.frightenedTimer = 600; // ~10 seconds at 60fps
            // Reverse direction immediately for classic feel
            g.dir = { x: -g.dir.x, y: -g.dir.y };
        }
    });
}

function checkWin() {
    if (gameState.dotsLeft <= 0) {
        gameState.running = false;
        cancelAnimationFrame(animationId);
        showMessage("LEVEL COMPLETE!", "Starting Next Level...", true);
        setTimeout(() => {
            gameState.level++;
            initGame(); // Reset dots and positions
            gameState.running = true;
            overlay.style.display = 'none';
            gameLoop();
        }, 2000);
    }
}

function handleDeath() {
    gameState.lives--;
    updateUI();
    
    if (gameState.lives <= 0) {
        gameOver();
    } else {
        // Reset positions only
        pacman.x = TILE_SIZE * 14;
        pacman.y = TILE_SIZE * 23;
        pacman.dir = DIR.NONE;
        pacman.nextDir = DIR.NONE;
        
        ghosts.forEach((g, index) => {
            g.x = TILE_SIZE * 14;
            g.y = TILE_SIZE * 11.5;
            g.inHouse = true;
            g.mode = 'scatter';
            g.releaseDelay = (index === 0 ? 0 : index * 200);
        });
        
        // Brief pause
        gameState.running = false;
        setTimeout(() => {
            gameState.running = true;
            gameLoop();
        }, 1500);
    }
}

function gameOver() {
    gameState.running = false;
    cancelAnimationFrame(animationId);
    
    if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
        localStorage.setItem('pacman_highscore', gameState.highScore);
    }
    
    showMessage("GAME OVER", `Final Score: ${gameState.score}`, true);
}

function showMessage(title, subtitle, showBtn) {
    overlay.innerHTML = `<h1>${title}</h1><p>${subtitle}</p>`;
    if (showBtn) {
        const btn = document.createElement('button');
        btn.innerText = "PLAY AGAIN";
        btn.onclick = startGame;
        overlay.appendChild(btn);
    }
    overlay.style.display = 'block';
}

function updateUI() {
    scoreEl.innerText = gameState.score;
    highScoreEl.innerText = gameState.highScore;
    
    // Draw Lives on Canvas (bottom left)
    // We handle this in the draw loop actually, but we could do it here too.
}

function showFloatingText(text, x, y) {
    floatingTexts.push({
        text: text,
        x: x,
        y: y,
        life: 30
    });
}

// --- DRAWING FUNCTIONS ---

function drawMap() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const tile = gameState.map[r][c];
            const x = c * TILE_SIZE;
            const y = r * TILE_SIZE;

            if (tile === 1) { // Wall
                ctx.fillStyle = COLOR_WALL;
                // Simple block walls for now, could be improved to lines
                // To make it look "Great", we draw a slightly smaller rect inside
                ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                
                // Inner detail for wall
                ctx.fillStyle = 'black';
                ctx.fillRect(x + 6, y + 6, TILE_SIZE - 12, TILE_SIZE - 12);
            } else if (tile === 2) { // Dot
                ctx.fillStyle = COLOR_DOT;
                ctx.beginPath();
                ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 2, 0, Math.PI*2);
                ctx.fill();
            } else if (tile === 3) { // Power Pellet
                // Pulsing effect
                const size = 6 + Math.sin(Date.now() / 100) * 2;
                ctx.fillStyle = COLOR_PELLET;
                ctx.beginPath();
                ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, size, 0, Math.PI*2);
                ctx.fill();
            } else if (tile === 4) { // Ghost Door
                ctx.strokeStyle = 'pink';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y + TILE_SIZE/2);
                ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE/2);
                ctx.stroke();
            }
        }
    }
}

function drawFruit() {
    // Logic to spawn fruit
    if (!gameState.activeFruit && gameState.dotsLeft === 100) { // Example trigger
         gameState.activeFruit = { x: TILE_SIZE * 14, y: TILE_SIZE * 17, points: 100, type: 'cherry' };
    }

    if (gameState.activeFruit) {
        const f = gameState.activeFruit;
        ctx.fillStyle = 'red';
        ctx.beginPath();
        // Draw a simple fruit shape
        ctx.arc(f.x + TILE_SIZE/2, f.y + TILE_SIZE/2, 8, 0, Math.PI*2);
        ctx.fill();
        // Leaf
        ctx.fillStyle = 'green';
        ctx.fillRect(f.x + TILE_SIZE/2, f.y + TILE_SIZE/2 - 10, 4, 6);
    }
}

function drawLives() {
    const startX = 10;
    const startY = canvas.height - 20;
    
    for(let i=0; i<gameState.lives-1; i++) { // -1 because current life is playing
        ctx.fillStyle = COLOR_PACMAN;
        ctx.beginPath();
        ctx.arc(startX + (i * 25), startY, 8, 0.2, Math.PI*2);
        ctx.lineTo(startX + (i * 25), startY);
        ctx.fill();
    }
}

function drawFloatingTexts() {
    ctx.font = '10px "Press Start 2P"';
    ctx.fillStyle = '#FFF';
    
    for(let i=floatingTexts.length-1; i>=0; i--) {
        const ft = floatingTexts[i];
        ctx.fillText(ft.text, ft.x, ft.y);
        ft.y -= 1;
        ft.life--;
        if (ft.life <= 0) floatingTexts.splice(i, 1);
    }
}

// --- MAIN LOOP ---

function gameLoop() {
    if (!gameState.running) return;

    // Update
    pacman.update();
    
    ghosts.forEach(ghost => {
        ghost.update(pacman);
        
        // Collision Detection
        const dist = Math.hypot(pacman.x - ghost.x, pacman.y - ghost.y);
        if (dist < TILE_SIZE * 0.8) {
            if (ghost.mode === 'frightened') {
                // Eat Ghost
                ghost.mode = 'eaten';
                gameState.score += 200;
                showFloatingText("200", ghost.x, ghost.y);
            } else if (ghost.mode !== 'eaten') {
                // Pacman Dies
                handleDeath();
                return; // Stop frame processing
            }
        }
    });

    // Draw
    drawMap();
    drawFruit();
    pacman.draw();
    ghosts.forEach(g => g.draw());
    drawLives();
    drawFloatingTexts();

    updateUI();

    animationId = requestAnimationFrame(gameLoop);
}

// --- INPUT HANDLING ---

window.addEventListener('keydown', (e) => {
    if (!gameState.running) return;
    
    switch(e.key) {
        case 'ArrowUp': 
        case 'w':
        case 'W':
            pacman.nextDir = DIR.UP; break;
        case 'ArrowDown': 
        case 's':
        case 'S':
            pacman.nextDir = DIR.DOWN; break;
        case 'ArrowLeft': 
        case 'a':
        case 'A':
            pacman.nextDir = DIR.LEFT; break;
        case 'ArrowRight': 
        case 'd':
        case 'D':
            pacman.nextDir = DIR.RIGHT; break;
    }
});

// Touch Controls
document.querySelectorAll('.d-pad-btn').forEach(btn => {
    btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!gameState.running) return;
        const dir = btn.dataset.dir;
        if (dir === 'UP') pacman.nextDir = DIR.UP;
        if (dir === 'DOWN') pacman.nextDir = DIR.DOWN;
        if (dir === 'LEFT') pacman.nextDir = DIR.LEFT;
        if (dir === 'RIGHT') pacman.nextDir = DIR.RIGHT;
    });
});

startBtn.addEventListener('click', startGame);

// Initial Draw
ctx.fillStyle = 'black';
ctx.fillRect(0, 0, canvas.width, canvas.height);
highScoreEl.innerText = gameState.highScore;

</script>
</body>
</html>