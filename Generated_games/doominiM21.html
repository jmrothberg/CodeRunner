<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JS Raycaster FPS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #hud-top {
            padding: 20px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            font-size: 24px;
            display: flex;
            justify-content: space-between;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: rgba(0, 255, 0, 0.5);
            transform: translate(-50%, -50%);
        }
        #overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 30px;
            pointer-events: auto;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="ui">
    <div id="hud-top">
        <span id="health-display">HEALTH: 100%</span>
        <span id="weapon-display">PISTOL [1]</span>
    </div>
    <div id="crosshair"></div>
</div>
<div id="overlay">CLICK TO START</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * ENGINE CONFIGURATION & CONSTANTS
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on main canvas

// Screen dimensions (Internal resolution, scaled up via CSS)
let screenWidth = 640;
let screenHeight = 360;

// Map Configuration
const MAP_SIZE = 24;
const map = [];
// Generate a procedural cave-like map
for(let y=0; y<MAP_SIZE; y++) {
    let row = [];
    for(let x=0; x<MAP_SIZE; x++) {
        // Borders are walls, random pillars inside
        if(x===0 || x===MAP_SIZE-1 || y===0 || y===MAP_SIZE-1) row.push(1);
        else if(Math.random() < 0.1 && Math.abs(x-12)>2 && Math.abs(y-12)>2) row.push(1);
        else row.push(0);
    }
    map.push(row);
}

// Player State
const player = {
    x: 12.5, y: 12.5,
    dirX: -1, dirY: 0,
    planeX: 0, planeY: 0.66, // The 2D raycaster version of camera plane
    moveSpeed: 0.08,
    rotSpeed: 0.04,
    health: 100,
    weaponIndex: 0
};

// Input State
const keys = { w:false, a:false, s:false, d:false };
let mouseX = 0;

// Game State
let lastTime = 0;
let enemies = [];
let zBuffer = new Array(screenWidth).fill(0);
let textures = {};
let weapons = [];

/**
 * TEXTURE GENERATION (Procedural Graphics)
 */
function createTexture(type) {
    const cvs = document.createElement('canvas');
    cvs.width = 64; cvs.height = 64;
    const cx = cvs.getContext('2d');

    if (type === 'wall') {
        // Base gray
        cx.fillStyle = '#555';
        cx.fillRect(0,0,64,64);
        // Noise
        for(let i=0; i<400; i++) {
            cx.fillStyle = Math.random() > 0.5 ? '#666' : '#444';
            cx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
        }
        // Bricks lines
        cx.strokeStyle = '#222';
        cx.lineWidth = 2;
        cx.beginPath();
        cx.moveTo(0, 32); cx.lineTo(64, 32);
        cx.moveTo(32, 0); cx.lineTo(32, 32);
        cx.moveTo(0, 0); cx.lineTo(0, 64); // Edge
        cx.stroke();
    } else if (type === 'enemy') {
        // Demon face placeholder
        cx.fillStyle = '#800';
        cx.beginPath(); cx.arc(32, 32, 30, 0, Math.PI*2); cx.fill();
        cx.fillStyle = '#f00'; // Eyes
        cx.beginPath(); cx.arc(22, 25, 5, 0, Math.PI*2); cx.fill();
        cx.beginPath(); cx.arc(42, 25, 5, 0, Math.PI*2); cx.fill();
        cx.fillStyle = '#000'; // Mouth
        cx.fillRect(20, 45, 24, 10);
    }
    
    return cvs;
}

textures.wall = createTexture('wall');
textures.enemy = createTexture('enemy');

/**
 * WEAPON SYSTEM
 */
class Weapon {
    constructor(name, color, widthMod, fireRate) {
        this.name = name;
        this.color = color;
        this.widthMod = widthMod; // Visual thickness
        this.fireRate = fireRate;
        this.lastShot = 0;
        this.recoil = 0;
        this.ammo = Infinity;
    }

    draw(x, y, bob) {
        const recoilOffset = this.recoil * 5;
        
        ctx.fillStyle = '#222'; // Gun body dark
        ctx.fillRect(x - 10 + this.widthMod, y - 80 - bob - recoilOffset, 20, 100);
        
        ctx.fillStyle = this.color; // Accents
        if(this.name === "Pistol") {
            ctx.fillRect(x - 5 + this.widthMod, y - 60 - bob - recoilOffset, 10, 40); // Handle
            ctx.fillRect(x - 8 + this.widthMod, y - 100 - bob - recoilOffset, 16, 50); // Barrel
        } else if (this.name === "Shotgun") {
            ctx.fillStyle = '#3d2e1e'; // Wood stock
            ctx.fillRect(x - 15 + this.widthMod, y - 40 - bob - recoilOffset, 30, 80);
            ctx.fillStyle = '#111';
            ctx.fillRect(x - 5 + this.widthMod, y - 110 - bob - recoilOffset, 10, 70); // Barrels
        } else if (this.name === "Chaingun") {
            ctx.fillStyle = '#444'; 
            ctx.fillRect(x - 20 + this.widthMod, y - 50 - bob - recoilOffset, 40, 60);
            ctx.fillStyle = '#888';
            for(let i=0; i<3; i++) ctx.fillRect(x - 15 + (i*10) + this.widthMod, y - 110 - bob - recoilOffset, 5, 60); // Barrels
        } else if (this.name === "Rocket Launcher") {
             ctx.fillStyle = '#4a5e2a';
             ctx.fillRect(x - 12 + this.widthMod, y - 50 - bob - recoilOffset, 24, 80);
             ctx.fillStyle = '#111';
             ctx.fillRect(x - 8 + this.widthMod, y - 120 - bob - recoilOffset, 16, 70); // Tube
        }

        // Muzzle flash
        if (this.recoil > 5) {
            ctx.globalCompositeOperation = 'lighter';
            const grad = ctx.createRadialGradient(x + this.widthMod, y - 130 - bob - recoilOffset, 5, x + this.widthMod, y - 130 - bob - recoilOffset, 40);
            grad.addColorStop(0, '#fff');
            grad.addColorStop(0.4, 'yellow');
            grad.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(x + this.widthMod, y - 130 - bob - recoilOffset, 40, 0, Math.PI*2); ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        }
    }

    update(dt) {
        if (this.recoil > 0) this.recoil -= dt * 20;
        if (this.recoil < 0) this.recoil = 0;
    }

    fire() {
        this.recoil = 15; // Max recoil
        // Simple hit check logic would go here, for now just visual
    }
}

weapons.push(new Weapon("Pistol", "#888", 20, 400));
weapons.push(new Weapon("Shotgun", "#630", -10, 1000));
weapons.push(new Weapon("Chaingun", "#555", 0, 100));
weapons.push(new Weapon("Rocket Launcher", "#4a5e2a", 30, 800));

/**
 * ENEMY SYSTEM
 */
class Enemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.active = true;
        this.speed = 0.03;
        this.hp = 3;
        this.state = 'chase'; // chase, attack
        this.attackTimer = 0;
    }

    update(dt) {
        if (!this.active) return;

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        // Simple AI: Move towards player
        if (dist > 1.5) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        } else {
            // Attack logic
            this.attackTimer += dt;
            if(this.attackTimer > 1000) {
                player.health -= 10;
                document.getElementById('health-display').innerText = `HEALTH: ${player.health}%`;
                document.getElementById('health-display').style.color = 'red';
                setTimeout(() => document.getElementById('health-display').style.color = 'white', 200);
                this.attackTimer = 0;
            }
        }

        // Collision with walls (simple)
        if(map[Math.floor(this.y)][Math.floor(this.x)] > 0) {
             this.x -= (dx / dist) * this.speed; 
             this.y -= (dy / dist) * this.speed;
        }
    }

    draw() {
        if (!this.active) return;
        
        // Sprite transformation logic is handled in main loop for sorting
        // This function just draws the specific sprite at calculated screen coords
    }
}

// Spawn some enemies
for(let i=0; i<5; i++) {
    let ex = 2 + Math.random() * (MAP_SIZE - 4);
    let ey = 2 + Math.random() * (MAP_SIZE - 4);
    if(map[Math.floor(ey)][Math.floor(ex)] === 0) enemies.push(new Enemy(ex, ey));
}

/**
 * INPUT HANDLING
 */
window.addEventListener('resize', resize);
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    screenWidth = canvas.width;
    screenHeight = canvas.height;
    zBuffer = new Array(screenWidth).fill(0);
}
resize();

const overlay = document.getElementById('overlay');
overlay.addEventListener('click', () => {
    canvas.requestPointerLock();
    overlay.style.display = 'none';
});

document.addEventListener('pointerlockchange', () => {
    if (document.pointerLockElement !== canvas) {
        overlay.style.display = 'flex';
    }
});

document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement === canvas) {
        // Rotate player based on mouse X
        const sensitivity = 0.002;
        const rot = e.movementX * sensitivity;
        
        const oldDirX = player.dirX;
        player.dirX = player.dirX * Math.cos(rot) - player.dirY * Math.sin(rot);
        player.dirY = oldDirX * Math.sin(rot) + player.dirY * Math.cos(rot);
        const oldPlaneX = player.planeX;
        player.planeX = player.planeX * Math.cos(rot) - player.planeY * Math.sin(rot);
        player.planeY = oldPlaneX * Math.sin(rot) + player.planeY * Math.cos(rot);
    }
});

document.addEventListener('keydown', (e) => {
    if(e.key === 'w') keys.w = true;
    if(e.key === 's') keys.s = true;
    if(e.key === 'a') keys.a = true;
    if(e.key === 'd') keys.d = true;
    
    // Weapon Switching
    if(e.key >= '1' && e.key <= '4') {
        player.weaponIndex = parseInt(e.key) - 1;
        document.getElementById('weapon-display').innerText = `${weapons[player.weaponIndex].name.toUpperCase()} [${e.key}]`;
    }
});

document.addEventListener('keyup', (e) => {
    if(e.key === 'w') keys.w = false;
    if(e.key === 's') keys.s = false;
    if(e.key === 'a') keys.a = false;
    if(e.key === 'd') keys.d = false;
});

document.addEventListener('mousedown', (e) => {
    if (document.pointerLockElement === canvas && e.button === 0) {
        const now = Date.now();
        const weapon = weapons[player.weaponIndex];
        if(now - weapon.lastShot > weapon.fireRate) {
            weapon.lastShot = now;
            weapon.fire();
            
            // Simple hit detection
            enemies.forEach(en => {
                // Calculate angle to enemy vs player direction
                const dx = en.x - player.x;
                const dy = en.y - player.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Very rough "cone" check based on screen position relative to center
                // In a real engine, we'd cast a ray. Here we just damage if close and looking roughly right.
                // For this demo, let's just do distance check for simplicity or random hitscan
                if(dist < 10) {
                    en.hp -= (player.weaponIndex === 1 ? 3 : 1); // Shotgun does more dmg
                    if(en.hp <= 0) en.active = false;
                }
            });
        }
    }
});

/**
 * MAIN GAME LOOP
 */
function gameLoop(timestamp) {
    const dt = timestamp - lastTime;
    lastTime = timestamp;

    update(dt);
    draw();

    requestAnimationFrame(gameLoop);
}

function update(dt) {
    // Movement Logic
    let moveStep = player.moveSpeed; 
    if(keys.w) {
        if(map[Math.floor(player.y)][Math.floor(player.x + player.dirX * moveStep)] === 0)
            player.x += player.dirX * moveStep;
        if(map[Math.floor(player.y + player.dirY * moveStep)][Math.floor(player.x)] === 0)
            player.y += player.dirY * moveStep;
    }
    if(keys.s) {
        if(map[Math.floor(player.y)][Math.floor(player.x - player.dirX * moveStep)] === 0)
            player.x -= player.dirX * moveStep;
        if(map[Math.floor(player.y - player.dirY * moveStep)][Math.floor(player.x)] === 0)
            player.y -= player.dirY * moveStep;
    }
    // Strafe
    if(keys.d) {
        const sideDirX = -player.dirY; 
        const sideDirY = player.dirX;
        if(map[Math.floor(player.y)][Math.floor(player.x + sideDirX * moveStep)] === 0)
            player.x += sideDirX * moveStep;
        if(map[Math.floor(player.y + sideDirY * moveStep)][Math.floor(player.x)] === 0)
            player.y += sideDirY * moveStep;
    }
    if(keys.a) {
        const sideDirX = player.dirY; 
        const sideDirY = -player.dirX;
        if(map[Math.floor(player.y)][Math.floor(player.x + sideDirX * moveStep)] === 0)
            player.x += sideDirX * moveStep;
        if(map[Math.floor(player.y + sideDirY * moveStep)][Math.floor(player.x)] === 0)
            player.y += sideDirY * moveStep;
    }

    // Update Entities
    weapons.forEach(w => w.update(dt));
    enemies.forEach(e => e.update(dt));
}

function draw() {
    // Clear Background (Ceiling/Floor)
    
    // Ceiling Gradient
    const ceilGrad = ctx.createLinearGradient(0, 0, 0, screenHeight/2);
    ceilGrad.addColorStop(0, '#111');
    ceilGrad.addColorStop(1, '#333');
    ctx.fillStyle = ceilGrad;
    ctx.fillRect(0, 0, screenWidth, screenHeight / 2);

    // Floor Gradient (Darkness at distance)
    const floorGrad = ctx.createLinearGradient(0, screenHeight/2, 0, screenHeight);
    floorGrad.addColorStop(0, '#222');
    floorGrad.addColorStop(1, '#000');
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0, screenHeight / 2, screenWidth, screenHeight / 2);

    // --- RAYCASTING WALLS ---
    for (let x = 0; x < screenWidth; x++) {
        const cameraX = 2 * x / screenWidth - 1;
        const rayDirX = player.dirX + player.planeX * cameraX;
        const rayDirY = player.dirY + player.planeY * cameraX;

        let mapX = Math.floor(player.x);
        let mapY = Math.floor(player.y);

        let sideDistX, sideDistY;
        
        const deltaDistX = (rayDirX === 0) ? 1e30 : Math.abs(1 / rayDirX);
        const deltaDistY = (rayDirY === 0) ? 1e30 : Math.abs(1 / rayDirY);

        let perpWallDist;
        let stepX, stepY;
        let hit = 0;
        let side; // 0 for NS, 1 for EW

        if (rayDirX < 0) { stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; }
        else { stepX = 1; sideDistX = (mapX + 1.0 - player.x) * deltaDistX; }

        if (rayDirY < 0) { stepY = -1; sideDistY = (player.y - mapY) * deltaDistY; }
        else { stepY = 1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; }

        // DDA
        while (hit === 0) {
            if (sideDistX < sideDistY) {
                sideDistX += deltaDistX;
                mapX += stepX;
                side = 0;
            } else {
                sideDistY += deltaDistY;
                mapY += stepY;
                side = 1;
            }
            if (map[mapY][mapX] > 0) hit = 1;
        }

        if (side === 0) perpWallDist = (mapX - player.x + (1 - stepX) / 2) / rayDirX;
        else           perpWallDist = (mapY - player.y + (1 - stepY) / 2) / rayDirY;

        zBuffer[x] = perpWallDist; // Store for sprite sorting

        const lineHeight = Math.floor(screenHeight / perpWallDist);
        
        let drawStart = -lineHeight / 2 + screenHeight / 2;
        if (drawStart < 0) drawStart = 0;
        let drawEnd = lineHeight / 2 + screenHeight / 2;
        if (drawEnd >= screenHeight) drawEnd = screenHeight - 1;

        // Texture calculations
        let wallX; 
        if (side === 0) wallX = player.y + perpWallDist * rayDirY;
        else           wallX = player.x + perpWallDist * rayDirX;
        wallX -= Math.floor(wallX);

        let texX = Math.floor(wallX * 64);
        if(side === 0 && rayDirX > 0) texX = 64 - texX - 1;
        if(side === 1 && rayDirY < 0) texX = 64 - texX - 1;

        // Draw textured wall slice
        ctx.drawImage(
            textures.wall, 
            texX, 0, 1, 64, 
            x, drawStart, 1, drawEnd - drawStart
        );

        // Apply Shading (Distance Fog)
        const shade = Math.max(0, 1 - perpWallDist / 15); // Fog factor
        ctx.fillStyle = `rgba(0,0,0,${1-shade})`; 
        if(side === 1) ctx.fillStyle = `rgba(50,50,50,${1-shade*0.8})`; // Darker side
        
        ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
    }

    // --- SPRITE CASTING (ENEMIES) ---
    
    // Sort enemies by distance (far to near)
    const sortedEnemies = enemies.map(e => {
        return { 
            enemy: e, 
            dist: ((player.x - e.x)**2 + (player.y - e.y)**2) 
        };
    }).sort((a, b) => b.dist - a.dist);

    for(let i=0; i<sortedEnemies.length; i++) {
        const ent = sortedEnemies[i].enemy;
        if(!ent.active) continue;

        // Translate sprite position to relative to camera
        const spriteX = ent.x - player.x;
        const spriteY = ent.y - player.y;

        // Transform with the inverse camera matrix
        const invDet = 1.0 / (player.planeX * player.dirY - player.dirX * player.planeY);
        
        const transformX = invDet * (player.dirY * spriteX - player.dirX * spriteY);
        const transformY = invDet * (-player.planeY * spriteX + player.planeX * spriteY); // This is actually the depth inside the screen

        if(transformY <= 0) continue; // Behind camera

        const spriteScreenX = Math.floor((screenWidth / 2) * (1 + transformX / transformY));
        
        // Calculate height of the sprite on screen
        const spriteHeight = Math.abs(Math.floor(screenHeight / transformY)); 
        
        // Calculate width of the sprite
        const spriteWidth = Math.abs(Math.floor(screenHeight / transformY));

        let drawStartY = -spriteHeight / 2 + screenHeight / 2;
        if(drawStartY < 0) drawStartY = 0;
        let drawEndY = spriteHeight / 2 + screenHeight / 2;
        if(drawEndY >= screenHeight) drawEndY = screenHeight - 1;

        let drawStartX = -spriteWidth / 2 + spriteScreenX;
        let drawEndX = spriteWidth / 2 + spriteScreenX;
        
        // Loop through every vertical stripe of the sprite on screen
        for(let stripe = Math.floor(drawStartX); stripe < Math.floor(drawEndX); stripe++) {
            if(stripe >= 0 && stripe < screenWidth && transformY < zBuffer[stripe]) {
                // Draw slice of enemy texture
                 ctx.drawImage(
                    textures.enemy,
                    (64 * (stripe - (-spriteWidth / 2 + spriteScreenX)) / spriteWidth), 0, 
                    Math.ceil(64 / spriteWidth), 64,
                    stripe, drawStartY, 1, drawEndY - drawStartY
                );
            }
        }
    }

    // --- WEAPON & HUD ---
    
    // Weapon Bobbing
    let bob = 0;
    if(keys.w || keys.s || keys.a || keys.d) {
        bob = Math.sin(Date.now() / 150) * 10;
    }

    const weapon = weapons[player.weaponIndex];
    weapon.draw(screenWidth/2, screenHeight, bob);
}

// Start
requestAnimationFrame(gameLoop);

</script>
</body>
</html>