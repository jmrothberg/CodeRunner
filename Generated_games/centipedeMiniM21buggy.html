<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Centipede - Arcade Classic</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            color: white;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            border: 4px solid #333;
        }
        canvas {
            display: block;
            background-color: black;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
        }
        .score-box { color: #fff; }
        .lives-box { color: #ff0055; }
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.7);
            z-index: 20;
        }
        h1 { font-size: 48px; margin: 0 0 20px 0; color: #00ff00; text-shadow: 0 0 10px #00ff00; }
        p { font-size: 24px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>

<div id="gameContainer">
    <div id="ui">
        <div class="score-box">SCORE: <span id="scoreEl">0</span></div>
        <div class="lives-box">HIGH: <span id="highScoreEl">0</span></div>
        <div class="lives-box">LIVES: <span id="livesEl">3</span></div>
    </div>
    <canvas id="gameCanvas" width="640" height="512"></canvas>
    <div id="overlay">
        <h1>CENTIPEDE</h1>
        <p>PRESS SPACE TO START</p>
    </div>
</div>

<script>
/**
 * CENTIPEDE - ATARI STYLE RECREATION
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONSTANTS & CONFIG ---
const GRID_SIZE = 16;
const PLAYER_SPEED = 4;
const BULLET_SPEED = 8;
const COLS = canvas.width / GRID_SIZE;
const ROWS = canvas.height / GRID_SIZE;

// Colors
const C_PLAYER = '#00ffff';
const C_BULLET = '#ffffff';
const C_MUSHROOM_1 = '#ff0055'; // Full health
const C_MUSHROOM_2 = '#ff9900'; // Damaged
const C_MUSHROOM_3 = '#ffff00'; // Very damaged
const C_POISON = '#aa00ff';     // Poisoned mushroom
const C_CENTIPEDE_HEAD = '#00ff00';
const C_CENTIPEDE_BODY = '#ccff00';

// Game State
let gameState = 'START'; // START, PLAYING, GAMEOVER, LEVEL_TRANSITION
let score = 0;
let highScore = localStorage.getItem('centipede_high') || 0;
let lives = 3;
let level = 1;
let frames = 0;

// Entities
let player;
let bullets = [];
let mushrooms = [];
let centipedes = [];
let enemies = []; // Fleas, Spiders, Scorpions
let particles = [];

// Inputs
const keys = { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false, Space: false };

// --- CLASSES ---

class Player {
    constructor() {
        this.w = 14;
        this.h = 14;
        this.x = canvas.width / 2 - this.w / 2;
        this.y = canvas.height - GRID_SIZE * 2; // Constrained to bottom area
        this.color = C_PLAYER;
        this.cooldown = 0;
    }

    update() {
        if (keys.ArrowLeft && this.x > 0) this.x -= PLAYER_SPEED;
        if (keys.ArrowRight && this.x < canvas.width - this.w) this.x += PLAYER_SPEED;
        
        // Shooting
        if (this.cooldown > 0) this.cooldown--;
        if (keys.Space && this.cooldown <= 0) {
            bullets.push(new Bullet(this.x + this.w/2, this.y));
            this.cooldown = 15; // Fire rate
        }
    }

    draw() {
        ctx.fillStyle = this.color;
        // Draw tank body
        ctx.fillRect(this.x + 2, this.y + 6, 10, 8);
        // Turret
        ctx.fillRect(this.x + 5, this.y, 4, 6);
        
        // Glow effect
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Bullet {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.r = 2;
        this.active = true;
    }

    update() {
        this.y -= BULLET_SPEED;
        if (this.y < 0) this.active = false;
    }

    draw() {
        ctx.fillStyle = C_BULLET;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Mushroom {
    constructor(x, y, isPoison = false) {
        // Snap to grid
        this.gx = x; 
        this.gy = y;
        this.x = x * GRID_SIZE;
        this.y = y * GRID_SIZE;
        this.health = 4;
        this.isPoison = isPoison;
    }

    draw() {
        if (this.health <= 0) return;

        let color;
        if (this.isPoison) {
            color = C_POISON; // Purple for poison
        } else {
            if (this.health === 4) color = C_MUSHROOM_1;
            else if (this.health === 3) color = C_MUSHROOM_2;
            else color = C_MUSHROOM_3;
        }

        ctx.fillStyle = color;
        
        // Draw organic blob shape based on health
        let radius = GRID_SIZE / 2 - 2 + (4-this.health); 
        
        ctx.shadowBlur = 5;
        ctx.shadowColor = color;
        
        ctx.beginPath();
        if(this.isPoison) {
            // Spiky poison mushroom
             ctx.moveTo(this.x + 8, this.y + 2);
             ctx.lineTo(this.x + 14, this.y + 6);
             ctx.lineTo(this.x + 12, this.y + 14);
             ctx.lineTo(this.x + 4, this.y + 14);
             ctx.lineTo(this.x + 2, this.y + 6);
        } else {
            // Round normal mushrooms
            ctx.arc(this.x + 8, this.y + 8, radius, 0, Math.PI * 2);
        }
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    hit() {
        if (this.isPoison) return false; // Bullets disappear but don't damage poison mushrooms
        this.health--;
        
        let particleColor = '#fff';
        if (this.health === 3) particleColor = C_MUSHROOM_2;
        else if (this.health === 2) particleColor = C_MUSHROOM_3;

        createParticles(this.x + 8, this.y + 8, particleColor);
        
        return this.health <= 0;
    }
}

class Centipede {
    constructor(x, y, length, speed) {
        this.segments = [];
        this.speed = speed; // Pixels per frame
        this.direction = 1; // 1 right, -1 left
        this.active = true;

        // Create segments
        for (let i = 0; i < length; i++) {
            this.segments.push({
                x: x,
                y: y + (i * GRID_SIZE),
                isHead: i === 0
            });
        }
    }

    update() {
        if (!this.active) return;

        // Move Head
        let head = this.segments[0];
        
        // Check collision for HEAD only
        let hitObstacle = false;
        
        // Wall check
        if ((head.x <= 0 && this.direction === -1) || (head.x >= canvas.width - GRID_SIZE && this.direction === 1)) {
            hitObstacle = true;
        } else {
            // Mushroom check for head
            let gridX = Math.floor((head.x + (this.direction * GRID_SIZE/2)) / GRID_SIZE);
            let gridY = Math.floor(head.y / GRID_SIZE);
            
            // Check if a mushroom exists at the next position
            let mush = getMushroomAt(gridX, gridY);
            if (mush) {
                hitObstacle = true;
            }
        }

        if (hitObstacle) {
            this.direction *= -1;
            head.y += GRID_SIZE; // Drop down one row
            
            // Prevent going below player area
            if (head.y >= canvas.height - GRID_SIZE * 2) {
                head.y = canvas.height - GRID_SIZE * 3;
            }
        } else {
            head.x += this.direction * this.speed;
        }

        // Move Body segments to follow the one before them
        for (let i = 1; i < this.segments.length; i++) {
            let leader = this.segments[i-1];
            let follower = this.segments[i];

            // Simple follow logic: if far away, move towards leader
            let dx = leader.x - follower.x;
            let dy = leader.y - follower.y;

            // Only move horizontally to catch up (classic behavior)
            
            // If on different rows, drop down immediately to match row
            if (Math.abs(dy) >= GRID_SIZE/2) {
                follower.y = leader.y;
            }

            // Horizontal follow
            let dist = Math.abs(dx);
            if (dist > GRID_SIZE / 2) {
                follower.x += this.speed * this.direction; 
                
                // If we passed the leader or went too far back, snap
                if ((this.direction === 1 && follower.x > leader.x) ||
                    (this.direction === -1 && follower.x < leader.x)) {
                    follower.x = leader.x + (-this.direction * GRID_SIZE);
                }
            } else if (dist < GRID_SIZE / 2) {
                 // Too close, push back
                 follower.x += this.speed * -this.direction;
            }
        }
    }

    draw() {
        for (let i = this.segments.length - 1; i >= 0; i--) {
            let s = this.segments[i];
            
            if (s.isHead) ctx.fillStyle = C_CENTIPEDE_HEAD;
            else ctx.fillStyle = C_CENTIPEDE_BODY;

            // Draw segment
            ctx.shadowBlur = 8;
            ctx.shadowColor = ctx.fillStyle;
            
            // Rounded rect for body
            roundRect(ctx, s.x + 2, s.y + 2, GRID_SIZE - 4, GRID_SIZE - 4, 4);
            
            if (s.isHead) {
                // Eyes
                ctx.fillStyle = 'black';
                let eyeOff = this.direction === 1 ? 8 : 2;
                ctx.fillRect(s.x + eyeOff, s.y + 4, 2, 2);
                ctx.fillRect(s.x + eyeOff, s.y + 10, 2, 2);
            }
            
            ctx.shadowBlur = 0;
        }
    }

    checkHit(bullet) {
        for (let i = 0; i < this.segments.length; i++) {
            let s = this.segments[i];
            // Simple box collision
            if (bullet.x > s.x && bullet.x < s.x + GRID_SIZE &&
                bullet.y > s.y && bullet.y < s.y + GRID_SIZE) {
                
                createParticles(s.x + 8, s.y + 8, C_CENTIPEDE_BODY);
                
                // Hit logic
                if (i === 0) {
                    // Head hit: Destroy entire centipede? 
                    score += 100;
                    this.active = false; 
                    return true;
                } else {
                    // Body hit: Split or shorten
                    score += 10;
                    
                    // Remove segment i
                    this.segments.splice(i, 1);

                    // If there are segments remaining after the hit one (the tail)
                    if (i < this.segments.length) { 
                        // The part that was behind becomes a new centipede
                        let tailSegments = this.segments.splice(i); // Remove from current, get them
                        
                        // Create new centipede with tail segments
                        let newCenti = new Centipede(tailSegments[0].x, tailSegments[0].y, tailSegments.length, this.speed);
                        newCenti.direction = this.direction;
                        // Copy positions exactly
                        for(let k=0; k<tailSegments.length; k++) {
                            newCenti.segments[k] = { ...tailSegments[k], isHead: (k===0) };
                        }
                        centipedes.push(newCenti);
                    } else {
                        // Hit the last segment, just shorten
                    }
                    
                    return true;
                }
            }
        }
        return false;
    }
}

class Enemy {
    constructor(type) {
        this.type = type; // 'flea', 'spider', 'scorpion'
        this.active = true;
        
        if (type === 'flea') {
            this.x = Math.random() * (canvas.width - GRID_SIZE);
            this.y = -GRID_SIZE;
            this.speedY = 2;
            this.color = '#ff3333';
        } else if (type === 'spider') {
            this.x = Math.random() > 0.5 ? 0 : canvas.width - GRID_SIZE;
            this.y = canvas.height - GRID_SIZE * 4; // Bottom area
            this.vx = 2;
            this.vy = 1.5;
            this.color = '#ff00ff';
        } else if (type === 'scorpion') {
            this.x = Math.random() > 0.5 ? -GRID_SIZE : canvas.width;
            this.y = GRID_SIZE * (Math.floor(Math.random() * 10) + 2); // Middle rows
            this.vx = this.x < 0 ? 1.5 : -1.5;
            this.color = '#00ffaa';
        }
    }

    update() {
        if (!this.active) return;

        if (this.type === 'flea') {
            this.y += this.speedY;
            
            // Drop mushrooms
            if (Math.random() < 0.25 && this.y > GRID_SIZE && this.y < canvas.height - GRID_SIZE * 2) {
                let gx = Math.floor(this.x / GRID_SIZE);
                let gy = Math.floor(this.y / GRID_SIZE);
                spawnMushroom(gx, gy);
            }

            if (this.y > canvas.height) this.active = false;
        } 
        else if (this.type === 'spider') {
            this.x += this.vx;
            this.y += Math.sin(frames * 0.1) * 2; // Zigzag

            // Bounce walls
            if (this.x <= 0 || this.x >= canvas.width - GRID_SIZE) this.vx *= -1;
            
            // Keep in bottom area
            if (this.y > canvas.height - GRID_SIZE * 3) this.y = canvas.height - GRID_SIZE * 3;
            if (this.y < canvas.height / 2) this.y = canvas.height / 2;

        } 
        else if (this.type === 'scorpion') {
            this.x += this.vx;
            
            // Poison mushrooms
            let gx = Math.floor(this.x / GRID_SIZE);
            let gy = Math.floor(this.y / GRID_SIZE);
            let mush = getMushroomAt(gx, gy);
            if (mush) {
                mush.isPoison = true;
            }

            if ((this.vx > 0 && this.x > canvas.width) || (this.vx < 0 && this.x < -GRID_SIZE)) {
                this.active = false;
            }
        }
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;

        if (this.type === 'flea') {
            roundRect(ctx, this.x + 4, this.y, 8, 12, 2);
        } else if (this.type === 'spider') {
            // Spider shape
            ctx.beginPath();
            ctx.arc(this.x+8, this.y+8, 6, 0, Math.PI*2); // Body
            ctx.moveTo(this.x, this.y); ctx.lineTo(this.x+16, this.y+16);
            ctx.moveTo(this.x+16, this.y); ctx.lineTo(this.x, this.y+16);
            ctx.stroke();
        } else if (this.type === 'scorpion') {
            roundRect(ctx, this.x + 2, this.y + 4, 12, 8, 2);
        }
        
        ctx.shadowBlur = 0;
    }

    checkCollision(player) {
        // Simple AABB
        let dx = Math.abs((this.x + 8) - (player.x + player.w/2));
        let dy = Math.abs((this.y + 8) - (player.y + player.h/2));
        
        if (dx < 12 && dy < 12) return true;
        return false;
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.life = 20;
        this.color = color;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw() {
        ctx.globalAlpha = this.life / 20;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 3, 3);
        ctx.globalAlpha = 1.0;
    }
}

// --- UTILS ---

function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
}

function createParticles(x, y, color) {
    for(let i=0; i<5; i++) particles.push(new Particle(x, y, color));
}

function getMushroomAt(gx, gy) {
    return mushrooms.find(m => m.gx === gx && m.gy === gy);
}

function spawnMushroom(gx, gy, isPoison = false) {
    if (gx < 0 || gx >= COLS || gy < 0 || gy >= ROWS) return;
    
    // Don't spawn on player
    if (gy * GRID_SIZE > canvas.height - GRID_SIZE * 4) return;

    let existing = getMushroomAt(gx, gy);
    if (!existing && Math.random() > 0.5) {
        mushrooms.push(new Mushroom(gx, gy, isPoison));
    }
}

function initLevel() {
    mushrooms = [];
    centipedes = [];
    enemies = [];
    bullets = [];
    
    // Initial Mushrooms (Classic: scattered in grid)
    for (let i = 0; i < 30 + level * 2; i++) {
        let gx = Math.floor(Math.random() * COLS);
        let gy = Math.floor(Math.random() * (ROWS - 6)) + 1;
        spawnMushroom(gx, gy);
    }

    // Centipedes
    let count = level === 1 ? 1 : Math.min(level, 10); 
    for(let i=0; i<count; i++) {
        let len = 10; // Standard length
        centipedes.push(new Centipede(GRID_SIZE * (i*2 + 5), GRID_SIZE * 2, len, 1.5)); // Start higher up
    }
}

function resetGame() {
    score = 0;
    lives = 3;
    level = 1;
    player = new Player();
    initLevel();
    gameState = 'PLAYING';
    document.getElementById('overlay').style.display = 'none';
    updateUI();
}

function playerDie() {
    createParticles(player.x + 7, player.y + 7, C_PLAYER);
    lives--;
    updateUI();
    
    if (lives <= 0) {
        gameState = 'GAMEOVER';
        document.querySelector('#overlay h1').innerText = "GAME OVER";
        document.querySelector('#overlay p').innerText = "PRESS SPACE TO RESTART";
        document.getElementById('overlay').style.display = 'flex';
    } else {
        // Reset player position
        player.x = canvas.width / 2 - player.w/2;
        // Clear nearby enemies? No, classic is unforgiving.
    }
}

function updateUI() {
    document.getElementById('scoreEl').innerText = score.toString().padStart(6, '0');
    document.getElementById('livesEl').innerText = lives;
    
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('centipede_high', highScore);
    }
    document.getElementById('highScoreEl').innerText = highScore.toString().padStart(6, '0');
}

// --- MAIN LOOP ---

function update() {
    if (gameState !== 'PLAYING') return;
    
    frames++;

    // Spawn Enemies
    if (frames % 600 === 0) { // Flea
        enemies.push(new Enemy('flea'));
    }
    if (frames % 900 === 0) { // Spider
        enemies.push(new Enemy('spider'));
    }
    if (frames % 700 === 0) { // Scorpion
        enemies.push(new Enemy('scorpion'));
    }

    player.update();

    // Bullets
    bullets.forEach(b => b.update());
    bullets = bullets.filter(b => b.active);

    // Mushrooms logic handled in collisions

    // Centipedes
    centipedes.forEach(c => c.update());
    
    // Check Level Clear
    if (centipedes.length === 0) {
        level++;
        initLevel();
        return; // Skip rest of frame to prevent glitches
    }

    // Enemies
    enemies.forEach(e => e.update());
    enemies = enemies.filter(e => e.active);

    // Particles
    particles.forEach(p => p.update());
    particles = particles.filter(p => p.life > 0);

    // Collisions: Bullet vs World
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        let hit = false;

        // Vs Mushrooms
        let gx = Math.floor(b.x / GRID_SIZE);
        let gy = Math.floor(b.y / GRID_SIZE);
        let mush = getMushroomAt(gx, gy);
        
        if (mush) {
            if(mush.hit()) {
                score += 1; // Small points for mushroom
                mushrooms.splice(mushrooms.indexOf(mush), 1);
            }
            hit = true;
        }

        // Vs Centipedes
        if (!hit) {
            for (let c of centipedes) {
                if (c.checkHit(b)) {
                    hit = true;
                    break; 
                }
            }
        }

        if (hit) b.active = false;
    }

    // Collisions: Player vs Enemies/Mushrooms
    let playerRect = {x: player.x, y: player.y, w: player.w, h: player.h};
    
    // Vs Poison Mushrooms
    for(let m of mushrooms) {
        if(m.isPoison && rectIntersect(playerRect, {x:m.x+4, y:m.y+4, w:8, h:8})) {
            playerDie();
            return;
        }
    }

    // Vs Enemies
    for (let e of enemies) {
        if (e.checkCollision(player)) {
            playerDie();
            return;
        }
    }

    // Vs Centipede Body
    for(let c of centipedes) {
        for(let s of c.segments) {
             if (rectIntersect(playerRect, {x:s.x+2, y:s.y+2, w:12, h:12})) {
                 playerDie();
                 return;
             }
        }
    }

    // Extra Life Check
    if (score > 0 && score % 12000 === 0) {
        lives++;
        updateUI();
    }
}

function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || 
             r2.x + r2.w < r1.x || 
             r2.y > r1.y + r1.h || 
             r2.y + r2.h < r1.y);
}

function draw() {
    // Clear
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'START') return;

    // Draw Grid Line (Subtle)
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    for(let i=0; i<COLS; i++) {
        ctx.beginPath(); ctx.moveTo(i*GRID_SIZE, 0); ctx.lineTo(i*GRID_SIZE, canvas.height); ctx.stroke();
    }
    
    // Draw Play Area Line (Separation)
    ctx.strokeStyle = '#444';
    let lineY = canvas.height - GRID_SIZE * 4;
    ctx.beginPath(); 
    ctx.moveTo(0, lineY); 
    ctx.lineTo(canvas.width, lineY); 
    ctx.stroke();

    mushrooms.forEach(m => m.draw());
    enemies.forEach(e => e.draw());
    centipedes.forEach(c => c.draw());
    bullets.forEach(b => b.draw());
    particles.forEach(p => p.draw());

    if (gameState === 'PLAYING') {
        player.draw();
    }
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// --- INPUT ---

window.addEventListener('keydown', e => {
    if(e.code === 'ArrowLeft') keys.ArrowLeft = true;
    if(e.code === 'ArrowRight') keys.ArrowRight = true;
    if(e.code === 'ArrowUp') keys.ArrowUp = true; // Optional fast move
    if(e.code === 'ArrowDown') keys.ArrowDown = true;
    
    if(e.code === 'Space') {
        keys.Space = true;
        if (gameState === 'START' || gameState === 'GAMEOVER') {
            resetGame();
        }
    }
});

window.addEventListener('keyup', e => {
    if(e.code === 'ArrowLeft') keys.ArrowLeft = false;
    if(e.code === 'ArrowRight') keys.ArrowRight = false;
    if(e.code === 'ArrowUp') keys.ArrowUp = false;
    if(e.code === 'ArrowDown') keys.ArrowDown = false;
    if(e.code === 'Space') keys.Space = false;
});

// Start
document.getElementById('highScoreEl').innerText = highScore.toString().padStart(6, '0');
loop();

</script>
</body>
</html>