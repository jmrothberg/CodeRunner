<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Classic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        #gameCanvas {
            border: 4px solid #0000ff;
            background: #000;
            display: block;
            margin: 20px auto;
        }
        
        #gameInfo {
            display: flex;
            justify-content: space-around;
            width: 600px;
            margin: 10px auto;
            font-size: 18px;
        }
        
        #score, #lives, #level {
            padding: 10px;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 3px solid #ffff00;
            border-radius: 10px;
            display: none;
        }
        
        #startScreen {
            text-align: center;
            padding: 20px;
        }
        
        button {
            padding: 15px 30px;
            font-size: 20px;
            background: #ffff00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        button:hover {
            background: #ffaa00;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>PAC-MAN</h1>
        <div id="gameInfo">
            <div id="score">SCORE: 0</div>
            <div id="lives">LIVES: 3</div>
            <div id="level">LEVEL: 1</div>
        </div>
        <canvas id="gameCanvas" width="600" height="700"></canvas>
        <div id="startScreen">
            <h2>Use Arrow Keys to Play</h2>
            <button onclick="startGame()">START GAME</button>
        </div>
        <div id="gameOver">
            <h2 id="gameOverText"></h2>
            <button onclick="restartGame()">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const TILE_SIZE = 20;
        const MAZE_WIDTH = 28;
        const MAZE_HEIGHT = 31;
        const CANVAS_WIDTH = MAZE_WIDTH * TILE_SIZE;
        const CANVAS_HEIGHT = MAZE_HEIGHT * TILE_SIZE;
        
        // Game state
        let gameState = 'start'; // start, playing, paused, gameOver
        let score = 0;
        let lives = 3;
        let level = 1;
        let pellets = [];
        let powerPellets = [];
        let totalPellets = 0;
        
        // Animation
        let animationFrame = 0;
        let pacmanMouthOpen = true;
        let pacmanMouthAngle = 0;
        
        // Classic Pac-Man maze layout (1 = wall, 0 = path, 2 = pellet, 3 = power pellet)
        const mazeLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
            [0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,0,0,0,0,0],
            [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
            [0,0,0,0,0,1,2,1,1,0,1,1,1,0,0,1,1,1,0,1,1,2,1,0,0,0,0,0],
            [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
            [0,0,0,0,0,0,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,0],
            [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
            [0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
            [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
            [0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
            [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,3,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,3,1],
            [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
            [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
            [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
            [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        // Pac-Man
        let pacman = {
            x: 14,
            y: 23,
            direction: 0, // 0: right, 1: down, 2: left, 3: up
            nextDirection: 0,
            speed: 1.5, // 2x faster (0.75 * 2)
            pixelX: 14 * TILE_SIZE + TILE_SIZE / 2,
            pixelY: 23 * TILE_SIZE + TILE_SIZE / 2
        };
        
        // Ghosts
        const ghosts = [
            { // Blinky (red) - chases directly
                x: 13,
                y: 11,
                pixelX: 13 * TILE_SIZE + TILE_SIZE / 2,
                pixelY: 11 * TILE_SIZE + TILE_SIZE / 2,
                direction: 2,
                color: '#ff0000',
                mode: 'scatter', // scatter, chase, frightened, eaten
                targetTile: {x: 25, y: 0},
                speed: 1.0, // 2x faster (0.5 * 2)
                home: {x: 13, y: 11},
                respawnTimer: 0
            },
            { // Pinky (pink) - targets ahead of Pac-Man
                x: 14,
                y: 11,
                pixelX: 14 * TILE_SIZE + TILE_SIZE / 2,
                pixelY: 11 * TILE_SIZE + TILE_SIZE / 2,
                direction: 2,
                color: '#ffb8ff',
                mode: 'scatter',
                targetTile: {x: 2, y: 0},
                speed: 1.0, // 2x faster (0.5 * 2)
                home: {x: 14, y: 11},
                respawnTimer: 0
            },
            { // Inky (cyan) - complex targeting
                x: 13,
                y: 14,
                pixelX: 13 * TILE_SIZE + TILE_SIZE / 2,
                pixelY: 14 * TILE_SIZE + TILE_SIZE / 2,
                direction: 0,
                color: '#00ffff',
                mode: 'scatter',
                targetTile: {x: 27, y: 29},
                speed: 1.0, // 2x faster (0.5 * 2)
                home: {x: 13, y: 14},
                respawnTimer: 0
            },
            { // Clyde (orange) - random when close
                x: 14,
                y: 14,
                pixelX: 14 * TILE_SIZE + TILE_SIZE / 2,
                pixelY: 14 * TILE_SIZE + TILE_SIZE / 2,
                direction: 0,
                color: '#ffb851',
                mode: 'scatter',
                targetTile: {x: 0, y: 29},
                speed: 1.0, // 2x faster (0.5 * 2)
                home: {x: 14, y: 14},
                respawnTimer: 0
            }
        ];
        
        let frightenedTimer = 0;
        let modeTimer = 0;
        let modeCycle = 0; // 0: scatter, 1: chase
        
        // Fruit system
        let fruit = null;
        let fruitTimer = 0;
        let fruitSpawned = false;
        const FRUIT_SPAWN_TIME = 1800; // 30 seconds at 60fps
        const FRUIT_DURATION = 600; // 10 seconds
        const FRUIT_POINTS = [100, 300, 500, 700, 1000, 2000, 3000, 5000];
        
        // Initialize pellets
        function initPellets() {
            pellets = [];
            powerPellets = [];
            totalPellets = 0;
            
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (mazeLayout[y][x] === 2) {
                        pellets.push({x: x * TILE_SIZE + TILE_SIZE / 2, y: y * TILE_SIZE + TILE_SIZE / 2});
                        totalPellets++;
                    } else if (mazeLayout[y][x] === 3) {
                        powerPellets.push({x: x * TILE_SIZE + TILE_SIZE / 2, y: y * TILE_SIZE + TILE_SIZE / 2, eaten: false});
                        totalPellets++;
                    }
                }
            }
        }
        
        // Check if position is valid (not a wall)
        function isValidPosition(x, y) {
            // Allow wrapping for tunnel (left/right sides)
            let tileX = Math.floor(x / TILE_SIZE);
            const tileY = Math.floor(y / TILE_SIZE);
            
            // Wrap around for tunnel
            if (tileX < 0) tileX = MAZE_WIDTH - 1;
            if (tileX >= MAZE_WIDTH) tileX = 0;
            
            if (tileY < 0 || tileY >= MAZE_HEIGHT) {
                return false;
            }
            
            return mazeLayout[tileY][tileX] !== 1;
        }
        
        // Check if at center of tile
        function isAtTileCenter(pixelX, pixelY) {
            const tileX = Math.floor(pixelX / TILE_SIZE);
            const tileY = Math.floor(pixelY / TILE_SIZE);
            const centerX = tileX * TILE_SIZE + TILE_SIZE / 2;
            const centerY = tileY * TILE_SIZE + TILE_SIZE / 2;
            const threshold = 5; // Increased threshold for faster movement
            
            return Math.abs(pixelX - centerX) < threshold && Math.abs(pixelY - centerY) < threshold;
        }
        
        // Get distance between two points
        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        
        // Ghost AI - Blinky (direct chase, aggressive)
        function getBlinkyTarget() {
            // Use pixel position for more accurate targeting
            const targetX = Math.floor(pacman.pixelX / TILE_SIZE);
            const targetY = Math.floor(pacman.pixelY / TILE_SIZE);
            return {x: targetX, y: targetY};
        }
        
        // Ghost AI - Pinky (4 tiles ahead, improved)
        function getPinkyTarget() {
            let aheadX = pacman.x;
            let aheadY = pacman.y;
            
            if (pacman.direction === 0) aheadX += 4; // right
            else if (pacman.direction === 1) aheadY += 4; // down
            else if (pacman.direction === 2) aheadX -= 4; // left
            else if (pacman.direction === 3) aheadY -= 4; // up
            
            // Clamp to valid maze bounds
            aheadX = Math.max(0, Math.min(MAZE_WIDTH - 1, aheadX));
            aheadY = Math.max(0, Math.min(MAZE_HEIGHT - 1, aheadY));
            
            return {x: aheadX, y: aheadY};
        }
        
        // Ghost AI - Inky (complex, improved)
        function getInkyTarget() {
            const blinky = ghosts[0];
            let aheadX = pacman.x;
            let aheadY = pacman.y;
            
            if (pacman.direction === 0) aheadX += 2;
            else if (pacman.direction === 1) aheadY += 2;
            else if (pacman.direction === 2) aheadX -= 2;
            else if (pacman.direction === 3) aheadY -= 2;
            
            const vectorX = aheadX - blinky.x;
            const vectorY = aheadY - blinky.y;
            
            const targetX = aheadX + vectorX;
            const targetY = aheadY + vectorY;
            
            // Clamp to valid bounds
            return {
                x: Math.max(0, Math.min(MAZE_WIDTH - 1, targetX)),
                y: Math.max(0, Math.min(MAZE_HEIGHT - 1, targetY))
            };
        }
        
        // Ghost AI - Clyde (scatter when close, improved)
        function getClydeTarget() {
            const distance = getDistance(ghosts[3].x, ghosts[3].y, pacman.x, pacman.y);
            if (distance < 8) {
                return ghosts[3].targetTile; // scatter
            }
            // Direct chase when far
            return {x: pacman.x, y: pacman.y};
        }
        
        // Get best direction for ghost (improved AI)
        function getGhostDirection(ghost) {
            let target;
            
            if (ghost.mode === 'frightened') {
                // Random direction but avoid walls
                const directions = [];
                const dx = [1, 0, -1, 0];
                const dy = [0, 1, 0, -1];
                
                for (let i = 0; i < 4; i++) {
                    const newX = ghost.x + dx[i];
                    const newY = ghost.y + dy[i];
                    if (isValidPosition(newX * TILE_SIZE + TILE_SIZE / 2, newY * TILE_SIZE + TILE_SIZE / 2)) {
                        directions.push(i);
                    }
                }
                
                if (directions.length > 0) {
                    return directions[Math.floor(Math.random() * directions.length)];
                }
                return ghost.direction;
            } else if (ghost.mode === 'eaten') {
                target = ghost.home;
            } else if (ghost.mode === 'scatter') {
                target = ghost.targetTile;
            } else { // chase - improved targeting
                if (ghost === ghosts[0]) target = getBlinkyTarget();
                else if (ghost === ghosts[1]) target = getPinkyTarget();
                else if (ghost === ghosts[2]) target = getInkyTarget();
                else target = getClydeTarget();
            }
            
            const directions = [];
            const dx = [1, 0, -1, 0];
            const dy = [0, 1, 0, -1];
            
            for (let i = 0; i < 4; i++) {
                const newX = ghost.x + dx[i];
                const newY = ghost.y + dy[i];
                
                // Don't reverse direction (except when eaten and going home)
                if (ghost.mode !== 'eaten' && (ghost.direction + 2) % 4 === i) continue;
                
                if (isValidPosition(newX * TILE_SIZE + TILE_SIZE / 2, newY * TILE_SIZE + TILE_SIZE / 2)) {
                    const distance = getDistance(newX, newY, target.x, target.y);
                    directions.push({dir: i, dist: distance});
                }
            }
            
            if (directions.length === 0) return ghost.direction;
            
            // Sort by distance (closest for chase/scatter/eaten, farthest for frightened)
            directions.sort((a, b) => {
                if (ghost.mode === 'frightened') return b.dist - a.dist;
                return a.dist - b.dist;
            });
            
            return directions[0].dir;
        }
        
        // Update Pac-Man
        function updatePacman() {
            const dx = [1, 0, -1, 0];
            const dy = [0, 1, 0, -1];
            
            // Snap to tile center if close enough (prevents getting stuck)
            const tileX = Math.floor(pacman.pixelX / TILE_SIZE);
            const tileY = Math.floor(pacman.pixelY / TILE_SIZE);
            const centerX = tileX * TILE_SIZE + TILE_SIZE / 2;
            const centerY = tileY * TILE_SIZE + TILE_SIZE / 2;
            
            // If close to center, snap to it for smoother turning
            if (Math.abs(pacman.pixelX - centerX) < pacman.speed && Math.abs(pacman.pixelY - centerY) < pacman.speed) {
                pacman.pixelX = centerX;
                pacman.pixelY = centerY;
            }
            
            // Try to change direction
            if (pacman.nextDirection !== pacman.direction) {
                const nextX = pacman.x + dx[pacman.nextDirection];
                const nextY = pacman.y + dy[pacman.nextDirection];
                
                if (isValidPosition(nextX * TILE_SIZE + TILE_SIZE / 2, nextY * TILE_SIZE + TILE_SIZE / 2)) {
                    if (isAtTileCenter(pacman.pixelX, pacman.pixelY)) {
                        pacman.direction = pacman.nextDirection;
                        // Snap to exact center when changing direction
                        pacman.pixelX = pacman.x * TILE_SIZE + TILE_SIZE / 2;
                        pacman.pixelY = pacman.y * TILE_SIZE + TILE_SIZE / 2;
                    }
                }
            }
            
            // Move
            const moveX = dx[pacman.direction] * pacman.speed;
            const moveY = dy[pacman.direction] * pacman.speed;
            
            const newPixelX = pacman.pixelX + moveX;
            const newPixelY = pacman.pixelY + moveY;
            
            // Check collision ahead before moving
            if (isValidPosition(newPixelX, newPixelY)) {
                pacman.pixelX = newPixelX;
                pacman.pixelY = newPixelY;
            } else {
                // If can't move forward, snap to current tile center
                pacman.pixelX = pacman.x * TILE_SIZE + TILE_SIZE / 2;
                pacman.pixelY = pacman.y * TILE_SIZE + TILE_SIZE / 2;
            }
            
            // Wrap around tunnel (left/right connection)
            if (pacman.pixelX < -TILE_SIZE / 2) {
                pacman.pixelX = MAZE_WIDTH * TILE_SIZE - TILE_SIZE / 2;
            } else if (pacman.pixelX > MAZE_WIDTH * TILE_SIZE - TILE_SIZE / 2) {
                pacman.pixelX = -TILE_SIZE / 2;
            }
            
            // Update tile position
            pacman.x = Math.floor(pacman.pixelX / TILE_SIZE);
            pacman.y = Math.floor(pacman.pixelY / TILE_SIZE);
            
            // Collect pellets
            pellets = pellets.filter(pellet => {
                const dist = getDistance(pacman.pixelX, pacman.pixelY, pellet.x, pellet.y);
                if (dist < TILE_SIZE / 2) {
                    score += 10;
                    updateScore();
                    return false;
                }
                return true;
            });
            
            // Collect power pellets
            powerPellets.forEach(pellet => {
                if (!pellet.eaten) {
                    const dist = getDistance(pacman.pixelX, pacman.pixelY, pellet.x, pellet.y);
                    if (dist < TILE_SIZE / 2) {
                        pellet.eaten = true;
                        score += 50;
                        updateScore();
                        frightenedTimer = 600; // 10 seconds at 60fps
                        ghosts.forEach(ghost => {
                            if (ghost.mode !== 'eaten') {
                                ghost.mode = 'frightened';
                            }
                        });
                    }
                }
            });
            
            // Collect fruit
            if (fruit && fruit.active) {
                const dist = getDistance(pacman.pixelX, pacman.pixelY, fruit.x, fruit.y);
                if (dist < TILE_SIZE) {
                    const points = FRUIT_POINTS[Math.min(level - 1, FRUIT_POINTS.length - 1)];
                    score += points;
                    updateScore();
                    fruit = null;
                }
            }
        }
        
        // Update ghosts
        function updateGhosts() {
            // Update mode timers
            modeTimer++;
            if (modeTimer > 700) { // ~11.7 seconds
                modeTimer = 0;
                modeCycle = (modeCycle + 1) % 2;
                
                ghosts.forEach(ghost => {
                    if (ghost.mode !== 'frightened' && ghost.mode !== 'eaten') {
                        ghost.mode = modeCycle === 0 ? 'scatter' : 'chase';
                    }
                });
            }
            
            // Update frightened timer
            if (frightenedTimer > 0) {
                frightenedTimer--;
                if (frightenedTimer === 0) {
                    ghosts.forEach(ghost => {
                        if (ghost.mode === 'frightened') {
                            ghost.mode = 'scatter';
                        }
                    });
                }
            }
            
            ghosts.forEach(ghost => {
                // Update respawn timer for eaten ghosts
                if (ghost.mode === 'eaten') {
                    ghost.respawnTimer++;
                }
                
                // Update tile position
                ghost.x = Math.floor(ghost.pixelX / TILE_SIZE);
                ghost.y = Math.floor(ghost.pixelY / TILE_SIZE);
                
                // Change direction at tile center
                if (isAtTileCenter(ghost.pixelX, ghost.pixelY)) {
                    ghost.direction = getGhostDirection(ghost);
                    
                    // Check if reached home after being eaten - rejuvinate
                    if (ghost.mode === 'eaten' && ghost.x === ghost.home.x && ghost.y === ghost.home.y) {
                        ghost.mode = 'scatter';
                        ghost.respawnTimer = 0;
                        // Reset to home position exactly
                        ghost.pixelX = ghost.home.x * TILE_SIZE + TILE_SIZE / 2;
                        ghost.pixelY = ghost.home.y * TILE_SIZE + TILE_SIZE / 2;
                    }
                }
                
                // Move
                const dx = [1, 0, -1, 0];
                const dy = [0, 1, 0, -1];
                
                let speed = ghost.speed;
                if (ghost.mode === 'frightened') speed *= 0.5;
                else if (ghost.mode === 'eaten') speed *= 1.5;
                
                const moveX = dx[ghost.direction] * speed;
                const moveY = dy[ghost.direction] * speed;
                
                const newPixelX = ghost.pixelX + moveX;
                const newPixelY = ghost.pixelY + moveY;
                
                if (isValidPosition(newPixelX, newPixelY)) {
                    ghost.pixelX = newPixelX;
                    ghost.pixelY = newPixelY;
                }
                
                // Wrap around tunnel (left/right connection)
                if (ghost.pixelX < -TILE_SIZE / 2) {
                    ghost.pixelX = MAZE_WIDTH * TILE_SIZE - TILE_SIZE / 2;
                } else if (ghost.pixelX > MAZE_WIDTH * TILE_SIZE - TILE_SIZE / 2) {
                    ghost.pixelX = -TILE_SIZE / 2;
                }
            });
        }
        
        // Update fruit system
        function updateFruit() {
            fruitTimer++;
            
            // Spawn fruit after some time
            if (!fruitSpawned && fruitTimer >= FRUIT_SPAWN_TIME) {
                fruit = {
                    x: 14 * TILE_SIZE + TILE_SIZE / 2,
                    y: 17 * TILE_SIZE + TILE_SIZE / 2,
                    active: true,
                    spawnTime: fruitTimer
                };
                fruitSpawned = true;
            }
            
            // Remove fruit after duration
            if (fruit && fruit.active && (fruitTimer - fruit.spawnTime) >= FRUIT_DURATION) {
                fruit = null;
            }
        }
        
        // Check collisions
        function checkCollisions() {
            ghosts.forEach(ghost => {
                const dist = getDistance(pacman.pixelX, pacman.pixelY, ghost.pixelX, ghost.pixelY);
                
                if (dist < TILE_SIZE * 0.7) {
                    if (ghost.mode === 'frightened') {
                        // Eat ghost - make it return home
                        ghost.mode = 'eaten';
                        ghost.respawnTimer = 0;
                        // Calculate points based on how many ghosts eaten recently
                        let multiplier = 1;
                        ghosts.forEach(g => {
                            if (g.mode === 'eaten') multiplier++;
                        });
                        score += 200 * multiplier;
                        updateScore();
                    } else if (ghost.mode !== 'eaten') {
                        // Pac-Man dies
                        lives--;
                        updateLives();
                        
                        if (lives <= 0) {
                            gameOver();
                        } else {
                            resetPositions();
                        }
                    }
                }
            });
        }
        
        // Reset positions
        function resetPositions() {
            pacman.x = 14;
            pacman.y = 23;
            pacman.pixelX = 14 * TILE_SIZE + TILE_SIZE / 2;
            pacman.pixelY = 23 * TILE_SIZE + TILE_SIZE / 2;
            pacman.direction = 0;
            pacman.nextDirection = 0;
            
            ghosts[0].x = 13;
            ghosts[0].y = 11;
            ghosts[0].pixelX = 13 * TILE_SIZE + TILE_SIZE / 2;
            ghosts[0].pixelY = 11 * TILE_SIZE + TILE_SIZE / 2;
            ghosts[0].direction = 2;
            ghosts[0].mode = 'scatter';
            
            ghosts[1].x = 14;
            ghosts[1].y = 11;
            ghosts[1].pixelX = 14 * TILE_SIZE + TILE_SIZE / 2;
            ghosts[1].pixelY = 11 * TILE_SIZE + TILE_SIZE / 2;
            ghosts[1].direction = 2;
            ghosts[1].mode = 'scatter';
            
            ghosts[2].x = 13;
            ghosts[2].y = 14;
            ghosts[2].pixelX = 13 * TILE_SIZE + TILE_SIZE / 2;
            ghosts[2].pixelY = 14 * TILE_SIZE + TILE_SIZE / 2;
            ghosts[2].direction = 0;
            ghosts[2].mode = 'scatter';
            
            ghosts[3].x = 14;
            ghosts[3].y = 14;
            ghosts[3].pixelX = 14 * TILE_SIZE + TILE_SIZE / 2;
            ghosts[3].pixelY = 14 * TILE_SIZE + TILE_SIZE / 2;
            ghosts[3].direction = 0;
            ghosts[3].mode = 'scatter';
            
            // Reset respawn timers
            ghosts.forEach(ghost => {
                ghost.respawnTimer = 0;
            });
            
            frightenedTimer = 0;
            modeTimer = 0;
            modeCycle = 0;
            
            // Reset fruit
            fruit = null;
            fruitTimer = 0;
            fruitSpawned = false;
        }
        
        // Draw maze
        function drawMaze() {
            ctx.fillStyle = '#2121ff';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.fillStyle = '#000';
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (mazeLayout[y][x] === 1) {
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }
        
        // Draw pellets
        function drawPellets() {
            ctx.fillStyle = '#ffb8ff';
            pellets.forEach(pellet => {
                ctx.beginPath();
                ctx.arc(pellet.x, pellet.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            powerPellets.forEach(pellet => {
                if (!pellet.eaten) {
                    ctx.fillStyle = '#ffb8ff';
                    ctx.beginPath();
                    ctx.arc(pellet.x, pellet.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Pulsing animation
                    const pulse = Math.sin(animationFrame * 0.2) * 0.3 + 1;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(pellet.x, pellet.y, 6 * pulse, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
        
        // Draw fruit
        function drawFruit() {
            if (fruit && fruit.active) {
                // Draw cherry (simple circle)
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(fruit.x, fruit.y, TILE_SIZE * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw stem
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(fruit.x - 2, fruit.y - TILE_SIZE * 0.4, 4, 6);
                
                // Pulsing animation
                const pulse = Math.sin(animationFrame * 0.15) * 0.1 + 1;
                ctx.globalAlpha = 0.8 + Math.sin(animationFrame * 0.2) * 0.2;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(fruit.x, fruit.y, TILE_SIZE * 0.4 * pulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
        
        // Draw Pac-Man
        function drawPacman() {
            ctx.save();
            ctx.translate(pacman.pixelX, pacman.pixelY);
            
            // Rotate based on direction
            const rotations = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
            ctx.rotate(rotations[pacman.direction]);
            
            ctx.fillStyle = '#ffff00';
            
            // Animate mouth
            pacmanMouthAngle += 0.3;
            const mouthOpen = Math.abs(Math.sin(pacmanMouthAngle)) * 0.4 + 0.2;
            
            ctx.beginPath();
            ctx.arc(0, 0, TILE_SIZE * 0.7, mouthOpen, Math.PI * 2 - mouthOpen);
            ctx.lineTo(0, 0);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Draw ghost
        function drawGhost(ghost) {
            ctx.save();
            ctx.translate(ghost.pixelX, ghost.pixelY);
            
            let color = ghost.color;
            if (ghost.mode === 'frightened') {
                color = '#2121de';
            } else if (ghost.mode === 'eaten') {
                color = '#000';
            }
            
            // Ghost body (rounded rectangle)
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, -TILE_SIZE * 0.2, TILE_SIZE * 0.6, Math.PI, 0, false);
            ctx.rect(-TILE_SIZE * 0.6, -TILE_SIZE * 0.2, TILE_SIZE * 1.2, TILE_SIZE * 0.8);
            ctx.fill();
            
            // Bottom wavy part
            if (ghost.mode !== 'eaten') {
                const wave = Math.sin(animationFrame * 0.3 + ghost.x * 0.5) * 3;
                ctx.beginPath();
                for (let i = -TILE_SIZE * 0.6; i <= TILE_SIZE * 0.6; i += TILE_SIZE * 0.3) {
                    const y = TILE_SIZE * 0.6 + wave;
                    if (i === -TILE_SIZE * 0.6) {
                        ctx.moveTo(i, y);
                    } else {
                        ctx.lineTo(i, y);
                    }
                }
                ctx.lineTo(TILE_SIZE * 0.6, TILE_SIZE * 0.6);
                ctx.lineTo(TILE_SIZE * 0.6, TILE_SIZE * 0.8);
                ctx.lineTo(-TILE_SIZE * 0.6, TILE_SIZE * 0.8);
                ctx.closePath();
                ctx.fill();
            }
            
            // Eyes
            if (ghost.mode !== 'frightened' && ghost.mode !== 'eaten') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-TILE_SIZE * 0.25, -TILE_SIZE * 0.1, TILE_SIZE * 0.15, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(TILE_SIZE * 0.25, -TILE_SIZE * 0.1, TILE_SIZE * 0.15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000';
                // Eye direction
                const eyeDx = [1, 0, -1, 0];
                const eyeDy = [0, 1, 0, -1];
                const eyeOffsetX = eyeDx[ghost.direction] * TILE_SIZE * 0.05;
                const eyeOffsetY = eyeDy[ghost.direction] * TILE_SIZE * 0.05;
                
                ctx.beginPath();
                ctx.arc(-TILE_SIZE * 0.25 + eyeOffsetX, -TILE_SIZE * 0.1 + eyeOffsetY, TILE_SIZE * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(TILE_SIZE * 0.25 + eyeOffsetX, -TILE_SIZE * 0.1 + eyeOffsetY, TILE_SIZE * 0.08, 0, Math.PI * 2);
                ctx.fill();
            } else if (ghost.mode === 'frightened') {
                // Frightened eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-TILE_SIZE * 0.2, 0, TILE_SIZE * 0.1, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(TILE_SIZE * 0.2, 0, TILE_SIZE * 0.1, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        // Update UI
        function updateScore() {
            document.getElementById('score').textContent = `SCORE: ${score}`;
        }
        
        function updateLives() {
            document.getElementById('lives').textContent = `LIVES: ${lives}`;
        }
        
        function updateLevel() {
            document.getElementById('level').textContent = `LEVEL: ${level}`;
        }
        
        // Game loop
        function gameLoop() {
            if (gameState !== 'playing') return;
            
            animationFrame++;
            
            updatePacman();
            updateGhosts();
            updateFruit();
            checkCollisions();
            
            // Check win condition
            if (pellets.length === 0 && powerPellets.every(p => p.eaten)) {
                level++;
                updateLevel();
                initPellets();
                resetPositions();
                // Reset fruit for new level
                fruit = null;
                fruitTimer = 0;
                fruitSpawned = false;
            }
            
            // Draw everything
            drawMaze();
            drawPellets();
            drawFruit();
            drawPacman();
            ghosts.forEach(ghost => drawGhost(ghost));
            
            requestAnimationFrame(gameLoop);
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing') return;
            
            if (e.key === 'ArrowRight') pacman.nextDirection = 0;
            else if (e.key === 'ArrowDown') pacman.nextDirection = 1;
            else if (e.key === 'ArrowLeft') pacman.nextDirection = 2;
            else if (e.key === 'ArrowUp') pacman.nextDirection = 3;
        });
        
        // Game functions
        function startGame() {
            gameState = 'playing';
            score = 0;
            lives = 3;
            level = 1;
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            initPellets();
            resetPositions();
            updateScore();
            updateLives();
            updateLevel();
            gameLoop();
        }
        
        function gameOver() {
            gameState = 'gameOver';
            document.getElementById('gameOverText').textContent = 'GAME OVER';
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restartGame() {
            startGame();
        }
        
        // Initial draw
        drawMaze();
    </script>
</body>
</html>
